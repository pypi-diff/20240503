# Comparing `tmp/dara_core-1.8.5-py3-none-any.whl.zip` & `tmp/dara_core-1.8.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 3896760 bytes, number of entries: 112
+Zip file size: 3904350 bytes, number of entries: 112
 -rw-r--r--  2.0 unx     2186 b- defN 80-Jan-01 00:00 dara/core/__init__.py
 -rw-r--r--  2.0 unx      965 b- defN 80-Jan-01 00:00 dara/core/actions.py
 -rw-r--r--  2.0 unx      851 b- defN 80-Jan-01 00:00 dara/core/auth/__init__.py
 -rw-r--r--  2.0 unx     2638 b- defN 80-Jan-01 00:00 dara/core/auth/base.py
 -rw-r--r--  2.0 unx     4692 b- defN 80-Jan-01 00:00 dara/core/auth/basic.py
 -rw-r--r--  2.0 unx     3511 b- defN 80-Jan-01 00:00 dara/core/auth/definitions.py
 -rw-r--r--  2.0 unx     4380 b- defN 80-Jan-01 00:00 dara/core/auth/routes.py
@@ -78,15 +78,15 @@
 -rw-r--r--  2.0 unx    13093 b- defN 80-Jan-01 00:00 dara/core/logging.py
 -rw-r--r--  2.0 unx    17899 b- defN 80-Jan-01 00:00 dara/core/main.py
 -rw-r--r--  2.0 unx      823 b- defN 80-Jan-01 00:00 dara/core/metrics/__init__.py
 -rw-r--r--  2.0 unx     2580 b- defN 80-Jan-01 00:00 dara/core/metrics/cache.py
 -rw-r--r--  2.0 unx     1833 b- defN 80-Jan-01 00:00 dara/core/metrics/runtime.py
 -rw-r--r--  2.0 unx     2231 b- defN 80-Jan-01 00:00 dara/core/metrics/utils.py
 -rw-r--r--  2.0 unx    10379 b- defN 80-Jan-01 00:00 dara/core/persistence.py
--rw-r--r--  2.0 unx  4793040 b- defN 80-Jan-01 00:00 dara/core/umd/dara.core.umd.js
+-rw-r--r--  2.0 unx  4834104 b- defN 80-Jan-01 00:00 dara/core/umd/dara.core.umd.js
 -rw-r--r--  2.0 unx  4095007 b- defN 80-Jan-01 00:00 dara/core/umd/style.css
 -rw-r--r--  2.0 unx      577 b- defN 80-Jan-01 00:00 dara/core/visual/__init__.py
 -rw-r--r--  2.0 unx     1811 b- defN 80-Jan-01 00:00 dara/core/visual/components/__init__.py
 -rw-r--r--  2.0 unx      692 b- defN 80-Jan-01 00:00 dara/core/visual/components/dynamic_component.py
 -rw-r--r--  2.0 unx     3378 b- defN 80-Jan-01 00:00 dara/core/visual/components/fallback.py
 -rw-r--r--  2.0 unx     6600 b- defN 80-Jan-01 00:00 dara/core/visual/components/for_cmp.py
 -rw-r--r--  2.0 unx      866 b- defN 80-Jan-01 00:00 dara/core/visual/components/invalid_component.py
@@ -102,13 +102,13 @@
 -rw-r--r--  2.0 unx    13608 b- defN 80-Jan-01 00:00 dara/core/visual/dynamic_component.py
 -rw-r--r--  2.0 unx     5840 b- defN 80-Jan-01 00:00 dara/core/visual/progress_updater.py
 -rw-r--r--  2.0 unx     5707 b- defN 80-Jan-01 00:00 dara/core/visual/template.py
 -rw-r--r--  2.0 unx      794 b- defN 80-Jan-01 00:00 dara/core/visual/themes/__init__.py
 -rw-r--r--  2.0 unx     1942 b- defN 80-Jan-01 00:00 dara/core/visual/themes/dark.py
 -rw-r--r--  2.0 unx     2744 b- defN 80-Jan-01 00:00 dara/core/visual/themes/definitions.py
 -rw-r--r--  2.0 unx     1944 b- defN 80-Jan-01 00:00 dara/core/visual/themes/light.py
--rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_core-1.8.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     6773 b- defN 80-Jan-01 00:00 dara_core-1.8.5.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_core-1.8.5.dist-info/WHEEL
--rw-r--r--  2.0 unx      139 b- defN 80-Jan-01 00:00 dara_core-1.8.5.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx    10153 b- defN 16-Jan-01 00:00 dara_core-1.8.5.dist-info/RECORD
-112 files, 9969342 bytes uncompressed, 3880578 bytes compressed:  61.1%
+-rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_core-1.8.6.dist-info/LICENSE
+-rw-r--r--  2.0 unx     6773 b- defN 80-Jan-01 00:00 dara_core-1.8.6.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_core-1.8.6.dist-info/WHEEL
+-rw-r--r--  2.0 unx      139 b- defN 80-Jan-01 00:00 dara_core-1.8.6.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx    10153 b- defN 16-Jan-01 00:00 dara_core-1.8.6.dist-info/RECORD
+112 files, 10010406 bytes uncompressed, 3888168 bytes compressed:  61.2%
```

## zipnote {}

```diff
@@ -315,23 +315,23 @@
 
 Filename: dara/core/visual/themes/definitions.py
 Comment: 
 
 Filename: dara/core/visual/themes/light.py
 Comment: 
 
-Filename: dara_core-1.8.5.dist-info/LICENSE
+Filename: dara_core-1.8.6.dist-info/LICENSE
 Comment: 
 
-Filename: dara_core-1.8.5.dist-info/METADATA
+Filename: dara_core-1.8.6.dist-info/METADATA
 Comment: 
 
-Filename: dara_core-1.8.5.dist-info/WHEEL
+Filename: dara_core-1.8.6.dist-info/WHEEL
 Comment: 
 
-Filename: dara_core-1.8.5.dist-info/entry_points.txt
+Filename: dara_core-1.8.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: dara_core-1.8.5.dist-info/RECORD
+Filename: dara_core-1.8.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dara/core/umd/dara.core.umd.js

### js-beautify {}

```diff
@@ -860,15 +860,15 @@
             goForward,
             block,
             listen
         };
         return history2;
     }
 
-    function clamp$1(n2, lowerBound, upperBound) {
+    function clamp$2(n2, lowerBound, upperBound) {
         return Math.min(Math.max(n2, lowerBound), upperBound);
     }
 
     function createMemoryHistory(props) {
         if (props === void 0) {
             props = {};
         }
@@ -887,15 +887,15 @@
             history2.length = history2.entries.length;
             transitionManager.notifyListeners(history2.location, history2.action);
         }
 
         function createKey() {
             return Math.random().toString(36).substr(2, keyLength);
         }
-        var index2 = clamp$1(initialIndex, 0, initialEntries.length - 1);
+        var index2 = clamp$2(initialIndex, 0, initialEntries.length - 1);
         var entries = initialEntries.map(function(entry) {
             return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
         });
         var createHref = createPath;
 
         function push(path, state) {
             var action = "PUSH";
@@ -931,15 +931,15 @@
                     action,
                     location: location2
                 });
             });
         }
 
         function go(n2) {
-            var nextIndex2 = clamp$1(history2.index + n2, 0, history2.entries.length - 1);
+            var nextIndex2 = clamp$2(history2.index + n2, 0, history2.entries.length - 1);
             var action = "POP";
             var location2 = history2.entries[nextIndex2];
             transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok) {
                 if (ok) {
                     setState({
                         action,
                         location: location2,
@@ -2940,16 +2940,16 @@
             x2 -= x2 >> 1 & 1431655765;
             x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
             x2 = x2 + (x2 >> 4) & 252645135;
             x2 += x2 >> 8;
             x2 += x2 >> 16;
             return x2 & 127;
         };
-        var hashFragment = function hashFragment2(shift, h2) {
-            return h2 >>> shift & MASK;
+        var hashFragment = function hashFragment2(shift2, h2) {
+            return h2 >>> shift2 & MASK;
         };
         var toBitmap = function toBitmap2(x2) {
             return 1 << x2;
         };
         var fromBitmap = function fromBitmap2(bitmap, bit) {
             return popcount(bitmap & bit - 1);
         };
@@ -3058,44 +3058,44 @@
         };
         var isLeaf = function isLeaf2(node) {
             return node === empty || node.type === LEAF || node.type === COLLISION;
         };
         var expand = function expand2(edit, frag, child, bitmap, subNodes) {
             var arr = [];
             var bit = bitmap;
-            var count2 = 0;
+            var count3 = 0;
             for (var i2 = 0; bit; ++i2) {
                 if (bit & 1)
-                    arr[i2] = subNodes[count2++];
+                    arr[i2] = subNodes[count3++];
                 bit >>>= 1;
             }
             arr[frag] = child;
-            return ArrayNode(edit, count2 + 1, arr);
+            return ArrayNode(edit, count3 + 1, arr);
         };
-        var pack = function pack2(edit, count2, removed, elements) {
-            var children = new Array(count2 - 1);
+        var pack = function pack2(edit, count3, removed, elements) {
+            var children = new Array(count3 - 1);
             var g2 = 0;
             var bitmap = 0;
             for (var i2 = 0, len = elements.length; i2 < len; ++i2) {
                 if (i2 !== removed) {
                     var elem = elements[i2];
                     if (elem && !isEmptyNode(elem)) {
                         children[g2++] = elem;
                         bitmap |= 1 << i2;
                     }
                 }
             }
             return IndexedNode(edit, bitmap, children);
         };
-        var mergeLeaves = function mergeLeaves2(edit, shift, h1, n1, h2, n2) {
+        var mergeLeaves = function mergeLeaves2(edit, shift2, h1, n1, h2, n2) {
             if (h1 === h2)
                 return Collision(edit, h1, [n2, n1]);
-            var subH1 = hashFragment(shift, h1);
-            var subH2 = hashFragment(shift, h2);
-            return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
+            var subH1 = hashFragment(shift2, h1);
+            var subH2 = hashFragment(shift2, h2);
+            return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift2 + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
         };
         var updateCollisionList = function updateCollisionList2(mutate2, edit, keyEq, h2, list, f2, k2, size2) {
             var len = list.length;
             for (var i2 = 0; i2 < len; ++i2) {
                 var child = list[i2];
                 if (keyEq(k2, child.key)) {
                     var value = child.value;
@@ -3114,15 +3114,15 @@
                 return list;
             ++size2.value;
             return arrayUpdate(mutate2, len, Leaf(edit, h2, k2, newValue), list);
         };
         var canEditNode = function canEditNode2(edit, node) {
             return edit === node.edit;
         };
-        var Leaf__modify = function Leaf__modify2(edit, keyEq, shift, f2, h2, k2, size2) {
+        var Leaf__modify = function Leaf__modify2(edit, keyEq, shift2, f2, h2, k2, size2) {
             if (keyEq(k2, this.key)) {
                 var _v = f2(this.value);
                 if (_v === this.value)
                     return this;
                 else if (_v === nothing) {
                     --size2.value;
                     return empty;
@@ -3133,39 +3133,39 @@
                 }
                 return Leaf(edit, h2, k2, _v);
             }
             var v2 = f2();
             if (v2 === nothing)
                 return this;
             ++size2.value;
-            return mergeLeaves(edit, shift, this.hash, this, h2, Leaf(edit, h2, k2, v2));
+            return mergeLeaves(edit, shift2, this.hash, this, h2, Leaf(edit, h2, k2, v2));
         };
-        var Collision__modify = function Collision__modify2(edit, keyEq, shift, f2, h2, k2, size2) {
+        var Collision__modify = function Collision__modify2(edit, keyEq, shift2, f2, h2, k2, size2) {
             if (h2 === this.hash) {
                 var canEdit = canEditNode(edit, this);
                 var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f2, k2, size2);
                 if (list === this.children)
                     return this;
                 return list.length > 1 ? Collision(edit, this.hash, list) : list[0];
             }
             var v2 = f2();
             if (v2 === nothing)
                 return this;
             ++size2.value;
-            return mergeLeaves(edit, shift, this.hash, this, h2, Leaf(edit, h2, k2, v2));
+            return mergeLeaves(edit, shift2, this.hash, this, h2, Leaf(edit, h2, k2, v2));
         };
-        var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift, f2, h2, k2, size2) {
+        var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift2, f2, h2, k2, size2) {
             var mask = this.mask;
             var children = this.children;
-            var frag = hashFragment(shift, h2);
+            var frag = hashFragment(shift2, h2);
             var bit = toBitmap(frag);
             var indx = fromBitmap(mask, bit);
             var exists = mask & bit;
             var current = exists ? children[indx] : empty;
-            var child = current._modify(edit, keyEq, shift + SIZE, f2, h2, k2, size2);
+            var child = current._modify(edit, keyEq, shift2 + SIZE, f2, h2, k2, size2);
             if (current === child)
                 return this;
             var canEdit = canEditNode(edit, this);
             var bitmap = mask;
             var newChildren = void 0;
             if (exists && isEmptyNode(child)) {
                 bitmap &= ~bit;
@@ -3185,43 +3185,43 @@
             if (canEdit) {
                 this.mask = bitmap;
                 this.children = newChildren;
                 return this;
             }
             return IndexedNode(edit, bitmap, newChildren);
         };
-        var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift, f2, h2, k2, size2) {
-            var count2 = this.size;
+        var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift2, f2, h2, k2, size2) {
+            var count3 = this.size;
             var children = this.children;
-            var frag = hashFragment(shift, h2);
+            var frag = hashFragment(shift2, h2);
             var child = children[frag];
-            var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f2, h2, k2, size2);
+            var newChild = (child || empty)._modify(edit, keyEq, shift2 + SIZE, f2, h2, k2, size2);
             if (child === newChild)
                 return this;
             var canEdit = canEditNode(edit, this);
             var newChildren = void 0;
             if (isEmptyNode(child) && !isEmptyNode(newChild)) {
-                ++count2;
+                ++count3;
                 newChildren = arrayUpdate(canEdit, frag, newChild, children);
             } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
-                --count2;
-                if (count2 <= MIN_ARRAY_NODE)
-                    return pack(edit, count2, frag, children);
+                --count3;
+                if (count3 <= MIN_ARRAY_NODE)
+                    return pack(edit, count3, frag, children);
                 newChildren = arrayUpdate(canEdit, frag, empty, children);
             } else {
                 newChildren = arrayUpdate(canEdit, frag, newChild, children);
             }
             if (canEdit) {
-                this.size = count2;
+                this.size = count3;
                 this.children = newChildren;
                 return this;
             }
-            return ArrayNode(edit, count2, newChildren);
+            return ArrayNode(edit, count3, newChildren);
         };
-        empty._modify = function(edit, keyEq, shift, f2, h2, k2, size2) {
+        empty._modify = function(edit, keyEq, shift2, f2, h2, k2, size2) {
             var v2 = f2();
             if (v2 === nothing)
                 return empty;
             ++size2.value;
             return Leaf(edit, h2, k2, v2);
         };
 
@@ -3238,15 +3238,15 @@
                 this._size = newSize;
                 return this;
             }
             return newRoot === this._root ? this : new Map2(this._editable, this._edit, this._config, newRoot, newSize);
         };
         var tryGetHash = hamt.tryGetHash = function(alt, hash3, key, map2) {
             var node = map2._root;
-            var shift = 0;
+            var shift2 = 0;
             var keyEq = map2._config.keyEq;
             while (true) {
                 switch (node.type) {
                     case LEAF: {
                         return keyEq(key, node.key) ? node.value : alt;
                     }
                     case COLLISION: {
@@ -3257,27 +3257,27 @@
                                 if (keyEq(key, child.key))
                                     return child.value;
                             }
                         }
                         return alt;
                     }
                     case INDEX: {
-                        var frag = hashFragment(shift, hash3);
+                        var frag = hashFragment(shift2, hash3);
                         var bit = toBitmap(frag);
                         if (node.mask & bit) {
                             node = node.children[fromBitmap(node.mask, bit)];
-                            shift += SIZE;
+                            shift2 += SIZE;
                             break;
                         }
                         return alt;
                     }
                     case ARRAY: {
-                        node = node.children[hashFragment(shift, hash3)];
+                        node = node.children[hashFragment(shift2, hash3)];
                         if (node) {
-                            shift += SIZE;
+                            shift2 += SIZE;
                             break;
                         }
                         return alt;
                     }
                     default:
                         return alt;
                 }
@@ -3494,19 +3494,19 @@
             return fold(function(_, value, key) {
                 return f2(value, key, map2);
             }, null, map2);
         };
         Map2.prototype.forEach = function(f2) {
             return forEach(f2, this);
         };
-        var count = hamt.count = function(map2) {
+        var count2 = hamt.count = function(map2) {
             return map2._size;
         };
         Map2.prototype.count = function() {
-            return count(this);
+            return count2(this);
         };
         Object.defineProperty(Map2.prototype, "size", {
             get: Map2.prototype.count
         });
         if (module2.exports) {
             module2.exports = hamt;
         } else {
@@ -15081,24 +15081,24 @@
         mark: noop$1$1,
         measure: noop$1$1
     };
     var preamble = 'FA "6.4.2"';
     var begin = function begin2(name) {
         p$1.mark("".concat(preamble, " ").concat(name, " begins"));
         return function() {
-            return end$2(name);
+            return end$1(name);
         };
     };
-    var end$2 = function end2(name) {
+    var end$1 = function end2(name) {
         p$1.mark("".concat(preamble, " ").concat(name, " ends"));
         p$1.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
     };
     var perf = {
         begin,
-        end: end$2
+        end: end$1
     };
     var noop$2$1 = function noop2() {};
 
     function isWatched(node) {
         var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
         return typeof i2svg === "string";
     }
@@ -17169,30 +17169,14 @@
         background-color: ${(props) => props.theme.colors.primary};
     }
 
     &:last-child {
         border-bottom: none;
     }
 `;
-    const sameWidthModifier = {
-        effect: ({
-            state
-        }) => () => {
-            state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
-        },
-        enabled: true,
-        fn: ({
-            state
-        }) => {
-            state.styles.popper.width = `${state.rects.reference.width}px`;
-        },
-        name: "sameWidth",
-        phase: "beforeWrite",
-        requires: ["computeStyles"]
-    };
     globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
         function adopt(value) {
             return value instanceof P ? value : new P(function(resolve) {
                 resolve(value);
             });
         }
         return new(P || (P = Promise))(function(resolve, reject) {
@@ -18677,15 +18661,15 @@
         isSymbol$3 = isSymbol_1;
     var NAN = 0 / 0;
     var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
     var reIsBinary = /^0b[01]+$/i;
     var reIsOctal = /^0o[0-7]+$/i;
     var freeParseInt = parseInt;
 
-    function toNumber$3(value) {
+    function toNumber$2(value) {
         if (typeof value == "number") {
             return value;
         }
         if (isSymbol$3(value)) {
             return NAN;
         }
         if (isObject$8(value)) {
@@ -18695,35 +18679,35 @@
         if (typeof value != "string") {
             return value === 0 ? value : +value;
         }
         value = baseTrim(value);
         var isBinary = reIsBinary.test(value);
         return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
     }
-    var toNumber_1 = toNumber$3;
+    var toNumber_1 = toNumber$2;
     var isObject$7 = isObject_1,
         now$1 = now_1,
-        toNumber$2 = toNumber_1;
+        toNumber$1 = toNumber_1;
     var FUNC_ERROR_TEXT$4 = "Expected a function";
     var nativeMax$3 = Math.max,
         nativeMin$2 = Math.min;
 
-    function debounce$6(func, wait, options) {
+    function debounce$5(func, wait, options) {
         var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
             leading = false,
             maxing = false,
             trailing = true;
         if (typeof func != "function") {
             throw new TypeError(FUNC_ERROR_TEXT$4);
         }
-        wait = toNumber$2(wait) || 0;
+        wait = toNumber$1(wait) || 0;
         if (isObject$7(options)) {
             leading = !!options.leading;
             maxing = "maxWait" in options;
-            maxWait = maxing ? nativeMax$3(toNumber$2(options.maxWait) || 0, wait) : maxWait;
+            maxWait = maxing ? nativeMax$3(toNumber$1(options.maxWait) || 0, wait) : maxWait;
             trailing = "trailing" in options ? !!options.trailing : trailing;
         }
 
         function invokeFunc(time) {
             var args = lastArgs,
                 thisArg = lastThis;
             lastArgs = lastThis = void 0;
@@ -18801,30 +18785,30 @@
             }
             return result;
         }
         debounced.cancel = cancel;
         debounced.flush = flush;
         return debounced;
     }
-    var debounce_1 = debounce$6;
-    var debounce$5 = debounce_1,
+    var debounce_1 = debounce$5;
+    var debounce$4 = debounce_1,
         isObject$6 = isObject_1;
     var FUNC_ERROR_TEXT$3 = "Expected a function";
 
     function throttle(func, wait, options) {
         var leading = true,
             trailing = true;
         if (typeof func != "function") {
             throw new TypeError(FUNC_ERROR_TEXT$3);
         }
         if (isObject$6(options)) {
             leading = "leading" in options ? !!options.leading : leading;
             trailing = "trailing" in options ? !!options.trailing : trailing;
         }
-        return debounce$5(func, wait, {
+        return debounce$4(func, wait, {
             "leading": leading,
             "maxWait": wait,
             "trailing": trailing
         });
     }
     var throttle_1 = throttle;
 
@@ -18844,23 +18828,23 @@
         const throttledSetValue = useThrottle(setValue, delay2, options);
         return [value, throttledSetValue, setValue];
     }
     var e10 = Math.sqrt(50),
         e5 = Math.sqrt(10),
         e2 = Math.sqrt(2);
 
-    function ticks(start2, stop, count) {
+    function ticks(start2, stop, count2) {
         var reverse, i2 = -1,
             n2, ticks2, step;
-        stop = +stop, start2 = +start2, count = +count;
-        if (start2 === stop && count > 0)
+        stop = +stop, start2 = +start2, count2 = +count2;
+        if (start2 === stop && count2 > 0)
             return [start2];
         if (reverse = stop < start2)
             n2 = start2, start2 = stop, stop = n2;
-        if ((step = tickIncrement(start2, stop, count)) === 0 || !isFinite(step))
+        if ((step = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step))
             return [];
         if (step > 0) {
             let r0 = Math.round(start2 / step),
                 r1 = Math.round(stop / step);
             if (r0 * step < start2)
                 ++r0;
             if (r1 * step > stop)
@@ -18881,37 +18865,20 @@
                 ticks2[i2] = (r0 + i2) / step;
         }
         if (reverse)
             ticks2.reverse();
         return ticks2;
     }
 
-    function tickIncrement(start2, stop, count) {
-        var step = (stop - start2) / Math.max(0, count),
+    function tickIncrement(start2, stop, count2) {
+        var step = (stop - start2) / Math.max(0, count2),
             power = Math.floor(Math.log(step) / Math.LN10),
             error = step / Math.pow(10, power);
         return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
     }
-
-    function useOnClickOutside(element, handler) {
-        React.useEffect(() => {
-            const listener2 = (event) => {
-                if (!element || element.contains(event.target)) {
-                    return;
-                }
-                handler();
-            };
-            document.addEventListener("mousedown", listener2);
-            document.addEventListener("touchstart", listener2);
-            return () => {
-                document.removeEventListener("mousedown", listener2);
-                document.removeEventListener("touchstart", listener2);
-            };
-        }, [element, handler]);
-    }
     globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
         function adopt(value) {
             return value instanceof P ? value : new P(function(resolve) {
                 resolve(value);
             });
         }
         return new(P || (P = Promise))(function(resolve, reject) {
@@ -18933,14 +18900,2771 @@
 
             function step(result) {
                 result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
             }
             step((generator = generator.apply(thisArg, _arguments || [])).next());
         });
     };
+
+    function getNodeName$1(node) {
+        if (isNode(node)) {
+            return (node.nodeName || "").toLowerCase();
+        }
+        return "#document";
+    }
+
+    function getWindow$1(node) {
+        var _node$ownerDocument;
+        return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
+    }
+
+    function getDocumentElement$1(node) {
+        var _ref2;
+        return (_ref2 = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref2.documentElement;
+    }
+
+    function isNode(value) {
+        return value instanceof Node || value instanceof getWindow$1(value).Node;
+    }
+
+    function isElement$3(value) {
+        return value instanceof Element || value instanceof getWindow$1(value).Element;
+    }
+
+    function isHTMLElement$1(value) {
+        return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
+    }
+
+    function isShadowRoot$1(value) {
+        if (typeof ShadowRoot === "undefined") {
+            return false;
+        }
+        return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
+    }
+
+    function isOverflowElement(element) {
+        const {
+            overflow,
+            overflowX,
+            overflowY,
+            display
+        } = getComputedStyle$2(element);
+        return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
+    }
+
+    function isTableElement$1(element) {
+        return ["table", "td", "th"].includes(getNodeName$1(element));
+    }
+
+    function isContainingBlock(element) {
+        const webkit = isWebKit();
+        const css2 = getComputedStyle$2(element);
+        return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
+    }
+
+    function getContainingBlock$1(element) {
+        let currentNode = getParentNode$1(element);
+        while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
+            if (isContainingBlock(currentNode)) {
+                return currentNode;
+            }
+            currentNode = getParentNode$1(currentNode);
+        }
+        return null;
+    }
+
+    function isWebKit() {
+        if (typeof CSS === "undefined" || !CSS.supports)
+            return false;
+        return CSS.supports("-webkit-backdrop-filter", "none");
+    }
+
+    function isLastTraversableNode(node) {
+        return ["html", "body", "#document"].includes(getNodeName$1(node));
+    }
+
+    function getComputedStyle$2(element) {
+        return getWindow$1(element).getComputedStyle(element);
+    }
+
+    function getNodeScroll$1(element) {
+        if (isElement$3(element)) {
+            return {
+                scrollLeft: element.scrollLeft,
+                scrollTop: element.scrollTop
+            };
+        }
+        return {
+            scrollLeft: element.pageXOffset,
+            scrollTop: element.pageYOffset
+        };
+    }
+
+    function getParentNode$1(node) {
+        if (getNodeName$1(node) === "html") {
+            return node;
+        }
+        const result = node.assignedSlot || node.parentNode || isShadowRoot$1(node) && node.host || getDocumentElement$1(node);
+        return isShadowRoot$1(result) ? result.host : result;
+    }
+
+    function getNearestOverflowAncestor(node) {
+        const parentNode = getParentNode$1(node);
+        if (isLastTraversableNode(parentNode)) {
+            return node.ownerDocument ? node.ownerDocument.body : node.body;
+        }
+        if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
+            return parentNode;
+        }
+        return getNearestOverflowAncestor(parentNode);
+    }
+
+    function getOverflowAncestors(node, list, traverseIframes) {
+        var _node$ownerDocument2;
+        if (list === void 0) {
+            list = [];
+        }
+        if (traverseIframes === void 0) {
+            traverseIframes = true;
+        }
+        const scrollableAncestor = getNearestOverflowAncestor(node);
+        const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
+        const win = getWindow$1(scrollableAncestor);
+        if (isBody) {
+            return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
+        }
+        return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
+    }
+
+    function contains$1(parent, child) {
+        if (!parent || !child) {
+            return false;
+        }
+        const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
+        if (parent.contains(child)) {
+            return true;
+        }
+        if (rootNode && isShadowRoot$1(rootNode)) {
+            let next = child;
+            while (next) {
+                if (parent === next) {
+                    return true;
+                }
+                next = next.parentNode || next.host;
+            }
+        }
+        return false;
+    }
+
+    function isMouseLikePointerType(pointerType, strict) {
+        const values = ["mouse", "pen"];
+        if (!strict) {
+            values.push("", void 0);
+        }
+        return values.includes(pointerType);
+    }
+
+    function isReactEvent(event) {
+        return "nativeEvent" in event;
+    }
+
+    function isRootElement(element) {
+        return element.matches("html,body");
+    }
+
+    function getDocument(node) {
+        return (node == null ? void 0 : node.ownerDocument) || document;
+    }
+
+    function isEventTargetWithin(event, node) {
+        if (node == null) {
+            return false;
+        }
+        if ("composedPath" in event) {
+            return event.composedPath().includes(node);
+        }
+        const e3 = event;
+        return e3.target != null && node.contains(e3.target);
+    }
+
+    function getTarget(event) {
+        if ("composedPath" in event) {
+            return event.composedPath()[0];
+        }
+        return event.target;
+    }
+    const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
+
+    function isTypeableElement(element) {
+        return isHTMLElement$1(element) && element.matches(TYPEABLE_SELECTOR);
+    }
+    const sides = ["top", "right", "bottom", "left"];
+    const alignments = ["start", "end"];
+    const placements$1 = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
+    const min$2 = Math.min;
+    const max$2 = Math.max;
+    const round$1 = Math.round;
+    const floor = Math.floor;
+    const createCoords = (v2) => ({
+        x: v2,
+        y: v2
+    });
+    const oppositeSideMap = {
+        left: "right",
+        right: "left",
+        bottom: "top",
+        top: "bottom"
+    };
+    const oppositeAlignmentMap = {
+        start: "end",
+        end: "start"
+    };
+
+    function clamp$1(start2, value, end2) {
+        return max$2(start2, min$2(value, end2));
+    }
+
+    function evaluate(value, param) {
+        return typeof value === "function" ? value(param) : value;
+    }
+
+    function getSide(placement) {
+        return placement.split("-")[0];
+    }
+
+    function getAlignment(placement) {
+        return placement.split("-")[1];
+    }
+
+    function getOppositeAxis(axis) {
+        return axis === "x" ? "y" : "x";
+    }
+
+    function getAxisLength(axis) {
+        return axis === "y" ? "height" : "width";
+    }
+
+    function getSideAxis(placement) {
+        return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
+    }
+
+    function getAlignmentAxis(placement) {
+        return getOppositeAxis(getSideAxis(placement));
+    }
+
+    function getAlignmentSides(placement, rects, rtl) {
+        if (rtl === void 0) {
+            rtl = false;
+        }
+        const alignment = getAlignment(placement);
+        const alignmentAxis = getAlignmentAxis(placement);
+        const length = getAxisLength(alignmentAxis);
+        let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
+        if (rects.reference[length] > rects.floating[length]) {
+            mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
+        }
+        return [mainAlignmentSide, getOppositePlacement$1(mainAlignmentSide)];
+    }
+
+    function getExpandedPlacements(placement) {
+        const oppositePlacement = getOppositePlacement$1(placement);
+        return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
+    }
+
+    function getOppositeAlignmentPlacement(placement) {
+        return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
+    }
+
+    function getSideList(side, isStart, rtl) {
+        const lr = ["left", "right"];
+        const rl = ["right", "left"];
+        const tb = ["top", "bottom"];
+        const bt2 = ["bottom", "top"];
+        switch (side) {
+            case "top":
+            case "bottom":
+                if (rtl)
+                    return isStart ? rl : lr;
+                return isStart ? lr : rl;
+            case "left":
+            case "right":
+                return isStart ? tb : bt2;
+            default:
+                return [];
+        }
+    }
+
+    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
+        const alignment = getAlignment(placement);
+        let list = getSideList(getSide(placement), direction === "start", rtl);
+        if (alignment) {
+            list = list.map((side) => side + "-" + alignment);
+            if (flipAlignment) {
+                list = list.concat(list.map(getOppositeAlignmentPlacement));
+            }
+        }
+        return list;
+    }
+
+    function getOppositePlacement$1(placement) {
+        return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
+    }
+
+    function expandPaddingObject(padding) {
+        return {
+            top: 0,
+            right: 0,
+            bottom: 0,
+            left: 0,
+            ...padding
+        };
+    }
+
+    function getPaddingObject(padding) {
+        return typeof padding !== "number" ? expandPaddingObject(padding) : {
+            top: padding,
+            right: padding,
+            bottom: padding,
+            left: padding
+        };
+    }
+
+    function rectToClientRect$1(rect) {
+        const {
+            x: x2,
+            y: y2,
+            width,
+            height
+        } = rect;
+        return {
+            width,
+            height,
+            top: y2,
+            left: x2,
+            right: x2 + width,
+            bottom: y2 + height,
+            x: x2,
+            y: y2
+        };
+    }
+
+    function computeCoordsFromPlacement(_ref2, placement, rtl) {
+        let {
+            reference: reference2,
+            floating
+        } = _ref2;
+        const sideAxis = getSideAxis(placement);
+        const alignmentAxis = getAlignmentAxis(placement);
+        const alignLength = getAxisLength(alignmentAxis);
+        const side = getSide(placement);
+        const isVertical = sideAxis === "y";
+        const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
+        const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
+        const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
+        let coords;
+        switch (side) {
+            case "top":
+                coords = {
+                    x: commonX,
+                    y: reference2.y - floating.height
+                };
+                break;
+            case "bottom":
+                coords = {
+                    x: commonX,
+                    y: reference2.y + reference2.height
+                };
+                break;
+            case "right":
+                coords = {
+                    x: reference2.x + reference2.width,
+                    y: commonY
+                };
+                break;
+            case "left":
+                coords = {
+                    x: reference2.x - floating.width,
+                    y: commonY
+                };
+                break;
+            default:
+                coords = {
+                    x: reference2.x,
+                    y: reference2.y
+                };
+        }
+        switch (getAlignment(placement)) {
+            case "start":
+                coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
+                break;
+            case "end":
+                coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
+                break;
+        }
+        return coords;
+    }
+    const computePosition$1 = async (reference2, floating, config2) => {
+        const {
+            placement = "bottom",
+                strategy = "absolute",
+                middleware = [],
+                platform: platform2
+        } = config2;
+        const validMiddleware = middleware.filter(Boolean);
+        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
+        let rects = await platform2.getElementRects({
+            reference: reference2,
+            floating,
+            strategy
+        });
+        let {
+            x: x2,
+            y: y2
+        } = computeCoordsFromPlacement(rects, placement, rtl);
+        let statefulPlacement = placement;
+        let middlewareData = {};
+        let resetCount = 0;
+        for (let i2 = 0; i2 < validMiddleware.length; i2++) {
+            const {
+                name,
+                fn
+            } = validMiddleware[i2];
+            const {
+                x: nextX,
+                y: nextY,
+                data,
+                reset: reset2
+            } = await fn({
+                x: x2,
+                y: y2,
+                initialPlacement: placement,
+                placement: statefulPlacement,
+                strategy,
+                middlewareData,
+                rects,
+                platform: platform2,
+                elements: {
+                    reference: reference2,
+                    floating
+                }
+            });
+            x2 = nextX != null ? nextX : x2;
+            y2 = nextY != null ? nextY : y2;
+            middlewareData = {
+                ...middlewareData,
+                [name]: {
+                    ...middlewareData[name],
+                    ...data
+                }
+            };
+            if (reset2 && resetCount <= 50) {
+                resetCount++;
+                if (typeof reset2 === "object") {
+                    if (reset2.placement) {
+                        statefulPlacement = reset2.placement;
+                    }
+                    if (reset2.rects) {
+                        rects = reset2.rects === true ? await platform2.getElementRects({
+                            reference: reference2,
+                            floating,
+                            strategy
+                        }) : reset2.rects;
+                    }
+                    ({
+                        x: x2,
+                        y: y2
+                    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
+                }
+                i2 = -1;
+            }
+        }
+        return {
+            x: x2,
+            y: y2,
+            placement: statefulPlacement,
+            strategy,
+            middlewareData
+        };
+    };
+    async function detectOverflow$1(state, options) {
+        var _await$platform$isEle;
+        if (options === void 0) {
+            options = {};
+        }
+        const {
+            x: x2,
+            y: y2,
+            platform: platform2,
+            rects,
+            elements,
+            strategy
+        } = state;
+        const {
+            boundary = "clippingAncestors",
+                rootBoundary = "viewport",
+                elementContext = "floating",
+                altBoundary = false,
+                padding = 0
+        } = evaluate(options, state);
+        const paddingObject = getPaddingObject(padding);
+        const altContext = elementContext === "floating" ? "reference" : "floating";
+        const element = elements[altBoundary ? altContext : elementContext];
+        const clippingClientRect = rectToClientRect$1(await platform2.getClippingRect({
+            element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
+            boundary,
+            rootBoundary,
+            strategy
+        }));
+        const rect = elementContext === "floating" ? {
+            x: x2,
+            y: y2,
+            width: rects.floating.width,
+            height: rects.floating.height
+        } : rects.reference;
+        const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
+        const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
+            x: 1,
+            y: 1
+        } : {
+            x: 1,
+            y: 1
+        };
+        const elementClientRect = rectToClientRect$1(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
+            elements,
+            rect,
+            offsetParent,
+            strategy
+        }) : rect);
+        return {
+            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
+            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
+            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
+            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
+        };
+    }
+    const arrow$2 = (options) => ({
+        name: "arrow",
+        options,
+        async fn(state) {
+            const {
+                x: x2,
+                y: y2,
+                placement,
+                rects,
+                platform: platform2,
+                elements,
+                middlewareData
+            } = state;
+            const {
+                element,
+                padding = 0
+            } = evaluate(options, state) || {};
+            if (element == null) {
+                return {};
+            }
+            const paddingObject = getPaddingObject(padding);
+            const coords = {
+                x: x2,
+                y: y2
+            };
+            const axis = getAlignmentAxis(placement);
+            const length = getAxisLength(axis);
+            const arrowDimensions = await platform2.getDimensions(element);
+            const isYAxis = axis === "y";
+            const minProp = isYAxis ? "top" : "left";
+            const maxProp = isYAxis ? "bottom" : "right";
+            const clientProp = isYAxis ? "clientHeight" : "clientWidth";
+            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
+            const startDiff = coords[axis] - rects.reference[axis];
+            const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
+            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
+            if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
+                clientSize = elements.floating[clientProp] || rects.floating[length];
+            }
+            const centerToReference = endDiff / 2 - startDiff / 2;
+            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
+            const minPadding = min$2(paddingObject[minProp], largestPossiblePadding);
+            const maxPadding = min$2(paddingObject[maxProp], largestPossiblePadding);
+            const min$12 = minPadding;
+            const max2 = clientSize - arrowDimensions[length] - maxPadding;
+            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
+            const offset2 = clamp$1(min$12, center, max2);
+            const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
+            const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
+            return {
+                [axis]: coords[axis] + alignmentOffset,
+                data: {
+                    [axis]: offset2,
+                    centerOffset: center - offset2 - alignmentOffset,
+                    ...shouldAddOffset && {
+                        alignmentOffset
+                    }
+                },
+                reset: shouldAddOffset
+            };
+        }
+    });
+
+    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
+        const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
+        return allowedPlacementsSortedByAlignment.filter((placement) => {
+            if (alignment) {
+                return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
+            }
+            return true;
+        });
+    }
+    const autoPlacement = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "autoPlacement",
+            options,
+            async fn(state) {
+                var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
+                const {
+                    rects,
+                    middlewareData,
+                    placement,
+                    platform: platform2,
+                    elements
+                } = state;
+                const {
+                    crossAxis = false,
+                        alignment,
+                        allowedPlacements = placements$1,
+                        autoAlignment = true,
+                        ...detectOverflowOptions
+                } = evaluate(options, state);
+                const placements$1$1 = alignment !== void 0 || allowedPlacements === placements$1 ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
+                const overflow = await detectOverflow$1(state, detectOverflowOptions);
+                const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
+                const currentPlacement = placements$1$1[currentIndex];
+                if (currentPlacement == null) {
+                    return {};
+                }
+                const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
+                if (placement !== currentPlacement) {
+                    return {
+                        reset: {
+                            placement: placements$1$1[0]
+                        }
+                    };
+                }
+                const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
+                const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
+                    placement: currentPlacement,
+                    overflows: currentOverflows
+                }];
+                const nextPlacement = placements$1$1[currentIndex + 1];
+                if (nextPlacement) {
+                    return {
+                        data: {
+                            index: currentIndex + 1,
+                            overflows: allOverflows
+                        },
+                        reset: {
+                            placement: nextPlacement
+                        }
+                    };
+                }
+                const placementsSortedByMostSpace = allOverflows.map((d2) => {
+                    const alignment2 = getAlignment(d2.placement);
+                    return [d2.placement, alignment2 && crossAxis ? d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0) : d2.overflows[0], d2.overflows];
+                }).sort((a2, b2) => a2[1] - b2[1]);
+                const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
+                    0,
+                    getAlignment(d2[0]) ? 2 : 3
+                ).every((v2) => v2 <= 0));
+                const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
+                if (resetPlacement !== placement) {
+                    return {
+                        data: {
+                            index: currentIndex + 1,
+                            overflows: allOverflows
+                        },
+                        reset: {
+                            placement: resetPlacement
+                        }
+                    };
+                }
+                return {};
+            }
+        };
+    };
+    const flip$3 = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "flip",
+            options,
+            async fn(state) {
+                var _middlewareData$arrow, _middlewareData$flip;
+                const {
+                    placement,
+                    middlewareData,
+                    rects,
+                    initialPlacement,
+                    platform: platform2,
+                    elements
+                } = state;
+                const {
+                    mainAxis: checkMainAxis = true,
+                    crossAxis: checkCrossAxis = true,
+                    fallbackPlacements: specifiedFallbackPlacements,
+                    fallbackStrategy = "bestFit",
+                    fallbackAxisSideDirection = "none",
+                    flipAlignment = true,
+                    ...detectOverflowOptions
+                } = evaluate(options, state);
+                if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
+                    return {};
+                }
+                const side = getSide(placement);
+                const isBasePlacement = getSide(initialPlacement) === initialPlacement;
+                const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
+                const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements(initialPlacement));
+                if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
+                    fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
+                }
+                const placements2 = [initialPlacement, ...fallbackPlacements];
+                const overflow = await detectOverflow$1(state, detectOverflowOptions);
+                const overflows = [];
+                let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
+                if (checkMainAxis) {
+                    overflows.push(overflow[side]);
+                }
+                if (checkCrossAxis) {
+                    const sides2 = getAlignmentSides(placement, rects, rtl);
+                    overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
+                }
+                overflowsData = [...overflowsData, {
+                    placement,
+                    overflows
+                }];
+                if (!overflows.every((side2) => side2 <= 0)) {
+                    var _middlewareData$flip2, _overflowsData$filter;
+                    const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
+                    const nextPlacement = placements2[nextIndex2];
+                    if (nextPlacement) {
+                        return {
+                            data: {
+                                index: nextIndex2,
+                                overflows: overflowsData
+                            },
+                            reset: {
+                                placement: nextPlacement
+                            }
+                        };
+                    }
+                    let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
+                    if (!resetPlacement) {
+                        switch (fallbackStrategy) {
+                            case "bestFit": {
+                                var _overflowsData$map$so;
+                                const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
+                                if (placement2) {
+                                    resetPlacement = placement2;
+                                }
+                                break;
+                            }
+                            case "initialPlacement":
+                                resetPlacement = initialPlacement;
+                                break;
+                        }
+                    }
+                    if (placement !== resetPlacement) {
+                        return {
+                            reset: {
+                                placement: resetPlacement
+                            }
+                        };
+                    }
+                }
+                return {};
+            }
+        };
+    };
+
+    function getSideOffsets$1(overflow, rect) {
+        return {
+            top: overflow.top - rect.height,
+            right: overflow.right - rect.width,
+            bottom: overflow.bottom - rect.height,
+            left: overflow.left - rect.width
+        };
+    }
+
+    function isAnySideFullyClipped$1(overflow) {
+        return sides.some((side) => overflow[side] >= 0);
+    }
+    const hide$2 = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "hide",
+            options,
+            async fn(state) {
+                const {
+                    rects
+                } = state;
+                const {
+                    strategy = "referenceHidden",
+                        ...detectOverflowOptions
+                } = evaluate(options, state);
+                switch (strategy) {
+                    case "referenceHidden": {
+                        const overflow = await detectOverflow$1(state, {
+                            ...detectOverflowOptions,
+                            elementContext: "reference"
+                        });
+                        const offsets = getSideOffsets$1(overflow, rects.reference);
+                        return {
+                            data: {
+                                referenceHiddenOffsets: offsets,
+                                referenceHidden: isAnySideFullyClipped$1(offsets)
+                            }
+                        };
+                    }
+                    case "escaped": {
+                        const overflow = await detectOverflow$1(state, {
+                            ...detectOverflowOptions,
+                            altBoundary: true
+                        });
+                        const offsets = getSideOffsets$1(overflow, rects.floating);
+                        return {
+                            data: {
+                                escapedOffsets: offsets,
+                                escaped: isAnySideFullyClipped$1(offsets)
+                            }
+                        };
+                    }
+                    default: {
+                        return {};
+                    }
+                }
+            }
+        };
+    };
+
+    function getBoundingRect(rects) {
+        const minX = min$2(...rects.map((rect) => rect.left));
+        const minY = min$2(...rects.map((rect) => rect.top));
+        const maxX = max$2(...rects.map((rect) => rect.right));
+        const maxY = max$2(...rects.map((rect) => rect.bottom));
+        return {
+            x: minX,
+            y: minY,
+            width: maxX - minX,
+            height: maxY - minY
+        };
+    }
+
+    function getRectsByLine(rects) {
+        const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y);
+        const groups = [];
+        let prevRect = null;
+        for (let i2 = 0; i2 < sortedRects.length; i2++) {
+            const rect = sortedRects[i2];
+            if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
+                groups.push([rect]);
+            } else {
+                groups[groups.length - 1].push(rect);
+            }
+            prevRect = rect;
+        }
+        return groups.map((rect) => rectToClientRect$1(getBoundingRect(rect)));
+    }
+    const inline = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "inline",
+            options,
+            async fn(state) {
+                const {
+                    placement,
+                    elements,
+                    rects,
+                    platform: platform2,
+                    strategy
+                } = state;
+                const {
+                    padding = 2,
+                        x: x2,
+                        y: y2
+                } = evaluate(options, state);
+                const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
+                const clientRects = getRectsByLine(nativeClientRects);
+                const fallback = rectToClientRect$1(getBoundingRect(nativeClientRects));
+                const paddingObject = getPaddingObject(padding);
+
+                function getBoundingClientRect2() {
+                    if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
+                        return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
+                    }
+                    if (clientRects.length >= 2) {
+                        if (getSideAxis(placement) === "y") {
+                            const firstRect = clientRects[0];
+                            const lastRect = clientRects[clientRects.length - 1];
+                            const isTop = getSide(placement) === "top";
+                            const top3 = firstRect.top;
+                            const bottom3 = lastRect.bottom;
+                            const left3 = isTop ? firstRect.left : lastRect.left;
+                            const right3 = isTop ? firstRect.right : lastRect.right;
+                            const width2 = right3 - left3;
+                            const height2 = bottom3 - top3;
+                            return {
+                                top: top3,
+                                bottom: bottom3,
+                                left: left3,
+                                right: right3,
+                                width: width2,
+                                height: height2,
+                                x: left3,
+                                y: top3
+                            };
+                        }
+                        const isLeftSide = getSide(placement) === "left";
+                        const maxRight = max$2(...clientRects.map((rect) => rect.right));
+                        const minLeft = min$2(...clientRects.map((rect) => rect.left));
+                        const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
+                        const top2 = measureRects[0].top;
+                        const bottom2 = measureRects[measureRects.length - 1].bottom;
+                        const left2 = minLeft;
+                        const right2 = maxRight;
+                        const width = right2 - left2;
+                        const height = bottom2 - top2;
+                        return {
+                            top: top2,
+                            bottom: bottom2,
+                            left: left2,
+                            right: right2,
+                            width,
+                            height,
+                            x: left2,
+                            y: top2
+                        };
+                    }
+                    return fallback;
+                }
+                const resetRects = await platform2.getElementRects({
+                    reference: {
+                        getBoundingClientRect: getBoundingClientRect2
+                    },
+                    floating: elements.floating,
+                    strategy
+                });
+                if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
+                    return {
+                        reset: {
+                            rects: resetRects
+                        }
+                    };
+                }
+                return {};
+            }
+        };
+    };
+    async function convertValueToCoords(state, options) {
+        const {
+            placement,
+            platform: platform2,
+            elements
+        } = state;
+        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
+        const side = getSide(placement);
+        const alignment = getAlignment(placement);
+        const isVertical = getSideAxis(placement) === "y";
+        const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
+        const crossAxisMulti = rtl && isVertical ? -1 : 1;
+        const rawValue = evaluate(options, state);
+        let {
+            mainAxis,
+            crossAxis,
+            alignmentAxis
+        } = typeof rawValue === "number" ? {
+            mainAxis: rawValue,
+            crossAxis: 0,
+            alignmentAxis: null
+        } : {
+            mainAxis: 0,
+            crossAxis: 0,
+            alignmentAxis: null,
+            ...rawValue
+        };
+        if (alignment && typeof alignmentAxis === "number") {
+            crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
+        }
+        return isVertical ? {
+            x: crossAxis * crossAxisMulti,
+            y: mainAxis * mainAxisMulti
+        } : {
+            x: mainAxis * mainAxisMulti,
+            y: crossAxis * crossAxisMulti
+        };
+    }
+    const offset$3 = function(options) {
+        if (options === void 0) {
+            options = 0;
+        }
+        return {
+            name: "offset",
+            options,
+            async fn(state) {
+                var _middlewareData$offse, _middlewareData$arrow;
+                const {
+                    x: x2,
+                    y: y2,
+                    placement,
+                    middlewareData
+                } = state;
+                const diffCoords = await convertValueToCoords(state, options);
+                if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
+                    return {};
+                }
+                return {
+                    x: x2 + diffCoords.x,
+                    y: y2 + diffCoords.y,
+                    data: {
+                        ...diffCoords,
+                        placement
+                    }
+                };
+            }
+        };
+    };
+    const shift$1 = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "shift",
+            options,
+            async fn(state) {
+                const {
+                    x: x2,
+                    y: y2,
+                    placement
+                } = state;
+                const {
+                    mainAxis: checkMainAxis = true,
+                    crossAxis: checkCrossAxis = false,
+                    limiter = {
+                        fn: (_ref2) => {
+                            let {
+                                x: x3,
+                                y: y3
+                            } = _ref2;
+                            return {
+                                x: x3,
+                                y: y3
+                            };
+                        }
+                    },
+                    ...detectOverflowOptions
+                } = evaluate(options, state);
+                const coords = {
+                    x: x2,
+                    y: y2
+                };
+                const overflow = await detectOverflow$1(state, detectOverflowOptions);
+                const crossAxis = getSideAxis(getSide(placement));
+                const mainAxis = getOppositeAxis(crossAxis);
+                let mainAxisCoord = coords[mainAxis];
+                let crossAxisCoord = coords[crossAxis];
+                if (checkMainAxis) {
+                    const minSide = mainAxis === "y" ? "top" : "left";
+                    const maxSide = mainAxis === "y" ? "bottom" : "right";
+                    const min2 = mainAxisCoord + overflow[minSide];
+                    const max2 = mainAxisCoord - overflow[maxSide];
+                    mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
+                }
+                if (checkCrossAxis) {
+                    const minSide = crossAxis === "y" ? "top" : "left";
+                    const maxSide = crossAxis === "y" ? "bottom" : "right";
+                    const min2 = crossAxisCoord + overflow[minSide];
+                    const max2 = crossAxisCoord - overflow[maxSide];
+                    crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
+                }
+                const limitedCoords = limiter.fn({
+                    ...state,
+                    [mainAxis]: mainAxisCoord,
+                    [crossAxis]: crossAxisCoord
+                });
+                return {
+                    ...limitedCoords,
+                    data: {
+                        x: limitedCoords.x - x2,
+                        y: limitedCoords.y - y2
+                    }
+                };
+            }
+        };
+    };
+    const limitShift = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            options,
+            fn(state) {
+                const {
+                    x: x2,
+                    y: y2,
+                    placement,
+                    rects,
+                    middlewareData
+                } = state;
+                const {
+                    offset: offset2 = 0,
+                    mainAxis: checkMainAxis = true,
+                    crossAxis: checkCrossAxis = true
+                } = evaluate(options, state);
+                const coords = {
+                    x: x2,
+                    y: y2
+                };
+                const crossAxis = getSideAxis(placement);
+                const mainAxis = getOppositeAxis(crossAxis);
+                let mainAxisCoord = coords[mainAxis];
+                let crossAxisCoord = coords[crossAxis];
+                const rawOffset = evaluate(offset2, state);
+                const computedOffset = typeof rawOffset === "number" ? {
+                    mainAxis: rawOffset,
+                    crossAxis: 0
+                } : {
+                    mainAxis: 0,
+                    crossAxis: 0,
+                    ...rawOffset
+                };
+                if (checkMainAxis) {
+                    const len = mainAxis === "y" ? "height" : "width";
+                    const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
+                    const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
+                    if (mainAxisCoord < limitMin) {
+                        mainAxisCoord = limitMin;
+                    } else if (mainAxisCoord > limitMax) {
+                        mainAxisCoord = limitMax;
+                    }
+                }
+                if (checkCrossAxis) {
+                    var _middlewareData$offse, _middlewareData$offse2;
+                    const len = mainAxis === "y" ? "width" : "height";
+                    const isOriginSide = ["top", "left"].includes(getSide(placement));
+                    const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
+                    const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
+                    if (crossAxisCoord < limitMin) {
+                        crossAxisCoord = limitMin;
+                    } else if (crossAxisCoord > limitMax) {
+                        crossAxisCoord = limitMax;
+                    }
+                }
+                return {
+                    [mainAxis]: mainAxisCoord,
+                    [crossAxis]: crossAxisCoord
+                };
+            }
+        };
+    };
+    const size$2 = function(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        return {
+            name: "size",
+            options,
+            async fn(state) {
+                const {
+                    placement,
+                    rects,
+                    platform: platform2,
+                    elements
+                } = state;
+                const {
+                    apply: apply2 = () => {},
+                    ...detectOverflowOptions
+                } = evaluate(options, state);
+                const overflow = await detectOverflow$1(state, detectOverflowOptions);
+                const side = getSide(placement);
+                const alignment = getAlignment(placement);
+                const isYAxis = getSideAxis(placement) === "y";
+                const {
+                    width,
+                    height
+                } = rects.floating;
+                let heightSide;
+                let widthSide;
+                if (side === "top" || side === "bottom") {
+                    heightSide = side;
+                    widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
+                } else {
+                    widthSide = side;
+                    heightSide = alignment === "end" ? "top" : "bottom";
+                }
+                const overflowAvailableHeight = height - overflow[heightSide];
+                const overflowAvailableWidth = width - overflow[widthSide];
+                const noShift = !state.middlewareData.shift;
+                let availableHeight = overflowAvailableHeight;
+                let availableWidth = overflowAvailableWidth;
+                if (isYAxis) {
+                    const maximumClippingWidth = width - overflow.left - overflow.right;
+                    availableWidth = alignment || noShift ? min$2(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
+                } else {
+                    const maximumClippingHeight = height - overflow.top - overflow.bottom;
+                    availableHeight = alignment || noShift ? min$2(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
+                }
+                if (noShift && !alignment) {
+                    const xMin = max$2(overflow.left, 0);
+                    const xMax = max$2(overflow.right, 0);
+                    const yMin = max$2(overflow.top, 0);
+                    const yMax = max$2(overflow.bottom, 0);
+                    if (isYAxis) {
+                        availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$2(overflow.left, overflow.right));
+                    } else {
+                        availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$2(overflow.top, overflow.bottom));
+                    }
+                }
+                await apply2({
+                    ...state,
+                    availableWidth,
+                    availableHeight
+                });
+                const nextDimensions = await platform2.getDimensions(elements.floating);
+                if (width !== nextDimensions.width || height !== nextDimensions.height) {
+                    return {
+                        reset: {
+                            rects: true
+                        }
+                    };
+                }
+                return {};
+            }
+        };
+    };
+
+    function getCssDimensions(element) {
+        const css2 = getComputedStyle$2(element);
+        let width = parseFloat(css2.width) || 0;
+        let height = parseFloat(css2.height) || 0;
+        const hasOffset = isHTMLElement$1(element);
+        const offsetWidth = hasOffset ? element.offsetWidth : width;
+        const offsetHeight = hasOffset ? element.offsetHeight : height;
+        const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
+        if (shouldFallback) {
+            width = offsetWidth;
+            height = offsetHeight;
+        }
+        return {
+            width,
+            height,
+            $: shouldFallback
+        };
+    }
+
+    function unwrapElement(element) {
+        return !isElement$3(element) ? element.contextElement : element;
+    }
+
+    function getScale(element) {
+        const domElement = unwrapElement(element);
+        if (!isHTMLElement$1(domElement)) {
+            return createCoords(1);
+        }
+        const rect = domElement.getBoundingClientRect();
+        const {
+            width,
+            height,
+            $
+        } = getCssDimensions(domElement);
+        let x2 = ($ ? round$1(rect.width) : rect.width) / width;
+        let y2 = ($ ? round$1(rect.height) : rect.height) / height;
+        if (!x2 || !Number.isFinite(x2)) {
+            x2 = 1;
+        }
+        if (!y2 || !Number.isFinite(y2)) {
+            y2 = 1;
+        }
+        return {
+            x: x2,
+            y: y2
+        };
+    }
+    const noOffsets = /* @__PURE__ */ createCoords(0);
+
+    function getVisualOffsets(element) {
+        const win = getWindow$1(element);
+        if (!isWebKit() || !win.visualViewport) {
+            return noOffsets;
+        }
+        return {
+            x: win.visualViewport.offsetLeft,
+            y: win.visualViewport.offsetTop
+        };
+    }
+
+    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
+        if (isFixed === void 0) {
+            isFixed = false;
+        }
+        if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
+            return false;
+        }
+        return isFixed;
+    }
+
+    function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
+        if (includeScale === void 0) {
+            includeScale = false;
+        }
+        if (isFixedStrategy === void 0) {
+            isFixedStrategy = false;
+        }
+        const clientRect = element.getBoundingClientRect();
+        const domElement = unwrapElement(element);
+        let scale = createCoords(1);
+        if (includeScale) {
+            if (offsetParent) {
+                if (isElement$3(offsetParent)) {
+                    scale = getScale(offsetParent);
+                }
+            } else {
+                scale = getScale(element);
+            }
+        }
+        const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
+        let x2 = (clientRect.left + visualOffsets.x) / scale.x;
+        let y2 = (clientRect.top + visualOffsets.y) / scale.y;
+        let width = clientRect.width / scale.x;
+        let height = clientRect.height / scale.y;
+        if (domElement) {
+            const win = getWindow$1(domElement);
+            const offsetWin = offsetParent && isElement$3(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
+            let currentWin = win;
+            let currentIFrame = currentWin.frameElement;
+            while (currentIFrame && offsetParent && offsetWin !== currentWin) {
+                const iframeScale = getScale(currentIFrame);
+                const iframeRect = currentIFrame.getBoundingClientRect();
+                const css2 = getComputedStyle$2(currentIFrame);
+                const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
+                const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
+                x2 *= iframeScale.x;
+                y2 *= iframeScale.y;
+                width *= iframeScale.x;
+                height *= iframeScale.y;
+                x2 += left2;
+                y2 += top2;
+                currentWin = getWindow$1(currentIFrame);
+                currentIFrame = currentWin.frameElement;
+            }
+        }
+        return rectToClientRect$1({
+            width,
+            height,
+            x: x2,
+            y: y2
+        });
+    }
+    const topLayerSelectors = [":popover-open", ":modal"];
+
+    function isTopLayer(floating) {
+        return topLayerSelectors.some((selector2) => {
+            try {
+                return floating.matches(selector2);
+            } catch (e3) {
+                return false;
+            }
+        });
+    }
+
+    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
+        let {
+            elements,
+            rect,
+            offsetParent,
+            strategy
+        } = _ref2;
+        const isFixed = strategy === "fixed";
+        const documentElement = getDocumentElement$1(offsetParent);
+        const topLayer = elements ? isTopLayer(elements.floating) : false;
+        if (offsetParent === documentElement || topLayer && isFixed) {
+            return rect;
+        }
+        let scroll = {
+            scrollLeft: 0,
+            scrollTop: 0
+        };
+        let scale = createCoords(1);
+        const offsets = createCoords(0);
+        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
+        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
+            if (getNodeName$1(offsetParent) !== "body" || isOverflowElement(documentElement)) {
+                scroll = getNodeScroll$1(offsetParent);
+            }
+            if (isHTMLElement$1(offsetParent)) {
+                const offsetRect = getBoundingClientRect$1(offsetParent);
+                scale = getScale(offsetParent);
+                offsets.x = offsetRect.x + offsetParent.clientLeft;
+                offsets.y = offsetRect.y + offsetParent.clientTop;
+            }
+        }
+        return {
+            width: rect.width * scale.x,
+            height: rect.height * scale.y,
+            x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
+            y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
+        };
+    }
+
+    function getClientRects(element) {
+        return Array.from(element.getClientRects());
+    }
+
+    function getWindowScrollBarX$1(element) {
+        return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
+    }
+
+    function getDocumentRect$1(element) {
+        const html = getDocumentElement$1(element);
+        const scroll = getNodeScroll$1(element);
+        const body = element.ownerDocument.body;
+        const width = max$2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
+        const height = max$2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
+        let x2 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
+        const y2 = -scroll.scrollTop;
+        if (getComputedStyle$2(body).direction === "rtl") {
+            x2 += max$2(html.clientWidth, body.clientWidth) - width;
+        }
+        return {
+            width,
+            height,
+            x: x2,
+            y: y2
+        };
+    }
+
+    function getViewportRect$1(element, strategy) {
+        const win = getWindow$1(element);
+        const html = getDocumentElement$1(element);
+        const visualViewport = win.visualViewport;
+        let width = html.clientWidth;
+        let height = html.clientHeight;
+        let x2 = 0;
+        let y2 = 0;
+        if (visualViewport) {
+            width = visualViewport.width;
+            height = visualViewport.height;
+            const visualViewportBased = isWebKit();
+            if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
+                x2 = visualViewport.offsetLeft;
+                y2 = visualViewport.offsetTop;
+            }
+        }
+        return {
+            width,
+            height,
+            x: x2,
+            y: y2
+        };
+    }
+
+    function getInnerBoundingClientRect$1(element, strategy) {
+        const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
+        const top2 = clientRect.top + element.clientTop;
+        const left2 = clientRect.left + element.clientLeft;
+        const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
+        const width = element.clientWidth * scale.x;
+        const height = element.clientHeight * scale.y;
+        const x2 = left2 * scale.x;
+        const y2 = top2 * scale.y;
+        return {
+            width,
+            height,
+            x: x2,
+            y: y2
+        };
+    }
+
+    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
+        let rect;
+        if (clippingAncestor === "viewport") {
+            rect = getViewportRect$1(element, strategy);
+        } else if (clippingAncestor === "document") {
+            rect = getDocumentRect$1(getDocumentElement$1(element));
+        } else if (isElement$3(clippingAncestor)) {
+            rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
+        } else {
+            const visualOffsets = getVisualOffsets(element);
+            rect = {
+                ...clippingAncestor,
+                x: clippingAncestor.x - visualOffsets.x,
+                y: clippingAncestor.y - visualOffsets.y
+            };
+        }
+        return rectToClientRect$1(rect);
+    }
+
+    function hasFixedPositionAncestor(element, stopNode) {
+        const parentNode = getParentNode$1(element);
+        if (parentNode === stopNode || !isElement$3(parentNode) || isLastTraversableNode(parentNode)) {
+            return false;
+        }
+        return getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
+    }
+
+    function getClippingElementAncestors(element, cache2) {
+        const cachedResult = cache2.get(element);
+        if (cachedResult) {
+            return cachedResult;
+        }
+        let result = getOverflowAncestors(element, [], false).filter((el) => isElement$3(el) && getNodeName$1(el) !== "body");
+        let currentContainingBlockComputedStyle = null;
+        const elementIsFixed = getComputedStyle$2(element).position === "fixed";
+        let currentNode = elementIsFixed ? getParentNode$1(element) : element;
+        while (isElement$3(currentNode) && !isLastTraversableNode(currentNode)) {
+            const computedStyle = getComputedStyle$2(currentNode);
+            const currentNodeIsContaining = isContainingBlock(currentNode);
+            if (!currentNodeIsContaining && computedStyle.position === "fixed") {
+                currentContainingBlockComputedStyle = null;
+            }
+            const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
+            if (shouldDropCurrentNode) {
+                result = result.filter((ancestor) => ancestor !== currentNode);
+            } else {
+                currentContainingBlockComputedStyle = computedStyle;
+            }
+            currentNode = getParentNode$1(currentNode);
+        }
+        cache2.set(element, result);
+        return result;
+    }
+
+    function getClippingRect$1(_ref2) {
+        let {
+            element,
+            boundary,
+            rootBoundary,
+            strategy
+        } = _ref2;
+        const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
+        const clippingAncestors = [...elementClippingAncestors, rootBoundary];
+        const firstClippingAncestor = clippingAncestors[0];
+        const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
+            const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
+            accRect.top = max$2(rect.top, accRect.top);
+            accRect.right = min$2(rect.right, accRect.right);
+            accRect.bottom = min$2(rect.bottom, accRect.bottom);
+            accRect.left = max$2(rect.left, accRect.left);
+            return accRect;
+        }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
+        return {
+            width: clippingRect.right - clippingRect.left,
+            height: clippingRect.bottom - clippingRect.top,
+            x: clippingRect.left,
+            y: clippingRect.top
+        };
+    }
+
+    function getDimensions(element) {
+        const {
+            width,
+            height
+        } = getCssDimensions(element);
+        return {
+            width,
+            height
+        };
+    }
+
+    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
+        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
+        const documentElement = getDocumentElement$1(offsetParent);
+        const isFixed = strategy === "fixed";
+        const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
+        let scroll = {
+            scrollLeft: 0,
+            scrollTop: 0
+        };
+        const offsets = createCoords(0);
+        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
+            if (getNodeName$1(offsetParent) !== "body" || isOverflowElement(documentElement)) {
+                scroll = getNodeScroll$1(offsetParent);
+            }
+            if (isOffsetParentAnElement) {
+                const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
+                offsets.x = offsetRect.x + offsetParent.clientLeft;
+                offsets.y = offsetRect.y + offsetParent.clientTop;
+            } else if (documentElement) {
+                offsets.x = getWindowScrollBarX$1(documentElement);
+            }
+        }
+        const x2 = rect.left + scroll.scrollLeft - offsets.x;
+        const y2 = rect.top + scroll.scrollTop - offsets.y;
+        return {
+            x: x2,
+            y: y2,
+            width: rect.width,
+            height: rect.height
+        };
+    }
+
+    function getTrueOffsetParent$1(element, polyfill) {
+        if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
+            return null;
+        }
+        if (polyfill) {
+            return polyfill(element);
+        }
+        return element.offsetParent;
+    }
+
+    function getOffsetParent$1(element, polyfill) {
+        const window2 = getWindow$1(element);
+        if (!isHTMLElement$1(element) || isTopLayer(element)) {
+            return window2;
+        }
+        let offsetParent = getTrueOffsetParent$1(element, polyfill);
+        while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
+            offsetParent = getTrueOffsetParent$1(offsetParent, polyfill);
+        }
+        if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
+            return window2;
+        }
+        return offsetParent || getContainingBlock$1(element) || window2;
+    }
+    const getElementRects = async function(data) {
+        const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
+        const getDimensionsFn = this.getDimensions;
+        const floatingDimensions = await getDimensionsFn(data.floating);
+        return {
+            reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
+            floating: {
+                x: 0,
+                y: 0,
+                width: floatingDimensions.width,
+                height: floatingDimensions.height
+            }
+        };
+    };
+
+    function isRTL(element) {
+        return getComputedStyle$2(element).direction === "rtl";
+    }
+    const platform = {
+        convertOffsetParentRelativeRectToViewportRelativeRect,
+        getDocumentElement: getDocumentElement$1,
+        getClippingRect: getClippingRect$1,
+        getOffsetParent: getOffsetParent$1,
+        getElementRects,
+        getClientRects,
+        getDimensions,
+        getScale,
+        isElement: isElement$3,
+        isRTL
+    };
+
+    function observeMove(element, onMove) {
+        let io = null;
+        let timeoutId;
+        const root2 = getDocumentElement$1(element);
+
+        function cleanup() {
+            var _io;
+            clearTimeout(timeoutId);
+            (_io = io) == null || _io.disconnect();
+            io = null;
+        }
+
+        function refresh(skip, threshold) {
+            if (skip === void 0) {
+                skip = false;
+            }
+            if (threshold === void 0) {
+                threshold = 1;
+            }
+            cleanup();
+            const {
+                left: left2,
+                top: top2,
+                width,
+                height
+            } = element.getBoundingClientRect();
+            if (!skip) {
+                onMove();
+            }
+            if (!width || !height) {
+                return;
+            }
+            const insetTop = floor(top2);
+            const insetRight = floor(root2.clientWidth - (left2 + width));
+            const insetBottom = floor(root2.clientHeight - (top2 + height));
+            const insetLeft = floor(left2);
+            const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
+            const options = {
+                rootMargin,
+                threshold: max$2(0, min$2(1, threshold)) || 1
+            };
+            let isFirstUpdate = true;
+
+            function handleObserve(entries) {
+                const ratio = entries[0].intersectionRatio;
+                if (ratio !== threshold) {
+                    if (!isFirstUpdate) {
+                        return refresh();
+                    }
+                    if (!ratio) {
+                        timeoutId = setTimeout(() => {
+                            refresh(false, 1e-7);
+                        }, 1e3);
+                    } else {
+                        refresh(false, ratio);
+                    }
+                }
+                isFirstUpdate = false;
+            }
+            try {
+                io = new IntersectionObserver(handleObserve, {
+                    ...options,
+                    root: root2.ownerDocument
+                });
+            } catch (e3) {
+                io = new IntersectionObserver(handleObserve, options);
+            }
+            io.observe(element);
+        }
+        refresh(true);
+        return cleanup;
+    }
+
+    function autoUpdate(reference2, floating, update, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        const {
+            ancestorScroll = true,
+                ancestorResize = true,
+                elementResize = typeof ResizeObserver === "function",
+                layoutShift = typeof IntersectionObserver === "function",
+                animationFrame = false
+        } = options;
+        const referenceEl = unwrapElement(reference2);
+        const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
+        ancestors.forEach((ancestor) => {
+            ancestorScroll && ancestor.addEventListener("scroll", update, {
+                passive: true
+            });
+            ancestorResize && ancestor.addEventListener("resize", update);
+        });
+        const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
+        let reobserveFrame = -1;
+        let resizeObserver = null;
+        if (elementResize) {
+            resizeObserver = new ResizeObserver((_ref2) => {
+                let [firstEntry] = _ref2;
+                if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
+                    resizeObserver.unobserve(floating);
+                    cancelAnimationFrame(reobserveFrame);
+                    reobserveFrame = requestAnimationFrame(() => {
+                        var _resizeObserver;
+                        (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
+                    });
+                }
+                update();
+            });
+            if (referenceEl && !animationFrame) {
+                resizeObserver.observe(referenceEl);
+            }
+            resizeObserver.observe(floating);
+        }
+        let frameId;
+        let prevRefRect = animationFrame ? getBoundingClientRect$1(reference2) : null;
+        if (animationFrame) {
+            frameLoop();
+        }
+
+        function frameLoop() {
+            const nextRefRect = getBoundingClientRect$1(reference2);
+            if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
+                update();
+            }
+            prevRefRect = nextRefRect;
+            frameId = requestAnimationFrame(frameLoop);
+        }
+        update();
+        return () => {
+            var _resizeObserver2;
+            ancestors.forEach((ancestor) => {
+                ancestorScroll && ancestor.removeEventListener("scroll", update);
+                ancestorResize && ancestor.removeEventListener("resize", update);
+            });
+            cleanupIo == null || cleanupIo();
+            (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
+            resizeObserver = null;
+            if (animationFrame) {
+                cancelAnimationFrame(frameId);
+            }
+        };
+    }
+    const offset$2 = offset$3;
+    autoPlacement;
+    const shift = shift$1;
+    const flip$2 = flip$3;
+    const size$1 = size$2;
+    hide$2;
+    arrow$2;
+    inline;
+    limitShift;
+    const computePosition = (reference2, floating, options) => {
+        const cache2 = /* @__PURE__ */ new Map();
+        const mergedOptions = {
+            platform,
+            ...options
+        };
+        const platformWithCache = {
+            ...mergedOptions.platform,
+            _c: cache2
+        };
+        return computePosition$1(reference2, floating, {
+            ...mergedOptions,
+            platform: platformWithCache
+        });
+    };
+    var index$3 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
+
+    function deepEqual(a2, b2) {
+        if (a2 === b2) {
+            return true;
+        }
+        if (typeof a2 !== typeof b2) {
+            return false;
+        }
+        if (typeof a2 === "function" && a2.toString() === b2.toString()) {
+            return true;
+        }
+        let length;
+        let i2;
+        let keys2;
+        if (a2 && b2 && typeof a2 === "object") {
+            if (Array.isArray(a2)) {
+                length = a2.length;
+                if (length !== b2.length)
+                    return false;
+                for (i2 = length; i2-- !== 0;) {
+                    if (!deepEqual(a2[i2], b2[i2])) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            keys2 = Object.keys(a2);
+            length = keys2.length;
+            if (length !== Object.keys(b2).length) {
+                return false;
+            }
+            for (i2 = length; i2-- !== 0;) {
+                if (!{}.hasOwnProperty.call(b2, keys2[i2])) {
+                    return false;
+                }
+            }
+            for (i2 = length; i2-- !== 0;) {
+                const key = keys2[i2];
+                if (key === "_owner" && a2.$$typeof) {
+                    continue;
+                }
+                if (!deepEqual(a2[key], b2[key])) {
+                    return false;
+                }
+            }
+            return true;
+        }
+        return a2 !== a2 && b2 !== b2;
+    }
+
+    function getDPR(element) {
+        if (typeof window === "undefined") {
+            return 1;
+        }
+        const win = element.ownerDocument.defaultView || window;
+        return win.devicePixelRatio || 1;
+    }
+
+    function roundByDPR(element, value) {
+        const dpr = getDPR(element);
+        return Math.round(value * dpr) / dpr;
+    }
+
+    function useLatestRef$1(value) {
+        const ref = React__namespace.useRef(value);
+        index$3(() => {
+            ref.current = value;
+        });
+        return ref;
+    }
+
+    function useFloating$1(options) {
+        if (options === void 0) {
+            options = {};
+        }
+        const {
+            placement = "bottom",
+                strategy = "absolute",
+                middleware = [],
+                platform: platform2,
+                elements: {
+                    reference: externalReference,
+                    floating: externalFloating
+                } = {},
+                transform = true,
+                whileElementsMounted,
+                open: open2
+        } = options;
+        const [data, setData2] = React__namespace.useState({
+            x: 0,
+            y: 0,
+            strategy,
+            placement,
+            middlewareData: {},
+            isPositioned: false
+        });
+        const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
+        if (!deepEqual(latestMiddleware, middleware)) {
+            setLatestMiddleware(middleware);
+        }
+        const [_reference, _setReference] = React__namespace.useState(null);
+        const [_floating, _setFloating] = React__namespace.useState(null);
+        const setReference = React__namespace.useCallback((node) => {
+            if (node !== referenceRef.current) {
+                referenceRef.current = node;
+                _setReference(node);
+            }
+        }, []);
+        const setFloating = React__namespace.useCallback((node) => {
+            if (node !== floatingRef.current) {
+                floatingRef.current = node;
+                _setFloating(node);
+            }
+        }, []);
+        const referenceEl = externalReference || _reference;
+        const floatingEl = externalFloating || _floating;
+        const referenceRef = React__namespace.useRef(null);
+        const floatingRef = React__namespace.useRef(null);
+        const dataRef = React__namespace.useRef(data);
+        const hasWhileElementsMounted = whileElementsMounted != null;
+        const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
+        const platformRef = useLatestRef$1(platform2);
+        const update = React__namespace.useCallback(() => {
+            if (!referenceRef.current || !floatingRef.current) {
+                return;
+            }
+            const config2 = {
+                placement,
+                strategy,
+                middleware: latestMiddleware
+            };
+            if (platformRef.current) {
+                config2.platform = platformRef.current;
+            }
+            computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
+                const fullData = {
+                    ...data2,
+                    isPositioned: true
+                };
+                if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
+                    dataRef.current = fullData;
+                    ReactDOM__namespace.flushSync(() => {
+                        setData2(fullData);
+                    });
+                }
+            });
+        }, [latestMiddleware, placement, strategy, platformRef]);
+        index$3(() => {
+            if (open2 === false && dataRef.current.isPositioned) {
+                dataRef.current.isPositioned = false;
+                setData2((data2) => ({
+                    ...data2,
+                    isPositioned: false
+                }));
+            }
+        }, [open2]);
+        const isMountedRef = React__namespace.useRef(false);
+        index$3(() => {
+            isMountedRef.current = true;
+            return () => {
+                isMountedRef.current = false;
+            };
+        }, []);
+        index$3(() => {
+            if (referenceEl)
+                referenceRef.current = referenceEl;
+            if (floatingEl)
+                floatingRef.current = floatingEl;
+            if (referenceEl && floatingEl) {
+                if (whileElementsMountedRef.current) {
+                    return whileElementsMountedRef.current(referenceEl, floatingEl, update);
+                }
+                update();
+            }
+        }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
+        const refs = React__namespace.useMemo(() => ({
+            reference: referenceRef,
+            floating: floatingRef,
+            setReference,
+            setFloating
+        }), [setReference, setFloating]);
+        const elements = React__namespace.useMemo(() => ({
+            reference: referenceEl,
+            floating: floatingEl
+        }), [referenceEl, floatingEl]);
+        const floatingStyles = React__namespace.useMemo(() => {
+            const initialStyles = {
+                position: strategy,
+                left: 0,
+                top: 0
+            };
+            if (!elements.floating) {
+                return initialStyles;
+            }
+            const x2 = roundByDPR(elements.floating, data.x);
+            const y2 = roundByDPR(elements.floating, data.y);
+            if (transform) {
+                return {
+                    ...initialStyles,
+                    transform: "translate(" + x2 + "px, " + y2 + "px)",
+                    ...getDPR(elements.floating) >= 1.5 && {
+                        willChange: "transform"
+                    }
+                };
+            }
+            return {
+                position: strategy,
+                left: x2,
+                top: y2
+            };
+        }, [strategy, transform, elements.floating, data.x, data.y]);
+        return React__namespace.useMemo(() => ({
+            ...data,
+            update,
+            refs,
+            elements,
+            floatingStyles
+        }), [data, update, refs, elements, floatingStyles]);
+    }
+    const SafeReact = {
+        ...React__namespace
+    };
+    const useInsertionEffect = SafeReact.useInsertionEffect;
+    const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
+
+    function useEffectEvent(callback) {
+        const ref = React__namespace.useRef(() => {});
+        useSafeInsertionEffect(() => {
+            ref.current = callback;
+        });
+        return React__namespace.useCallback(function() {
+            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                args[_key] = arguments[_key];
+            }
+            return ref.current == null ? void 0 : ref.current(...args);
+        }, []);
+    }
+    var index$2 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
+    let serverHandoffComplete = false;
+    let count = 0;
+    const genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
+
+    function useFloatingId() {
+        const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : void 0);
+        index$2(() => {
+            if (id == null) {
+                setId(genId());
+            }
+        }, []);
+        React__namespace.useEffect(() => {
+            serverHandoffComplete = true;
+        }, []);
+        return id;
+    }
+    const useReactId = SafeReact.useId;
+    const useId = useReactId || useFloatingId;
+
+    function createPubSub() {
+        const map2 = /* @__PURE__ */ new Map();
+        return {
+            emit(event, data) {
+                var _map$get;
+                (_map$get = map2.get(event)) == null || _map$get.forEach((handler) => handler(data));
+            },
+            on(event, listener2) {
+                map2.set(event, [...map2.get(event) || [], listener2]);
+            },
+            off(event, listener2) {
+                var _map$get2;
+                map2.set(event, ((_map$get2 = map2.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener2)) || []);
+            }
+        };
+    }
+    const FloatingNodeContext = /* @__PURE__ */ React__namespace.createContext(null);
+    const FloatingTreeContext = /* @__PURE__ */ React__namespace.createContext(null);
+    const useFloatingParentNodeId = () => {
+        var _React$useContext;
+        return ((_React$useContext = React__namespace.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
+    };
+    const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);
+
+    function createAttribute(name) {
+        return "data-floating-ui-" + name;
+    }
+
+    function getChildren$2(nodes2, id) {
+        let allChildren = nodes2.filter((node) => {
+            var _node$context;
+            return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
+        });
+        let currentChildren = allChildren;
+        while (currentChildren.length) {
+            currentChildren = nodes2.filter((node) => {
+                var _currentChildren;
+                return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
+                    var _node$context2;
+                    return node.parentId === n2.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
+                });
+            });
+            allChildren = allChildren.concat(currentChildren);
+        }
+        return allChildren;
+    }
+
+    function isButtonTarget(event) {
+        return isHTMLElement$1(event.target) && event.target.tagName === "BUTTON";
+    }
+
+    function isSpaceIgnored(element) {
+        return isTypeableElement(element);
+    }
+
+    function useClick(context2, props) {
+        if (props === void 0) {
+            props = {};
+        }
+        const {
+            open: open2,
+            onOpenChange,
+            dataRef,
+            elements: {
+                domReference
+            }
+        } = context2;
+        const {
+            enabled = true,
+                event: eventOption = "click",
+                toggle = true,
+                ignoreMouse = false,
+                keyboardHandlers = true
+        } = props;
+        const pointerTypeRef = React__namespace.useRef();
+        const didKeyDownRef = React__namespace.useRef(false);
+        return React__namespace.useMemo(() => {
+            if (!enabled)
+                return {};
+            return {
+                reference: {
+                    onPointerDown(event) {
+                        pointerTypeRef.current = event.pointerType;
+                    },
+                    onMouseDown(event) {
+                        if (event.button !== 0) {
+                            return;
+                        }
+                        if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
+                            return;
+                        }
+                        if (eventOption === "click") {
+                            return;
+                        }
+                        if (open2 && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
+                            onOpenChange(false, event.nativeEvent, "click");
+                        } else {
+                            event.preventDefault();
+                            onOpenChange(true, event.nativeEvent, "click");
+                        }
+                    },
+                    onClick(event) {
+                        if (eventOption === "mousedown" && pointerTypeRef.current) {
+                            pointerTypeRef.current = void 0;
+                            return;
+                        }
+                        if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
+                            return;
+                        }
+                        if (open2 && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
+                            onOpenChange(false, event.nativeEvent, "click");
+                        } else {
+                            onOpenChange(true, event.nativeEvent, "click");
+                        }
+                    },
+                    onKeyDown(event) {
+                        pointerTypeRef.current = void 0;
+                        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
+                            return;
+                        }
+                        if (event.key === " " && !isSpaceIgnored(domReference)) {
+                            event.preventDefault();
+                            didKeyDownRef.current = true;
+                        }
+                        if (event.key === "Enter") {
+                            if (open2 && toggle) {
+                                onOpenChange(false, event.nativeEvent, "click");
+                            } else {
+                                onOpenChange(true, event.nativeEvent, "click");
+                            }
+                        }
+                    },
+                    onKeyUp(event) {
+                        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
+                            return;
+                        }
+                        if (event.key === " " && didKeyDownRef.current) {
+                            didKeyDownRef.current = false;
+                            if (open2 && toggle) {
+                                onOpenChange(false, event.nativeEvent, "click");
+                            } else {
+                                onOpenChange(true, event.nativeEvent, "click");
+                            }
+                        }
+                    }
+                }
+            };
+        }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open2, onOpenChange]);
+    }
+    const bubbleHandlerKeys = {
+        pointerdown: "onPointerDown",
+        mousedown: "onMouseDown",
+        click: "onClick"
+    };
+    const captureHandlerKeys = {
+        pointerdown: "onPointerDownCapture",
+        mousedown: "onMouseDownCapture",
+        click: "onClickCapture"
+    };
+    const normalizeProp = (normalizable) => {
+        var _normalizable$escapeK, _normalizable$outside;
+        return {
+            escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
+            outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
+        };
+    };
+
+    function useDismiss(context2, props) {
+        if (props === void 0) {
+            props = {};
+        }
+        const {
+            open: open2,
+            onOpenChange,
+            nodeId,
+            elements: {
+                reference: reference2,
+                domReference,
+                floating
+            },
+            dataRef
+        } = context2;
+        const {
+            enabled = true,
+                escapeKey = true,
+                outsidePress: unstable_outsidePress = true,
+                outsidePressEvent = "pointerdown",
+                referencePress = false,
+                referencePressEvent = "pointerdown",
+                ancestorScroll = false,
+                bubbles,
+                capture
+        } = props;
+        const tree = useFloatingTree();
+        const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
+        const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
+        const insideReactTreeRef = React__namespace.useRef(false);
+        const endedOrStartedInsideRef = React__namespace.useRef(false);
+        const {
+            escapeKey: escapeKeyBubbles,
+            outsidePress: outsidePressBubbles
+        } = normalizeProp(bubbles);
+        const {
+            escapeKey: escapeKeyCapture,
+            outsidePress: outsidePressCapture
+        } = normalizeProp(capture);
+        const closeOnEscapeKeyDown = useEffectEvent((event) => {
+            if (!open2 || !enabled || !escapeKey || event.key !== "Escape") {
+                return;
+            }
+            const children = tree ? getChildren$2(tree.nodesRef.current, nodeId) : [];
+            if (!escapeKeyBubbles) {
+                event.stopPropagation();
+                if (children.length > 0) {
+                    let shouldDismiss = true;
+                    children.forEach((child) => {
+                        var _child$context;
+                        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
+                            shouldDismiss = false;
+                            return;
+                        }
+                    });
+                    if (!shouldDismiss) {
+                        return;
+                    }
+                }
+            }
+            onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
+        });
+        const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
+            var _getTarget2;
+            const callback = () => {
+                var _getTarget;
+                closeOnEscapeKeyDown(event);
+                (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
+            };
+            (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
+        });
+        const closeOnPressOutside = useEffectEvent((event) => {
+            const insideReactTree = insideReactTreeRef.current;
+            insideReactTreeRef.current = false;
+            const endedOrStartedInside = endedOrStartedInsideRef.current;
+            endedOrStartedInsideRef.current = false;
+            if (outsidePressEvent === "click" && endedOrStartedInside) {
+                return;
+            }
+            if (insideReactTree) {
+                return;
+            }
+            if (typeof outsidePress === "function" && !outsidePress(event)) {
+                return;
+            }
+            const target = getTarget(event);
+            const inertSelector = "[" + createAttribute("inert") + "]";
+            const markers = getDocument(floating).querySelectorAll(inertSelector);
+            let targetRootAncestor = isElement$3(target) ? target : null;
+            while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
+                const nextParent = getParentNode$1(targetRootAncestor);
+                if (isLastTraversableNode(nextParent) || !isElement$3(nextParent)) {
+                    break;
+                }
+                targetRootAncestor = nextParent;
+            }
+            if (markers.length && isElement$3(target) && !isRootElement(target) && !contains$1(target, floating) && Array.from(markers).every((marker) => !contains$1(targetRootAncestor, marker))) {
+                return;
+            }
+            if (isHTMLElement$1(target) && floating) {
+                const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
+                const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
+                let xCond = canScrollY && event.offsetX > target.clientWidth;
+                if (canScrollY) {
+                    const isRTL2 = getComputedStyle$2(target).direction === "rtl";
+                    if (isRTL2) {
+                        xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
+                    }
+                }
+                if (xCond || canScrollX && event.offsetY > target.clientHeight) {
+                    return;
+                }
+            }
+            const targetIsInsideChildren = tree && getChildren$2(tree.nodesRef.current, nodeId).some((node) => {
+                var _node$context;
+                return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
+            });
+            if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {
+                return;
+            }
+            const children = tree ? getChildren$2(tree.nodesRef.current, nodeId) : [];
+            if (children.length > 0) {
+                let shouldDismiss = true;
+                children.forEach((child) => {
+                    var _child$context2;
+                    if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
+                        shouldDismiss = false;
+                        return;
+                    }
+                });
+                if (!shouldDismiss) {
+                    return;
+                }
+            }
+            onOpenChange(false, event, "outside-press");
+        });
+        const closeOnPressOutsideCapture = useEffectEvent((event) => {
+            var _getTarget4;
+            const callback = () => {
+                var _getTarget3;
+                closeOnPressOutside(event);
+                (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
+            };
+            (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
+        });
+        React__namespace.useEffect(() => {
+            if (!open2 || !enabled) {
+                return;
+            }
+            dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
+            dataRef.current.__outsidePressBubbles = outsidePressBubbles;
+
+            function onScroll(event) {
+                onOpenChange(false, event, "ancestor-scroll");
+            }
+            const doc = getDocument(floating);
+            escapeKey && doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
+            outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
+            let ancestors = [];
+            if (ancestorScroll) {
+                if (isElement$3(domReference)) {
+                    ancestors = getOverflowAncestors(domReference);
+                }
+                if (isElement$3(floating)) {
+                    ancestors = ancestors.concat(getOverflowAncestors(floating));
+                }
+                if (!isElement$3(reference2) && reference2 && reference2.contextElement) {
+                    ancestors = ancestors.concat(getOverflowAncestors(reference2.contextElement));
+                }
+            }
+            ancestors = ancestors.filter((ancestor) => {
+                var _doc$defaultView;
+                return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
+            });
+            ancestors.forEach((ancestor) => {
+                ancestor.addEventListener("scroll", onScroll, {
+                    passive: true
+                });
+            });
+            return () => {
+                escapeKey && doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
+                outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
+                ancestors.forEach((ancestor) => {
+                    ancestor.removeEventListener("scroll", onScroll);
+                });
+            };
+        }, [dataRef, floating, domReference, reference2, escapeKey, outsidePress, outsidePressEvent, open2, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
+        React__namespace.useEffect(() => {
+            insideReactTreeRef.current = false;
+        }, [outsidePress, outsidePressEvent]);
+        return React__namespace.useMemo(() => {
+            if (!enabled) {
+                return {};
+            }
+            return {
+                reference: {
+                    onKeyDown: closeOnEscapeKeyDown,
+                    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
+                        if (referencePress) {
+                            onOpenChange(false, event.nativeEvent, "reference-press");
+                        }
+                    }
+                },
+                floating: {
+                    onKeyDown: closeOnEscapeKeyDown,
+                    onMouseDown() {
+                        endedOrStartedInsideRef.current = true;
+                    },
+                    onMouseUp() {
+                        endedOrStartedInsideRef.current = true;
+                    },
+                    [captureHandlerKeys[outsidePressEvent]]: () => {
+                        insideReactTreeRef.current = true;
+                    }
+                }
+            };
+        }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
+    }
+
+    function useFloating(options) {
+        var _options$elements;
+        if (options === void 0) {
+            options = {};
+        }
+        const {
+            open: open2 = false,
+            onOpenChange: unstable_onOpenChange,
+            nodeId
+        } = options;
+        const [_domReference, setDomReference] = React__namespace.useState(null);
+        const [positionReference, _setPositionReference] = React__namespace.useState(null);
+        const optionDomReference = (_options$elements = options.elements) == null ? void 0 : _options$elements.reference;
+        const domReference = optionDomReference || _domReference;
+        index$2(() => {
+            if (domReference) {
+                domReferenceRef.current = domReference;
+            }
+        }, [domReference]);
+        const position = useFloating$1({
+            ...options,
+            elements: {
+                ...options.elements,
+                ...positionReference && {
+                    reference: positionReference
+                }
+            }
+        });
+        const tree = useFloatingTree();
+        const nested = useFloatingParentNodeId() != null;
+        const onOpenChange = useEffectEvent((open3, event, reason) => {
+            dataRef.current.openEvent = open3 ? event : void 0;
+            events.emit("openchange", {
+                open: open3,
+                event,
+                reason,
+                nested
+            });
+            unstable_onOpenChange == null || unstable_onOpenChange(open3, event, reason);
+        });
+        const domReferenceRef = React__namespace.useRef(null);
+        const dataRef = React__namespace.useRef({});
+        const events = React__namespace.useState(() => createPubSub())[0];
+        const floatingId = useId();
+        const setPositionReference = React__namespace.useCallback((node) => {
+            const computedPositionReference = isElement$3(node) ? {
+                getBoundingClientRect: () => node.getBoundingClientRect(),
+                contextElement: node
+            } : node;
+            _setPositionReference(computedPositionReference);
+            position.refs.setReference(computedPositionReference);
+        }, [position.refs]);
+        const setReference = React__namespace.useCallback((node) => {
+            if (isElement$3(node) || node === null) {
+                domReferenceRef.current = node;
+                setDomReference(node);
+            }
+            if (isElement$3(position.refs.reference.current) || position.refs.reference.current === null || node !== null && !isElement$3(node)) {
+                position.refs.setReference(node);
+            }
+        }, [position.refs]);
+        const refs = React__namespace.useMemo(() => ({
+            ...position.refs,
+            setReference,
+            setPositionReference,
+            domReference: domReferenceRef
+        }), [position.refs, setReference, setPositionReference]);
+        const elements = React__namespace.useMemo(() => ({
+            ...position.elements,
+            domReference
+        }), [position.elements, domReference]);
+        const context2 = React__namespace.useMemo(() => ({
+            ...position,
+            refs,
+            elements,
+            dataRef,
+            nodeId,
+            floatingId,
+            events,
+            open: open2,
+            onOpenChange
+        }), [position, nodeId, floatingId, events, open2, onOpenChange, refs, elements]);
+        index$2(() => {
+            const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
+            if (node) {
+                node.context = context2;
+            }
+        });
+        return React__namespace.useMemo(() => ({
+            ...position,
+            context: context2,
+            refs,
+            elements
+        }), [position, refs, elements, context2]);
+    }
+    const ACTIVE_KEY = "active";
+    const SELECTED_KEY = "selected";
+
+    function mergeProps(userProps, propsList, elementKey) {
+        const map2 = /* @__PURE__ */ new Map();
+        const isItem = elementKey === "item";
+        let domUserProps = userProps;
+        if (isItem && userProps) {
+            const {
+                [ACTIVE_KEY]: _,
+                [SELECTED_KEY]: __,
+                ...validProps
+            } = userProps;
+            domUserProps = validProps;
+        }
+        return {
+            ...elementKey === "floating" && {
+                tabIndex: -1
+            },
+            ...domUserProps,
+            ...propsList.map((value) => {
+                const propsOrGetProps = value ? value[elementKey] : null;
+                if (typeof propsOrGetProps === "function") {
+                    return userProps ? propsOrGetProps(userProps) : null;
+                }
+                return propsOrGetProps;
+            }).concat(userProps).reduce((acc, props) => {
+                if (!props) {
+                    return acc;
+                }
+                Object.entries(props).forEach((_ref2) => {
+                    let [key, value] = _ref2;
+                    if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
+                        return;
+                    }
+                    if (key.indexOf("on") === 0) {
+                        if (!map2.has(key)) {
+                            map2.set(key, []);
+                        }
+                        if (typeof value === "function") {
+                            var _map$get;
+                            (_map$get = map2.get(key)) == null || _map$get.push(value);
+                            acc[key] = function() {
+                                var _map$get2;
+                                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+                                    args[_key] = arguments[_key];
+                                }
+                                return (_map$get2 = map2.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
+                            };
+                        }
+                    } else {
+                        acc[key] = value;
+                    }
+                });
+                return acc;
+            }, {})
+        };
+    }
+
+    function useInteractions(propsList) {
+        if (propsList === void 0) {
+            propsList = [];
+        }
+        const deps = propsList;
+        const getReferenceProps = React__namespace.useCallback(
+            (userProps) => mergeProps(userProps, propsList, "reference"),
+            deps
+        );
+        const getFloatingProps = React__namespace.useCallback(
+            (userProps) => mergeProps(userProps, propsList, "floating"),
+            deps
+        );
+        const getItemProps = React__namespace.useCallback(
+            (userProps) => mergeProps(userProps, propsList, "item"),
+            propsList.map((key) => key == null ? void 0 : key.item)
+        );
+        return React__namespace.useMemo(() => ({
+            getReferenceProps,
+            getFloatingProps,
+            getItemProps
+        }), [getReferenceProps, getFloatingProps, getItemProps]);
+    }
+    const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([
+        ["select", "listbox"],
+        ["combobox", "listbox"],
+        ["label", false]
+    ]);
+
+    function useRole(context2, props) {
+        var _componentRoleToAriaR;
+        if (props === void 0) {
+            props = {};
+        }
+        const {
+            open: open2,
+            floatingId
+        } = context2;
+        const {
+            enabled = true,
+                role = "dialog"
+        } = props;
+        const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
+        const referenceId = useId();
+        const parentId = useFloatingParentNodeId();
+        const isNested = parentId != null;
+        return React__namespace.useMemo(() => {
+            if (!enabled)
+                return {};
+            const floatingProps = {
+                id: floatingId,
+                ...ariaRole && {
+                    role: ariaRole
+                }
+            };
+            if (ariaRole === "tooltip" || role === "label") {
+                return {
+                    reference: {
+                        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open2 ? floatingId : void 0
+                    },
+                    floating: floatingProps
+                };
+            }
+            return {
+                reference: {
+                    "aria-expanded": open2 ? "true" : "false",
+                    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
+                    "aria-controls": open2 ? floatingId : void 0,
+                    ...ariaRole === "listbox" && {
+                        role: "combobox"
+                    },
+                    ...ariaRole === "menu" && {
+                        id: referenceId
+                    },
+                    ...ariaRole === "menu" && isNested && {
+                        role: "menuitem"
+                    },
+                    ...role === "select" && {
+                        "aria-autocomplete": "none"
+                    },
+                    ...role === "combobox" && {
+                        "aria-autocomplete": "list"
+                    }
+                },
+                floating: {
+                    ...floatingProps,
+                    ...ariaRole === "menu" && {
+                        "aria-labelledby": referenceId
+                    }
+                },
+                item(_ref2) {
+                    let {
+                        active,
+                        selected
+                    } = _ref2;
+                    const commonProps = {
+                        role: "option",
+                        ...active && {
+                            id: floatingId + "-option"
+                        }
+                    };
+                    switch (role) {
+                        case "select":
+                            return {
+                                ...commonProps,
+                                "aria-selected": active && selected
+                            };
+                        case "combobox": {
+                            return {
+                                ...commonProps,
+                                ...active && {
+                                    "aria-selected": true
+                                }
+                            };
+                        }
+                    }
+                    return {};
+                }
+            };
+        }, [enabled, role, ariaRole, open2, floatingId, referenceId, isNested]);
+    }
+    const matchWidthToReference = (delta = 0) => size$1({
+        apply({
+            rects,
+            elements
+        }) {
+            Object.assign(elements.floating.style, {
+                width: `${rects.reference.width + delta}px`
+            });
+        }
+    });
     styled__default.default.div`
     width: 100%;
     background-color: ${(props) => {
     var _a;
     return (_a = props.backgroundColor) !== null && _a !== void 0 ? _a : props.theme.colors.blue1;
   }};
     border: 1px solid ${(props) => props.theme.colors.grey1};
@@ -23668,26 +26392,26 @@
 
                 function setWrapToString2(wrapper, reference2, bitmask) {
                     var source = reference2 + "";
                     return setToString2(wrapper, insertWrapDetails2(source, updateWrapDetails2(getWrapDetails2(source), bitmask)));
                 }
 
                 function shortOut2(func) {
-                    var count = 0,
+                    var count2 = 0,
                         lastCalled = 0;
                     return function() {
                         var stamp = nativeNow2(),
                             remaining = HOT_SPAN2 - (stamp - lastCalled);
                         lastCalled = stamp;
                         if (remaining > 0) {
-                            if (++count >= HOT_COUNT2) {
+                            if (++count2 >= HOT_COUNT2) {
                                 return arguments[0];
                             }
                         } else {
-                            count = 0;
+                            count2 = 0;
                         }
                         return func.apply(undefined$1, arguments);
                     };
                 }
 
                 function shuffleSelf(array2, size3) {
                     var index2 = -1,
@@ -25858,15 +28582,15 @@
                 var add = createMathOperation(function(augend, addend) {
                     return augend + addend;
                 }, 0);
                 var ceil = createRound("ceil");
                 var divide = createMathOperation(function(dividend, divisor) {
                     return dividend / divisor;
                 }, 1);
-                var floor = createRound("floor");
+                var floor2 = createRound("floor");
 
                 function max2(array2) {
                     return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$1;
                 }
 
                 function maxBy(array2, iteratee2) {
                     return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
@@ -26077,15 +28801,15 @@
                 lodash2.every = every;
                 lodash2.find = find;
                 lodash2.findIndex = findIndex2;
                 lodash2.findKey = findKey2;
                 lodash2.findLast = findLast;
                 lodash2.findLastIndex = findLastIndex;
                 lodash2.findLastKey = findLastKey;
-                lodash2.floor = floor;
+                lodash2.floor = floor2;
                 lodash2.forEach = forEach;
                 lodash2.forEachRight = forEachRight;
                 lodash2.forIn = forIn;
                 lodash2.forInRight = forInRight;
                 lodash2.forOwn = forOwn;
                 lodash2.forOwnRight = forOwnRight;
                 lodash2.get = get2;
@@ -26562,23 +29286,23 @@
         },
         almostXYears: {
             one: "almost 1 year",
             other: "almost {{count}} years"
         }
     };
 
-    function formatDistance$2(token, count, options) {
+    function formatDistance$2(token, count2, options) {
         options = options || {};
         var result;
         if (typeof formatDistanceLocale$1[token] === "string") {
             result = formatDistanceLocale$1[token];
-        } else if (count === 1) {
+        } else if (count2 === 1) {
             result = formatDistanceLocale$1[token].one;
         } else {
-            result = formatDistanceLocale$1[token].other.replace("{{count}}", count);
+            result = formatDistanceLocale$1[token].other.replace("{{count}}", count2);
         }
         if (options.addSuffix) {
             if (options.comparison > 0) {
                 return "in " + result;
             } else {
                 return result + " ago";
             }
@@ -29882,98 +32606,98 @@
     figure:last-child,
     video:last-child,
     pre:last-child,
     hr:last-child {
         margin-bottom: 0;
     }
 `;
-    var top$1 = "top";
-    var bottom$1 = "bottom";
-    var right$1 = "right";
-    var left$1 = "left";
-    var auto$1 = "auto";
-    var basePlacements$1 = [top$1, bottom$1, right$1, left$1];
-    var start$1 = "start";
-    var end$1 = "end";
-    var clippingParents$1 = "clippingParents";
-    var viewport$1 = "viewport";
-    var popper$1 = "popper";
-    var reference$1 = "reference";
-    var variationPlacements$1 = /* @__PURE__ */ basePlacements$1.reduce(function(acc, placement) {
-        return acc.concat([placement + "-" + start$1, placement + "-" + end$1]);
+    var top = "top";
+    var bottom = "bottom";
+    var right = "right";
+    var left = "left";
+    var auto = "auto";
+    var basePlacements = [top, bottom, right, left];
+    var start = "start";
+    var end = "end";
+    var clippingParents = "clippingParents";
+    var viewport = "viewport";
+    var popper = "popper";
+    var reference = "reference";
+    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
+        return acc.concat([placement + "-" + start, placement + "-" + end]);
     }, []);
-    var placements$1 = /* @__PURE__ */ [].concat(basePlacements$1, [auto$1]).reduce(function(acc, placement) {
-        return acc.concat([placement, placement + "-" + start$1, placement + "-" + end$1]);
+    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
+        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
     }, []);
-    var beforeRead$1 = "beforeRead";
-    var read$1 = "read";
-    var afterRead$1 = "afterRead";
-    var beforeMain$1 = "beforeMain";
-    var main$1 = "main";
-    var afterMain$1 = "afterMain";
-    var beforeWrite$1 = "beforeWrite";
-    var write$1 = "write";
-    var afterWrite$1 = "afterWrite";
-    var modifierPhases$1 = [beforeRead$1, read$1, afterRead$1, beforeMain$1, main$1, afterMain$1, beforeWrite$1, write$1, afterWrite$1];
+    var beforeRead = "beforeRead";
+    var read = "read";
+    var afterRead = "afterRead";
+    var beforeMain = "beforeMain";
+    var main = "main";
+    var afterMain = "afterMain";
+    var beforeWrite = "beforeWrite";
+    var write = "write";
+    var afterWrite = "afterWrite";
+    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
 
-    function getNodeName$1(element) {
+    function getNodeName(element) {
         return element ? (element.nodeName || "").toLowerCase() : null;
     }
 
-    function getWindow$1(node) {
+    function getWindow(node) {
         if (node == null) {
             return window;
         }
         if (node.toString() !== "[object Window]") {
             var ownerDocument = node.ownerDocument;
             return ownerDocument ? ownerDocument.defaultView || window : window;
         }
         return node;
     }
 
-    function isElement$3(node) {
-        var OwnElement = getWindow$1(node).Element;
+    function isElement$2(node) {
+        var OwnElement = getWindow(node).Element;
         return node instanceof OwnElement || node instanceof Element;
     }
 
-    function isHTMLElement$1(node) {
-        var OwnElement = getWindow$1(node).HTMLElement;
+    function isHTMLElement(node) {
+        var OwnElement = getWindow(node).HTMLElement;
         return node instanceof OwnElement || node instanceof HTMLElement;
     }
 
     function isShadowRoot(node) {
         if (typeof ShadowRoot === "undefined") {
             return false;
         }
-        var OwnElement = getWindow$1(node).ShadowRoot;
+        var OwnElement = getWindow(node).ShadowRoot;
         return node instanceof OwnElement || node instanceof ShadowRoot;
     }
 
-    function applyStyles$2(_ref2) {
+    function applyStyles(_ref2) {
         var state = _ref2.state;
         Object.keys(state.elements).forEach(function(name) {
             var style = state.styles[name] || {};
             var attributes = state.attributes[name] || {};
             var element = state.elements[name];
-            if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
+            if (!isHTMLElement(element) || !getNodeName(element)) {
                 return;
             }
             Object.assign(element.style, style);
             Object.keys(attributes).forEach(function(name2) {
                 var value = attributes[name2];
                 if (value === false) {
                     element.removeAttribute(name2);
                 } else {
                     element.setAttribute(name2, value === true ? "" : value);
                 }
             });
         });
     }
 
-    function effect$5(_ref2) {
+    function effect$2(_ref2) {
         var state = _ref2.state;
         var initialStyles = {
             popper: {
                 position: state.options.strategy,
                 left: "0",
                 top: "0",
                 margin: "0"
@@ -29993,34 +32717,34 @@
                 var element = state.elements[name];
                 var attributes = state.attributes[name] || {};
                 var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                 var style = styleProperties.reduce(function(style2, property2) {
                     style2[property2] = "";
                     return style2;
                 }, {});
-                if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
+                if (!isHTMLElement(element) || !getNodeName(element)) {
                     return;
                 }
                 Object.assign(element.style, style);
                 Object.keys(attributes).forEach(function(attribute) {
                     element.removeAttribute(attribute);
                 });
             });
         };
     }
-    const applyStyles$3 = {
+    const applyStyles$1 = {
         name: "applyStyles",
         enabled: true,
         phase: "write",
-        fn: applyStyles$2,
-        effect: effect$5,
+        fn: applyStyles,
+        effect: effect$2,
         requires: ["computeStyles"]
     };
 
-    function getBasePlacement$3(placement) {
+    function getBasePlacement$2(placement) {
         return placement.split("-")[0];
     }
     var max$1 = Math.max;
     var min$1 = Math.min;
     var round = Math.round;
 
     function getUAString() {
@@ -30033,29 +32757,29 @@
         return navigator.userAgent;
     }
 
     function isLayoutViewport() {
         return !/^((?!chrome|android).)*safari/i.test(getUAString());
     }
 
-    function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
+    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
         if (includeScale === void 0) {
             includeScale = false;
         }
         if (isFixedStrategy === void 0) {
             isFixedStrategy = false;
         }
         var clientRect = element.getBoundingClientRect();
         var scaleX = 1;
         var scaleY = 1;
-        if (includeScale && isHTMLElement$1(element)) {
+        if (includeScale && isHTMLElement(element)) {
             scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
             scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
         }
-        var _ref2 = isElement$3(element) ? getWindow$1(element) : window,
+        var _ref2 = isElement$2(element) ? getWindow(element) : window,
             visualViewport = _ref2.visualViewport;
         var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
         var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
         var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
         var width = clientRect.width / scaleX;
         var height = clientRect.height / scaleY;
         return {
@@ -30066,16 +32790,16 @@
             bottom: y2 + height,
             left: x2,
             x: x2,
             y: y2
         };
     }
 
-    function getLayoutRect$1(element) {
-        var clientRect = getBoundingClientRect$1(element);
+    function getLayoutRect(element) {
+        var clientRect = getBoundingClientRect(element);
         var width = element.offsetWidth;
         var height = element.offsetHeight;
         if (Math.abs(clientRect.width - width) <= 1) {
             width = clientRect.width;
         }
         if (Math.abs(clientRect.height - height) <= 1) {
             height = clientRect.height;
@@ -30084,15 +32808,15 @@
             x: element.offsetLeft,
             y: element.offsetTop,
             width,
             height
         };
     }
 
-    function contains$1(parent, child) {
+    function contains(parent, child) {
         var rootNode = child.getRootNode && child.getRootNode();
         if (parent.contains(child)) {
             return true;
         } else if (rootNode && isShadowRoot(rootNode)) {
             var next = child;
             do {
                 if (next && parent.isSameNode(next)) {
@@ -30100,179 +32824,179 @@
                 }
                 next = next.parentNode || next.host;
             } while (next);
         }
         return false;
     }
 
-    function getComputedStyle$2(element) {
-        return getWindow$1(element).getComputedStyle(element);
+    function getComputedStyle$1(element) {
+        return getWindow(element).getComputedStyle(element);
     }
 
-    function isTableElement$1(element) {
-        return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
+    function isTableElement(element) {
+        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
     }
 
-    function getDocumentElement$1(element) {
-        return ((isElement$3(element) ? element.ownerDocument : element.document) || window.document).documentElement;
+    function getDocumentElement(element) {
+        return ((isElement$2(element) ? element.ownerDocument : element.document) || window.document).documentElement;
     }
 
-    function getParentNode$1(element) {
-        if (getNodeName$1(element) === "html") {
+    function getParentNode(element) {
+        if (getNodeName(element) === "html") {
             return element;
         }
-        return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement$1(element);
+        return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
     }
 
-    function getTrueOffsetParent$1(element) {
-        if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
+    function getTrueOffsetParent(element) {
+        if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
             return null;
         }
         return element.offsetParent;
     }
 
     function getContainingBlock(element) {
         var isFirefox = /firefox/i.test(getUAString());
         var isIE2 = /Trident/i.test(getUAString());
-        if (isIE2 && isHTMLElement$1(element)) {
-            var elementCss = getComputedStyle$2(element);
+        if (isIE2 && isHTMLElement(element)) {
+            var elementCss = getComputedStyle$1(element);
             if (elementCss.position === "fixed") {
                 return null;
             }
         }
-        var currentNode = getParentNode$1(element);
+        var currentNode = getParentNode(element);
         if (isShadowRoot(currentNode)) {
             currentNode = currentNode.host;
         }
-        while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
-            var css2 = getComputedStyle$2(currentNode);
+        while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
+            var css2 = getComputedStyle$1(currentNode);
             if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
                 return currentNode;
             } else {
                 currentNode = currentNode.parentNode;
             }
         }
         return null;
     }
 
-    function getOffsetParent$1(element) {
-        var window2 = getWindow$1(element);
-        var offsetParent = getTrueOffsetParent$1(element);
-        while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
-            offsetParent = getTrueOffsetParent$1(offsetParent);
+    function getOffsetParent(element) {
+        var window2 = getWindow(element);
+        var offsetParent = getTrueOffsetParent(element);
+        while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
+            offsetParent = getTrueOffsetParent(offsetParent);
         }
-        if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
+        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
             return window2;
         }
         return offsetParent || getContainingBlock(element) || window2;
     }
 
-    function getMainAxisFromPlacement$1(placement) {
+    function getMainAxisFromPlacement(placement) {
         return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
     }
 
-    function within$1(min2, value, max2) {
+    function within(min2, value, max2) {
         return max$1(min2, min$1(value, max2));
     }
 
     function withinMaxClamp(min2, value, max2) {
-        var v2 = within$1(min2, value, max2);
+        var v2 = within(min2, value, max2);
         return v2 > max2 ? max2 : v2;
     }
 
-    function getFreshSideObject$1() {
+    function getFreshSideObject() {
         return {
             top: 0,
             right: 0,
             bottom: 0,
             left: 0
         };
     }
 
-    function mergePaddingObject$1(paddingObject) {
-        return Object.assign({}, getFreshSideObject$1(), paddingObject);
+    function mergePaddingObject(paddingObject) {
+        return Object.assign({}, getFreshSideObject(), paddingObject);
     }
 
-    function expandToHashMap$1(value, keys2) {
+    function expandToHashMap(value, keys2) {
         return keys2.reduce(function(hashMap, key) {
             hashMap[key] = value;
             return hashMap;
         }, {});
     }
     var toPaddingObject = function toPaddingObject2(padding, state) {
         padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
             placement: state.placement
         })) : padding;
-        return mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
+        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
     };
 
-    function arrow$2(_ref2) {
+    function arrow(_ref2) {
         var _state$modifiersData$;
         var state = _ref2.state,
             name = _ref2.name,
             options = _ref2.options;
         var arrowElement = state.elements.arrow;
         var popperOffsets2 = state.modifiersData.popperOffsets;
-        var basePlacement = getBasePlacement$3(state.placement);
-        var axis = getMainAxisFromPlacement$1(basePlacement);
-        var isVertical = [left$1, right$1].indexOf(basePlacement) >= 0;
+        var basePlacement = getBasePlacement$2(state.placement);
+        var axis = getMainAxisFromPlacement(basePlacement);
+        var isVertical = [left, right].indexOf(basePlacement) >= 0;
         var len = isVertical ? "height" : "width";
         if (!arrowElement || !popperOffsets2) {
             return;
         }
         var paddingObject = toPaddingObject(options.padding, state);
-        var arrowRect = getLayoutRect$1(arrowElement);
-        var minProp = axis === "y" ? top$1 : left$1;
-        var maxProp = axis === "y" ? bottom$1 : right$1;
+        var arrowRect = getLayoutRect(arrowElement);
+        var minProp = axis === "y" ? top : left;
+        var maxProp = axis === "y" ? bottom : right;
         var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
         var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
-        var arrowOffsetParent = getOffsetParent$1(arrowElement);
+        var arrowOffsetParent = getOffsetParent(arrowElement);
         var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
         var centerToReference = endDiff / 2 - startDiff / 2;
         var min2 = paddingObject[minProp];
         var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
         var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
-        var offset2 = within$1(min2, center, max2);
+        var offset2 = within(min2, center, max2);
         var axisProp = axis;
         state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
     }
 
-    function effect$4(_ref2) {
+    function effect$1(_ref2) {
         var state = _ref2.state,
             options = _ref2.options;
         var _options$element = options.element,
             arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
         if (arrowElement == null) {
             return;
         }
         if (typeof arrowElement === "string") {
             arrowElement = state.elements.popper.querySelector(arrowElement);
             if (!arrowElement) {
                 return;
             }
         }
-        if (!contains$1(state.elements.popper, arrowElement)) {
+        if (!contains(state.elements.popper, arrowElement)) {
             return;
         }
         state.elements.arrow = arrowElement;
     }
-    const arrow$3 = {
+    const arrow$1 = {
         name: "arrow",
         enabled: true,
         phase: "main",
-        fn: arrow$2,
-        effect: effect$4,
+        fn: arrow,
+        effect: effect$1,
         requires: ["popperOffsets"],
         requiresIfExists: ["preventOverflow"]
     };
 
-    function getVariation$1(placement) {
+    function getVariation(placement) {
         return placement.split("-")[1];
     }
-    var unsetSides$1 = {
+    var unsetSides = {
         top: "auto",
         right: "auto",
         bottom: "auto",
         left: "auto"
     };
 
     function roundOffsetsByDPR(_ref2, win) {
@@ -30281,213 +33005,213 @@
         var dpr = win.devicePixelRatio || 1;
         return {
             x: round(x2 * dpr) / dpr || 0,
             y: round(y2 * dpr) / dpr || 0
         };
     }
 
-    function mapToStyles$1(_ref2) {
+    function mapToStyles(_ref2) {
         var _Object$assign2;
         var popper2 = _ref2.popper,
             popperRect = _ref2.popperRect,
             placement = _ref2.placement,
             variation = _ref2.variation,
             offsets = _ref2.offsets,
             position = _ref2.position,
             gpuAcceleration = _ref2.gpuAcceleration,
             adaptive = _ref2.adaptive,
-            roundOffsets2 = _ref2.roundOffsets,
+            roundOffsets = _ref2.roundOffsets,
             isFixed = _ref2.isFixed;
         var _offsets$x = offsets.x,
             x2 = _offsets$x === void 0 ? 0 : _offsets$x,
             _offsets$y = offsets.y,
             y2 = _offsets$y === void 0 ? 0 : _offsets$y;
-        var _ref3 = typeof roundOffsets2 === "function" ? roundOffsets2({
+        var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
             x: x2,
             y: y2
         }) : {
             x: x2,
             y: y2
         };
         x2 = _ref3.x;
         y2 = _ref3.y;
         var hasX = offsets.hasOwnProperty("x");
         var hasY = offsets.hasOwnProperty("y");
-        var sideX = left$1;
-        var sideY = top$1;
+        var sideX = left;
+        var sideY = top;
         var win = window;
         if (adaptive) {
-            var offsetParent = getOffsetParent$1(popper2);
+            var offsetParent = getOffsetParent(popper2);
             var heightProp = "clientHeight";
             var widthProp = "clientWidth";
-            if (offsetParent === getWindow$1(popper2)) {
-                offsetParent = getDocumentElement$1(popper2);
-                if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
+            if (offsetParent === getWindow(popper2)) {
+                offsetParent = getDocumentElement(popper2);
+                if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
                     heightProp = "scrollHeight";
                     widthProp = "scrollWidth";
                 }
             }
             offsetParent = offsetParent;
-            if (placement === top$1 || (placement === left$1 || placement === right$1) && variation === end$1) {
-                sideY = bottom$1;
+            if (placement === top || (placement === left || placement === right) && variation === end) {
+                sideY = bottom;
                 var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
                 y2 -= offsetY - popperRect.height;
                 y2 *= gpuAcceleration ? 1 : -1;
             }
-            if (placement === left$1 || (placement === top$1 || placement === bottom$1) && variation === end$1) {
-                sideX = right$1;
+            if (placement === left || (placement === top || placement === bottom) && variation === end) {
+                sideX = right;
                 var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
                 x2 -= offsetX - popperRect.width;
                 x2 *= gpuAcceleration ? 1 : -1;
             }
         }
         var commonStyles = Object.assign({
             position
-        }, adaptive && unsetSides$1);
-        var _ref4 = roundOffsets2 === true ? roundOffsetsByDPR({
+        }, adaptive && unsetSides);
+        var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
             x: x2,
             y: y2
-        }, getWindow$1(popper2)) : {
+        }, getWindow(popper2)) : {
             x: x2,
             y: y2
         };
         x2 = _ref4.x;
         y2 = _ref4.y;
         if (gpuAcceleration) {
             var _Object$assign;
             return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
         }
         return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
     }
 
-    function computeStyles$2(_ref5) {
+    function computeStyles(_ref5) {
         var state = _ref5.state,
             options = _ref5.options;
         var _options$gpuAccelerat = options.gpuAcceleration,
             gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
             _options$adaptive = options.adaptive,
             adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
             _options$roundOffsets = options.roundOffsets,
-            roundOffsets2 = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
+            roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
         var commonStyles = {
-            placement: getBasePlacement$3(state.placement),
-            variation: getVariation$1(state.placement),
+            placement: getBasePlacement$2(state.placement),
+            variation: getVariation(state.placement),
             popper: state.elements.popper,
             popperRect: state.rects.popper,
             gpuAcceleration,
             isFixed: state.options.strategy === "fixed"
         };
         if (state.modifiersData.popperOffsets != null) {
-            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles$1(Object.assign({}, commonStyles, {
+            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                 offsets: state.modifiersData.popperOffsets,
                 position: state.options.strategy,
                 adaptive,
-                roundOffsets: roundOffsets2
+                roundOffsets
             })));
         }
         if (state.modifiersData.arrow != null) {
-            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles$1(Object.assign({}, commonStyles, {
+            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                 offsets: state.modifiersData.arrow,
                 position: "absolute",
                 adaptive: false,
-                roundOffsets: roundOffsets2
+                roundOffsets
             })));
         }
         state.attributes.popper = Object.assign({}, state.attributes.popper, {
             "data-popper-placement": state.placement
         });
     }
-    const computeStyles$3 = {
+    const computeStyles$1 = {
         name: "computeStyles",
         enabled: true,
         phase: "beforeWrite",
-        fn: computeStyles$2,
+        fn: computeStyles,
         data: {}
     };
-    var passive$1 = {
+    var passive = {
         passive: true
     };
 
-    function effect$3(_ref2) {
+    function effect(_ref2) {
         var state = _ref2.state,
             instance = _ref2.instance,
             options = _ref2.options;
         var _options$scroll = options.scroll,
             scroll = _options$scroll === void 0 ? true : _options$scroll,
             _options$resize = options.resize,
             resize = _options$resize === void 0 ? true : _options$resize;
-        var window2 = getWindow$1(state.elements.popper);
+        var window2 = getWindow(state.elements.popper);
         var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
         if (scroll) {
             scrollParents.forEach(function(scrollParent) {
-                scrollParent.addEventListener("scroll", instance.update, passive$1);
+                scrollParent.addEventListener("scroll", instance.update, passive);
             });
         }
         if (resize) {
-            window2.addEventListener("resize", instance.update, passive$1);
+            window2.addEventListener("resize", instance.update, passive);
         }
         return function() {
             if (scroll) {
                 scrollParents.forEach(function(scrollParent) {
-                    scrollParent.removeEventListener("scroll", instance.update, passive$1);
+                    scrollParent.removeEventListener("scroll", instance.update, passive);
                 });
             }
             if (resize) {
-                window2.removeEventListener("resize", instance.update, passive$1);
+                window2.removeEventListener("resize", instance.update, passive);
             }
         };
     }
-    const eventListeners$1 = {
+    const eventListeners = {
         name: "eventListeners",
         enabled: true,
         phase: "write",
         fn: function fn() {},
-        effect: effect$3,
+        effect,
         data: {}
     };
-    var hash$4 = {
+    var hash$2 = {
         left: "right",
         right: "left",
         bottom: "top",
         top: "bottom"
     };
 
-    function getOppositePlacement$1(placement) {
+    function getOppositePlacement(placement) {
         return placement.replace(/left|right|bottom|top/g, function(matched) {
-            return hash$4[matched];
+            return hash$2[matched];
         });
     }
-    var hash$3 = {
+    var hash$1 = {
         start: "end",
         end: "start"
     };
 
-    function getOppositeVariationPlacement$1(placement) {
+    function getOppositeVariationPlacement(placement) {
         return placement.replace(/start|end/g, function(matched) {
-            return hash$3[matched];
+            return hash$1[matched];
         });
     }
 
-    function getWindowScroll$1(node) {
-        var win = getWindow$1(node);
+    function getWindowScroll(node) {
+        var win = getWindow(node);
         var scrollLeft = win.pageXOffset;
         var scrollTop = win.pageYOffset;
         return {
             scrollLeft,
             scrollTop
         };
     }
 
-    function getWindowScrollBarX$1(element) {
-        return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll$1(element).scrollLeft;
+    function getWindowScrollBarX(element) {
+        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
     }
 
-    function getViewportRect$1(element, strategy) {
-        var win = getWindow$1(element);
-        var html = getDocumentElement$1(element);
+    function getViewportRect(element, strategy) {
+        var win = getWindow(element);
+        var html = getDocumentElement(element);
         var visualViewport = win.visualViewport;
         var width = html.clientWidth;
         var height = html.clientHeight;
         var x2 = 0;
         var y2 = 0;
         if (visualViewport) {
             width = visualViewport.width;
@@ -30497,278 +33221,278 @@
                 x2 = visualViewport.offsetLeft;
                 y2 = visualViewport.offsetTop;
             }
         }
         return {
             width,
             height,
-            x: x2 + getWindowScrollBarX$1(element),
+            x: x2 + getWindowScrollBarX(element),
             y: y2
         };
     }
 
-    function getDocumentRect$1(element) {
+    function getDocumentRect(element) {
         var _element$ownerDocumen;
-        var html = getDocumentElement$1(element);
-        var winScroll = getWindowScroll$1(element);
+        var html = getDocumentElement(element);
+        var winScroll = getWindowScroll(element);
         var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
         var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
         var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
-        var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
+        var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
         var y2 = -winScroll.scrollTop;
-        if (getComputedStyle$2(body || html).direction === "rtl") {
+        if (getComputedStyle$1(body || html).direction === "rtl") {
             x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
         }
         return {
             width,
             height,
             x: x2,
             y: y2
         };
     }
 
-    function isScrollParent$1(element) {
-        var _getComputedStyle = getComputedStyle$2(element),
+    function isScrollParent(element) {
+        var _getComputedStyle = getComputedStyle$1(element),
             overflow = _getComputedStyle.overflow,
             overflowX = _getComputedStyle.overflowX,
             overflowY = _getComputedStyle.overflowY;
         return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
     }
 
-    function getScrollParent$1(node) {
-        if (["html", "body", "#document"].indexOf(getNodeName$1(node)) >= 0) {
+    function getScrollParent(node) {
+        if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
             return node.ownerDocument.body;
         }
-        if (isHTMLElement$1(node) && isScrollParent$1(node)) {
+        if (isHTMLElement(node) && isScrollParent(node)) {
             return node;
         }
-        return getScrollParent$1(getParentNode$1(node));
+        return getScrollParent(getParentNode(node));
     }
 
-    function listScrollParents$1(element, list) {
+    function listScrollParents(element, list) {
         var _element$ownerDocumen;
         if (list === void 0) {
             list = [];
         }
-        var scrollParent = getScrollParent$1(element);
+        var scrollParent = getScrollParent(element);
         var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
-        var win = getWindow$1(scrollParent);
-        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
+        var win = getWindow(scrollParent);
+        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
         var updatedList = list.concat(target);
-        return isBody ? updatedList : updatedList.concat(listScrollParents$1(getParentNode$1(target)));
+        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
     }
 
-    function rectToClientRect$1(rect) {
+    function rectToClientRect(rect) {
         return Object.assign({}, rect, {
             left: rect.x,
             top: rect.y,
             right: rect.x + rect.width,
             bottom: rect.y + rect.height
         });
     }
 
     function getInnerBoundingClientRect(element, strategy) {
-        var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
+        var rect = getBoundingClientRect(element, false, strategy === "fixed");
         rect.top = rect.top + element.clientTop;
         rect.left = rect.left + element.clientLeft;
         rect.bottom = rect.top + element.clientHeight;
         rect.right = rect.left + element.clientWidth;
         rect.width = element.clientWidth;
         rect.height = element.clientHeight;
         rect.x = rect.left;
         rect.y = rect.top;
         return rect;
     }
 
-    function getClientRectFromMixedType$1(element, clippingParent, strategy) {
-        return clippingParent === viewport$1 ? rectToClientRect$1(getViewportRect$1(element, strategy)) : isElement$3(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
+    function getClientRectFromMixedType(element, clippingParent, strategy) {
+        return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
     }
 
-    function getClippingParents$1(element) {
-        var clippingParents2 = listScrollParents$1(getParentNode$1(element));
-        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
-        var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
-        if (!isElement$3(clipperElement)) {
+    function getClippingParents(element) {
+        var clippingParents2 = listScrollParents(getParentNode(element));
+        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
+        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
+        if (!isElement$2(clipperElement)) {
             return [];
         }
         return clippingParents2.filter(function(clippingParent) {
-            return isElement$3(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
+            return isElement$2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
         });
     }
 
-    function getClippingRect$1(element, boundary, rootBoundary, strategy) {
-        var mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element) : [].concat(boundary);
+    function getClippingRect(element, boundary, rootBoundary, strategy) {
+        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
         var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
         var firstClippingParent = clippingParents2[0];
         var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
-            var rect = getClientRectFromMixedType$1(element, clippingParent, strategy);
+            var rect = getClientRectFromMixedType(element, clippingParent, strategy);
             accRect.top = max$1(rect.top, accRect.top);
             accRect.right = min$1(rect.right, accRect.right);
             accRect.bottom = min$1(rect.bottom, accRect.bottom);
             accRect.left = max$1(rect.left, accRect.left);
             return accRect;
-        }, getClientRectFromMixedType$1(element, firstClippingParent, strategy));
+        }, getClientRectFromMixedType(element, firstClippingParent, strategy));
         clippingRect.width = clippingRect.right - clippingRect.left;
         clippingRect.height = clippingRect.bottom - clippingRect.top;
         clippingRect.x = clippingRect.left;
         clippingRect.y = clippingRect.top;
         return clippingRect;
     }
 
-    function computeOffsets$1(_ref2) {
+    function computeOffsets(_ref2) {
         var reference2 = _ref2.reference,
             element = _ref2.element,
             placement = _ref2.placement;
-        var basePlacement = placement ? getBasePlacement$3(placement) : null;
-        var variation = placement ? getVariation$1(placement) : null;
+        var basePlacement = placement ? getBasePlacement$2(placement) : null;
+        var variation = placement ? getVariation(placement) : null;
         var commonX = reference2.x + reference2.width / 2 - element.width / 2;
         var commonY = reference2.y + reference2.height / 2 - element.height / 2;
         var offsets;
         switch (basePlacement) {
-            case top$1:
+            case top:
                 offsets = {
                     x: commonX,
                     y: reference2.y - element.height
                 };
                 break;
-            case bottom$1:
+            case bottom:
                 offsets = {
                     x: commonX,
                     y: reference2.y + reference2.height
                 };
                 break;
-            case right$1:
+            case right:
                 offsets = {
                     x: reference2.x + reference2.width,
                     y: commonY
                 };
                 break;
-            case left$1:
+            case left:
                 offsets = {
                     x: reference2.x - element.width,
                     y: commonY
                 };
                 break;
             default:
                 offsets = {
                     x: reference2.x,
                     y: reference2.y
                 };
         }
-        var mainAxis = basePlacement ? getMainAxisFromPlacement$1(basePlacement) : null;
+        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
         if (mainAxis != null) {
             var len = mainAxis === "y" ? "height" : "width";
             switch (variation) {
-                case start$1:
+                case start:
                     offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                     break;
-                case end$1:
+                case end:
                     offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                     break;
             }
         }
         return offsets;
     }
 
-    function detectOverflow$1(state, options) {
+    function detectOverflow(state, options) {
         if (options === void 0) {
             options = {};
         }
         var _options = options,
             _options$placement = _options.placement,
             placement = _options$placement === void 0 ? state.placement : _options$placement,
             _options$strategy = _options.strategy,
             strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
             _options$boundary = _options.boundary,
-            boundary = _options$boundary === void 0 ? clippingParents$1 : _options$boundary,
+            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
             _options$rootBoundary = _options.rootBoundary,
-            rootBoundary = _options$rootBoundary === void 0 ? viewport$1 : _options$rootBoundary,
+            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
             _options$elementConte = _options.elementContext,
-            elementContext = _options$elementConte === void 0 ? popper$1 : _options$elementConte,
+            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
             _options$altBoundary = _options.altBoundary,
             altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
             _options$padding = _options.padding,
             padding = _options$padding === void 0 ? 0 : _options$padding;
-        var paddingObject = mergePaddingObject$1(typeof padding !== "number" ? padding : expandToHashMap$1(padding, basePlacements$1));
-        var altContext = elementContext === popper$1 ? reference$1 : popper$1;
+        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
+        var altContext = elementContext === popper ? reference : popper;
         var popperRect = state.rects.popper;
         var element = state.elements[altBoundary ? altContext : elementContext];
-        var clippingClientRect = getClippingRect$1(isElement$3(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
-        var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
-        var popperOffsets2 = computeOffsets$1({
+        var clippingClientRect = getClippingRect(isElement$2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
+        var referenceClientRect = getBoundingClientRect(state.elements.reference);
+        var popperOffsets2 = computeOffsets({
             reference: referenceClientRect,
             element: popperRect,
             strategy: "absolute",
             placement
         });
-        var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
-        var elementClientRect = elementContext === popper$1 ? popperClientRect : referenceClientRect;
+        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
+        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
         var overflowOffsets = {
             top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
             bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
             left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
             right: elementClientRect.right - clippingClientRect.right + paddingObject.right
         };
         var offsetData = state.modifiersData.offset;
-        if (elementContext === popper$1 && offsetData) {
+        if (elementContext === popper && offsetData) {
             var offset2 = offsetData[placement];
             Object.keys(overflowOffsets).forEach(function(key) {
-                var multiply = [right$1, bottom$1].indexOf(key) >= 0 ? 1 : -1;
-                var axis = [top$1, bottom$1].indexOf(key) >= 0 ? "y" : "x";
+                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
+                var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
                 overflowOffsets[key] += offset2[axis] * multiply;
             });
         }
         return overflowOffsets;
     }
 
-    function computeAutoPlacement$1(state, options) {
+    function computeAutoPlacement(state, options) {
         if (options === void 0) {
             options = {};
         }
         var _options = options,
             placement = _options.placement,
             boundary = _options.boundary,
             rootBoundary = _options.rootBoundary,
             padding = _options.padding,
             flipVariations = _options.flipVariations,
             _options$allowedAutoP = _options.allowedAutoPlacements,
-            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
-        var variation = getVariation$1(placement);
-        var placements2 = variation ? flipVariations ? variationPlacements$1 : variationPlacements$1.filter(function(placement2) {
-            return getVariation$1(placement2) === variation;
-        }) : basePlacements$1;
-        var allowedPlacements = placements2.filter(function(placement2) {
+            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
+        var variation = getVariation(placement);
+        var placements$12 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
+            return getVariation(placement2) === variation;
+        }) : basePlacements;
+        var allowedPlacements = placements$12.filter(function(placement2) {
             return allowedAutoPlacements.indexOf(placement2) >= 0;
         });
         if (allowedPlacements.length === 0) {
-            allowedPlacements = placements2;
+            allowedPlacements = placements$12;
         }
         var overflows = allowedPlacements.reduce(function(acc, placement2) {
-            acc[placement2] = detectOverflow$1(state, {
+            acc[placement2] = detectOverflow(state, {
                 placement: placement2,
                 boundary,
                 rootBoundary,
                 padding
-            })[getBasePlacement$3(placement2)];
+            })[getBasePlacement$2(placement2)];
             return acc;
         }, {});
         return Object.keys(overflows).sort(function(a2, b2) {
             return overflows[a2] - overflows[b2];
         });
     }
 
-    function getExpandedFallbackPlacements$1(placement) {
-        if (getBasePlacement$3(placement) === auto$1) {
+    function getExpandedFallbackPlacements(placement) {
+        if (getBasePlacement$2(placement) === auto) {
             return [];
         }
-        var oppositePlacement = getOppositePlacement$1(placement);
-        return [getOppositeVariationPlacement$1(placement), oppositePlacement, getOppositeVariationPlacement$1(oppositePlacement)];
+        var oppositePlacement = getOppositePlacement(placement);
+        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
     }
 
-    function flip$2(_ref2) {
+    function flip(_ref2) {
         var state = _ref2.state,
             options = _ref2.options,
             name = _ref2.name;
         if (state.modifiersData[name]._skip) {
             return;
         }
         var _options$mainAxis = options.mainAxis,
@@ -30780,19 +33504,19 @@
             boundary = options.boundary,
             rootBoundary = options.rootBoundary,
             altBoundary = options.altBoundary,
             _options$flipVariatio = options.flipVariations,
             flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
             allowedAutoPlacements = options.allowedAutoPlacements;
         var preferredPlacement = state.options.placement;
-        var basePlacement = getBasePlacement$3(preferredPlacement);
+        var basePlacement = getBasePlacement$2(preferredPlacement);
         var isBasePlacement = basePlacement === preferredPlacement;
-        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements$1(preferredPlacement));
+        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
         var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
-            return acc.concat(getBasePlacement$3(placement2) === auto$1 ? computeAutoPlacement$1(state, {
+            return acc.concat(getBasePlacement$2(placement2) === auto ? computeAutoPlacement(state, {
                 placement: placement2,
                 boundary,
                 rootBoundary,
                 padding,
                 flipVariations,
                 allowedAutoPlacements
             }) : placement2);
@@ -30800,30 +33524,30 @@
         var referenceRect = state.rects.reference;
         var popperRect = state.rects.popper;
         var checksMap = /* @__PURE__ */ new Map();
         var makeFallbackChecks = true;
         var firstFittingPlacement = placements2[0];
         for (var i2 = 0; i2 < placements2.length; i2++) {
             var placement = placements2[i2];
-            var _basePlacement = getBasePlacement$3(placement);
-            var isStartVariation = getVariation$1(placement) === start$1;
-            var isVertical = [top$1, bottom$1].indexOf(_basePlacement) >= 0;
+            var _basePlacement = getBasePlacement$2(placement);
+            var isStartVariation = getVariation(placement) === start;
+            var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
             var len = isVertical ? "width" : "height";
-            var overflow = detectOverflow$1(state, {
+            var overflow = detectOverflow(state, {
                 placement,
                 boundary,
                 rootBoundary,
                 altBoundary,
                 padding
             });
-            var mainVariationSide = isVertical ? isStartVariation ? right$1 : left$1 : isStartVariation ? bottom$1 : top$1;
+            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
             if (referenceRect[len] > popperRect[len]) {
-                mainVariationSide = getOppositePlacement$1(mainVariationSide);
+                mainVariationSide = getOppositePlacement(mainVariationSide);
             }
-            var altVariationSide = getOppositePlacement$1(mainVariationSide);
+            var altVariationSide = getOppositePlacement(mainVariationSide);
             var checks = [];
             if (checkMainAxis) {
                 checks.push(overflow[_basePlacement] <= 0);
             }
             if (checkAltAxis) {
                 checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
             }
@@ -30860,150 +33584,150 @@
         }
         if (state.placement !== firstFittingPlacement) {
             state.modifiersData[name]._skip = true;
             state.placement = firstFittingPlacement;
             state.reset = true;
         }
     }
-    const flip$3 = {
+    const flip$1 = {
         name: "flip",
         enabled: true,
         phase: "main",
-        fn: flip$2,
+        fn: flip,
         requiresIfExists: ["offset"],
         data: {
             _skip: false
         }
     };
 
-    function getSideOffsets$1(overflow, rect, preventedOffsets) {
+    function getSideOffsets(overflow, rect, preventedOffsets) {
         if (preventedOffsets === void 0) {
             preventedOffsets = {
                 x: 0,
                 y: 0
             };
         }
         return {
             top: overflow.top - rect.height - preventedOffsets.y,
             right: overflow.right - rect.width + preventedOffsets.x,
             bottom: overflow.bottom - rect.height + preventedOffsets.y,
             left: overflow.left - rect.width - preventedOffsets.x
         };
     }
 
-    function isAnySideFullyClipped$1(overflow) {
-        return [top$1, right$1, bottom$1, left$1].some(function(side) {
+    function isAnySideFullyClipped(overflow) {
+        return [top, right, bottom, left].some(function(side) {
             return overflow[side] >= 0;
         });
     }
 
-    function hide$2(_ref2) {
+    function hide(_ref2) {
         var state = _ref2.state,
             name = _ref2.name;
         var referenceRect = state.rects.reference;
         var popperRect = state.rects.popper;
         var preventedOffsets = state.modifiersData.preventOverflow;
-        var referenceOverflow = detectOverflow$1(state, {
+        var referenceOverflow = detectOverflow(state, {
             elementContext: "reference"
         });
-        var popperAltOverflow = detectOverflow$1(state, {
+        var popperAltOverflow = detectOverflow(state, {
             altBoundary: true
         });
-        var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
-        var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
-        var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
-        var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
+        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
+        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
+        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
+        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
         state.modifiersData[name] = {
             referenceClippingOffsets,
             popperEscapeOffsets,
             isReferenceHidden,
             hasPopperEscaped
         };
         state.attributes.popper = Object.assign({}, state.attributes.popper, {
             "data-popper-reference-hidden": isReferenceHidden,
             "data-popper-escaped": hasPopperEscaped
         });
     }
-    const hide$3 = {
+    const hide$1 = {
         name: "hide",
         enabled: true,
         phase: "main",
         requiresIfExists: ["preventOverflow"],
-        fn: hide$2
+        fn: hide
     };
 
-    function distanceAndSkiddingToXY$1(placement, rects, offset2) {
-        var basePlacement = getBasePlacement$3(placement);
-        var invertDistance = [left$1, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
+    function distanceAndSkiddingToXY(placement, rects, offset2) {
+        var basePlacement = getBasePlacement$2(placement);
+        var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
         var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
                 placement
             })) : offset2,
             skidding = _ref2[0],
             distance = _ref2[1];
         skidding = skidding || 0;
         distance = (distance || 0) * invertDistance;
-        return [left$1, right$1].indexOf(basePlacement) >= 0 ? {
+        return [left, right].indexOf(basePlacement) >= 0 ? {
             x: distance,
             y: skidding
         } : {
             x: skidding,
             y: distance
         };
     }
 
-    function offset$2(_ref2) {
+    function offset(_ref2) {
         var state = _ref2.state,
             options = _ref2.options,
             name = _ref2.name;
         var _options$offset = options.offset,
             offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
-        var data = placements$1.reduce(function(acc, placement) {
-            acc[placement] = distanceAndSkiddingToXY$1(placement, state.rects, offset2);
+        var data = placements.reduce(function(acc, placement) {
+            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
             return acc;
         }, {});
         var _data$state$placement = data[state.placement],
             x2 = _data$state$placement.x,
             y2 = _data$state$placement.y;
         if (state.modifiersData.popperOffsets != null) {
             state.modifiersData.popperOffsets.x += x2;
             state.modifiersData.popperOffsets.y += y2;
         }
         state.modifiersData[name] = data;
     }
-    const offset$3 = {
+    const offset$1 = {
         name: "offset",
         enabled: true,
         phase: "main",
         requires: ["popperOffsets"],
-        fn: offset$2
+        fn: offset
     };
 
-    function popperOffsets$2(_ref2) {
+    function popperOffsets(_ref2) {
         var state = _ref2.state,
             name = _ref2.name;
-        state.modifiersData[name] = computeOffsets$1({
+        state.modifiersData[name] = computeOffsets({
             reference: state.rects.reference,
             element: state.rects.popper,
             strategy: "absolute",
             placement: state.placement
         });
     }
-    const popperOffsets$3 = {
+    const popperOffsets$1 = {
         name: "popperOffsets",
         enabled: true,
         phase: "read",
-        fn: popperOffsets$2,
+        fn: popperOffsets,
         data: {}
     };
 
-    function getAltAxis$1(axis) {
+    function getAltAxis(axis) {
         return axis === "x" ? "y" : "x";
     }
 
-    function preventOverflow$2(_ref2) {
+    function preventOverflow(_ref2) {
         var state = _ref2.state,
             options = _ref2.options,
             name = _ref2.name;
         var _options$mainAxis = options.mainAxis,
             checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
             _options$altAxis = options.altAxis,
             checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
@@ -31011,25 +33735,25 @@
             rootBoundary = options.rootBoundary,
             altBoundary = options.altBoundary,
             padding = options.padding,
             _options$tether = options.tether,
             tether = _options$tether === void 0 ? true : _options$tether,
             _options$tetherOffset = options.tetherOffset,
             tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
-        var overflow = detectOverflow$1(state, {
+        var overflow = detectOverflow(state, {
             boundary,
             rootBoundary,
             padding,
             altBoundary
         });
-        var basePlacement = getBasePlacement$3(state.placement);
-        var variation = getVariation$1(state.placement);
+        var basePlacement = getBasePlacement$2(state.placement);
+        var variation = getVariation(state.placement);
         var isBasePlacement = !variation;
-        var mainAxis = getMainAxisFromPlacement$1(basePlacement);
-        var altAxis = getAltAxis$1(mainAxis);
+        var mainAxis = getMainAxisFromPlacement(basePlacement);
+        var altAxis = getAltAxis(mainAxis);
         var popperOffsets2 = state.modifiersData.popperOffsets;
         var referenceRect = state.rects.reference;
         var popperRect = state.rects.popper;
         var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
             placement: state.placement
         })) : tetherOffset;
         var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
@@ -31045,128 +33769,128 @@
             y: 0
         };
         if (!popperOffsets2) {
             return;
         }
         if (checkMainAxis) {
             var _offsetModifierState$;
-            var mainSide = mainAxis === "y" ? top$1 : left$1;
-            var altSide = mainAxis === "y" ? bottom$1 : right$1;
+            var mainSide = mainAxis === "y" ? top : left;
+            var altSide = mainAxis === "y" ? bottom : right;
             var len = mainAxis === "y" ? "height" : "width";
             var offset2 = popperOffsets2[mainAxis];
             var min2 = offset2 + overflow[mainSide];
             var max2 = offset2 - overflow[altSide];
             var additive = tether ? -popperRect[len] / 2 : 0;
-            var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
-            var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
+            var minLen = variation === start ? referenceRect[len] : popperRect[len];
+            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
             var arrowElement = state.elements.arrow;
-            var arrowRect = tether && arrowElement ? getLayoutRect$1(arrowElement) : {
+            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                 width: 0,
                 height: 0
             };
-            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject$1();
+            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
             var arrowPaddingMin = arrowPaddingObject[mainSide];
             var arrowPaddingMax = arrowPaddingObject[altSide];
-            var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
+            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
             var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
             var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
-            var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
+            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
             var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
             var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
             var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
             var tetherMax = offset2 + maxOffset - offsetModifierValue;
-            var preventedOffset = within$1(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
+            var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
             popperOffsets2[mainAxis] = preventedOffset;
             data[mainAxis] = preventedOffset - offset2;
         }
         if (checkAltAxis) {
             var _offsetModifierState$2;
-            var _mainSide = mainAxis === "x" ? top$1 : left$1;
-            var _altSide = mainAxis === "x" ? bottom$1 : right$1;
+            var _mainSide = mainAxis === "x" ? top : left;
+            var _altSide = mainAxis === "x" ? bottom : right;
             var _offset = popperOffsets2[altAxis];
             var _len = altAxis === "y" ? "height" : "width";
             var _min = _offset + overflow[_mainSide];
             var _max = _offset - overflow[_altSide];
-            var isOriginSide = [top$1, left$1].indexOf(basePlacement) !== -1;
+            var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
             var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
             var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
             var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
-            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
+            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
             popperOffsets2[altAxis] = _preventedOffset;
             data[altAxis] = _preventedOffset - _offset;
         }
         state.modifiersData[name] = data;
     }
-    const preventOverflow$3 = {
+    const preventOverflow$1 = {
         name: "preventOverflow",
         enabled: true,
         phase: "main",
-        fn: preventOverflow$2,
+        fn: preventOverflow,
         requiresIfExists: ["offset"]
     };
 
-    function getHTMLElementScroll$1(element) {
+    function getHTMLElementScroll(element) {
         return {
             scrollLeft: element.scrollLeft,
             scrollTop: element.scrollTop
         };
     }
 
-    function getNodeScroll$1(node) {
-        if (node === getWindow$1(node) || !isHTMLElement$1(node)) {
-            return getWindowScroll$1(node);
+    function getNodeScroll(node) {
+        if (node === getWindow(node) || !isHTMLElement(node)) {
+            return getWindowScroll(node);
         } else {
-            return getHTMLElementScroll$1(node);
+            return getHTMLElementScroll(node);
         }
     }
 
     function isElementScaled(element) {
         var rect = element.getBoundingClientRect();
         var scaleX = round(rect.width) / element.offsetWidth || 1;
         var scaleY = round(rect.height) / element.offsetHeight || 1;
         return scaleX !== 1 || scaleY !== 1;
     }
 
-    function getCompositeRect$1(elementOrVirtualElement, offsetParent, isFixed) {
+    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
         if (isFixed === void 0) {
             isFixed = false;
         }
-        var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
-        var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
-        var documentElement = getDocumentElement$1(offsetParent);
-        var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
+        var isOffsetParentAnElement = isHTMLElement(offsetParent);
+        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
+        var documentElement = getDocumentElement(offsetParent);
+        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
         var scroll = {
             scrollLeft: 0,
             scrollTop: 0
         };
         var offsets = {
             x: 0,
             y: 0
         };
         if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
-            if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
-                scroll = getNodeScroll$1(offsetParent);
+            if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
+                scroll = getNodeScroll(offsetParent);
             }
-            if (isHTMLElement$1(offsetParent)) {
-                offsets = getBoundingClientRect$1(offsetParent, true);
+            if (isHTMLElement(offsetParent)) {
+                offsets = getBoundingClientRect(offsetParent, true);
                 offsets.x += offsetParent.clientLeft;
                 offsets.y += offsetParent.clientTop;
             } else if (documentElement) {
-                offsets.x = getWindowScrollBarX$1(documentElement);
+                offsets.x = getWindowScrollBarX(documentElement);
             }
         }
         return {
             x: rect.left + scroll.scrollLeft - offsets.x,
             y: rect.top + scroll.scrollTop - offsets.y,
             width: rect.width,
             height: rect.height
         };
     }
 
-    function order$1(modifiers) {
+    function order(modifiers) {
         var map2 = /* @__PURE__ */ new Map();
         var visited = /* @__PURE__ */ new Set();
         var result = [];
         modifiers.forEach(function(modifier) {
             map2.set(modifier.name, modifier);
         });
 
@@ -31187,83 +33911,83 @@
             if (!visited.has(modifier.name)) {
                 sort(modifier);
             }
         });
         return result;
     }
 
-    function orderModifiers$1(modifiers) {
-        var orderedModifiers = order$1(modifiers);
-        return modifierPhases$1.reduce(function(acc, phase) {
+    function orderModifiers(modifiers) {
+        var orderedModifiers = order(modifiers);
+        return modifierPhases.reduce(function(acc, phase) {
             return acc.concat(orderedModifiers.filter(function(modifier) {
                 return modifier.phase === phase;
             }));
         }, []);
     }
 
-    function debounce$4(fn) {
+    function debounce$3(fn) {
         var pending;
         return function() {
             if (!pending) {
                 pending = new Promise(function(resolve) {
                     Promise.resolve().then(function() {
                         pending = void 0;
                         resolve(fn());
                     });
                 });
             }
             return pending;
         };
     }
 
-    function mergeByName$1(modifiers) {
+    function mergeByName(modifiers) {
         var merged = modifiers.reduce(function(merged2, current) {
             var existing = merged2[current.name];
             merged2[current.name] = existing ? Object.assign({}, existing, current, {
                 options: Object.assign({}, existing.options, current.options),
                 data: Object.assign({}, existing.data, current.data)
             }) : current;
             return merged2;
         }, {});
         return Object.keys(merged).map(function(key) {
             return merged[key];
         });
     }
-    var DEFAULT_OPTIONS$1 = {
+    var DEFAULT_OPTIONS = {
         placement: "bottom",
         modifiers: [],
         strategy: "absolute"
     };
 
-    function areValidElements$1() {
+    function areValidElements() {
         for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
             args[_key] = arguments[_key];
         }
         return !args.some(function(element) {
             return !(element && typeof element.getBoundingClientRect === "function");
         });
     }
 
-    function popperGenerator$1(generatorOptions) {
+    function popperGenerator(generatorOptions) {
         if (generatorOptions === void 0) {
             generatorOptions = {};
         }
         var _generatorOptions = generatorOptions,
             _generatorOptions$def = _generatorOptions.defaultModifiers,
             defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
             _generatorOptions$def2 = _generatorOptions.defaultOptions,
-            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
+            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
         return function createPopper2(reference2, popper2, options) {
             if (options === void 0) {
                 options = defaultOptions2;
             }
             var state = {
                 placement: "bottom",
                 orderedModifiers: [],
-                options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions2),
+                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
                 modifiersData: {},
                 elements: {
                     reference: reference2,
                     popper: popper2
                 },
                 attributes: {},
                 styles: {}
@@ -31273,37 +33997,37 @@
             var instance = {
                 state,
                 setOptions: function setOptions(setOptionsAction) {
                     var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                     cleanupModifierEffects();
                     state.options = Object.assign({}, defaultOptions2, state.options, options2);
                     state.scrollParents = {
-                        reference: isElement$3(reference2) ? listScrollParents$1(reference2) : reference2.contextElement ? listScrollParents$1(reference2.contextElement) : [],
-                        popper: listScrollParents$1(popper2)
+                        reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
+                        popper: listScrollParents(popper2)
                     };
-                    var orderedModifiers = orderModifiers$1(mergeByName$1([].concat(defaultModifiers2, state.options.modifiers)));
+                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                     state.orderedModifiers = orderedModifiers.filter(function(m2) {
                         return m2.enabled;
                     });
                     runModifierEffects();
                     return instance.update();
                 },
                 forceUpdate: function forceUpdate() {
                     if (isDestroyed) {
                         return;
                     }
                     var _state$elements = state.elements,
                         reference3 = _state$elements.reference,
                         popper3 = _state$elements.popper;
-                    if (!areValidElements$1(reference3, popper3)) {
+                    if (!areValidElements(reference3, popper3)) {
                         return;
                     }
                     state.rects = {
-                        reference: getCompositeRect$1(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
-                        popper: getLayoutRect$1(popper3)
+                        reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
+                        popper: getLayoutRect(popper3)
                     };
                     state.reset = false;
                     state.placement = state.options.placement;
                     state.orderedModifiers.forEach(function(modifier) {
                         return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                     });
                     for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
@@ -31323,26 +34047,26 @@
                                 options: _options,
                                 name,
                                 instance
                             }) || state;
                         }
                     }
                 },
-                update: debounce$4(function() {
+                update: debounce$3(function() {
                     return new Promise(function(resolve) {
                         instance.forceUpdate();
                         resolve(state);
                     });
                 }),
                 destroy: function destroy() {
                     cleanupModifierEffects();
                     isDestroyed = true;
                 }
             };
-            if (!areValidElements$1(reference2, popper2)) {
+            if (!areValidElements(reference2, popper2)) {
                 return instance;
             }
             instance.setOptions(options).then(function(state2) {
                 if (!isDestroyed && options.onFirstUpdate) {
                     options.onFirstUpdate(state2);
                 }
             });
@@ -31371,17 +34095,17 @@
                     return fn();
                 });
                 effectCleanupFns = [];
             }
             return instance;
         };
     }
-    var defaultModifiers$1 = [eventListeners$1, popperOffsets$3, computeStyles$3, applyStyles$3, offset$3, flip$3, preventOverflow$3, arrow$3, hide$3];
-    var createPopper$1 = /* @__PURE__ */ popperGenerator$1({
-        defaultModifiers: defaultModifiers$1
+    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
+    var createPopper = /* @__PURE__ */ popperGenerator({
+        defaultModifiers
     });
     var CONTENT_CLASS$1 = "tippy-content";
     var BACKDROP_CLASS$1 = "tippy-backdrop";
     var ARROW_CLASS$1 = "tippy-arrow";
     var SVG_ARROW_CLASS$1 = "tippy-svg-arrow";
     var TOUCH_OPTIONS$1 = {
         passive: true,
@@ -31401,15 +34125,15 @@
         return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
     }
 
     function invokeWithArgsOrReturn$1(value, args) {
         return typeof value === "function" ? value.apply(void 0, args) : value;
     }
 
-    function debounce$3(fn, ms) {
+    function debounce$2(fn, ms) {
         if (ms === 0) {
             return fn;
         }
         var timeout;
         return function(arg) {
             clearTimeout(timeout);
             timeout = setTimeout(function() {
@@ -31434,15 +34158,15 @@
 
     function unique$1(arr) {
         return arr.filter(function(item, index2) {
             return arr.indexOf(item) === index2;
         });
     }
 
-    function getBasePlacement$2(placement) {
+    function getBasePlacement$1(placement) {
         return placement.split("-")[0];
     }
 
     function arrayFrom$1(value) {
         return [].slice.call(value);
     }
 
@@ -31455,15 +34179,15 @@
         }, {});
     }
 
     function div$1() {
         return document.createElement("div");
     }
 
-    function isElement$2(value) {
+    function isElement$1(value) {
         return ["Element", "Fragment"].some(function(type) {
             return isType$1(value, type);
         });
     }
 
     function isNodeList$1(value) {
         return isType$1(value, "NodeList");
@@ -31474,15 +34198,15 @@
     }
 
     function isReferenceElement$1(value) {
         return !!(value && value._tippy && value._tippy.reference === value);
     }
 
     function getArrayOfElements$1(value) {
-        if (isElement$2(value)) {
+        if (isElement$1(value)) {
             return [value];
         }
         if (isNodeList$1(value)) {
             return arrayFrom$1(value);
         }
         if (Array.isArray(value)) {
             return value;
@@ -31516,15 +34240,15 @@
         var clientX = event.clientX,
             clientY = event.clientY;
         return popperTreeData.every(function(_ref2) {
             var popperRect = _ref2.popperRect,
                 popperState = _ref2.popperState,
                 props = _ref2.props;
             var interactiveBorder = props.interactiveBorder;
-            var basePlacement = getBasePlacement$2(popperState.placement);
+            var basePlacement = getBasePlacement$1(popperState.placement);
             var offsetData = popperState.modifiersData.offset;
             if (!offsetData) {
                 return true;
             }
             var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
             var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
             var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
@@ -31725,15 +34449,15 @@
         var didHideDueToDocumentMouseDown = false;
         var didTouchMove = false;
         var ignoreOnFirstUpdate = false;
         var lastTriggerEvent;
         var currentTransitionEndListener;
         var onFirstUpdate;
         var listeners = [];
-        var debouncedOnMouseMove = debounce$3(onMouseMove, props.interactiveDebounce);
+        var debouncedOnMouseMove = debounce$2(onMouseMove, props.interactiveDebounce);
         var currentTarget;
         var doc = getOwnerDocument$1(props.triggerTarget || reference2);
         var id = idCounter$2++;
         var popperInstance = null;
         var plugins2 = unique$1(props.plugins);
         var state = {
             isEnabled: true,
@@ -32176,15 +34900,15 @@
                     options: {
                         element: arrow2,
                         padding: 3
                     }
                 });
             }
             modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
-            instance.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
+            instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
                 placement,
                 onFirstUpdate,
                 modifiers
             }));
         }
 
         function destroyPopperInstance() {
@@ -32284,15 +35008,15 @@
             var nextProps = evaluateProps$1(reference2, Object.assign({}, instance.props, {}, partialProps, {
                 ignoreAttributes: true
             }));
             instance.props = nextProps;
             addListeners();
             if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
                 cleanupInteractiveMouseListeners();
-                debouncedOnMouseMove = debounce$3(onMouseMove, nextProps.interactiveDebounce);
+                debouncedOnMouseMove = debounce$2(onMouseMove, nextProps.interactiveDebounce);
             }
             if (prevProps.triggerTarget && !nextProps.triggerTarget) {
                 normalizeToArray$1(prevProps.triggerTarget).forEach(function(node) {
                     node.removeAttribute("aria-expanded");
                 });
             } else if (nextProps.triggerTarget) {
                 reference2.removeAttribute("aria-expanded");
@@ -32472,15 +35196,15 @@
         var instances = elements.reduce(function(acc, reference2) {
             var instance = reference2 && createTippy$1(reference2, passedProps);
             if (instance) {
                 acc.push(instance);
             }
             return acc;
         }, []);
-        return isElement$2(targets) ? instances[0] : instances;
+        return isElement$1(targets) ? instances[0] : instances;
     }
     tippy$1.defaultProps = defaultProps$4;
     tippy$1.setDefaultProps = setDefaultProps$1;
     tippy$1.currentInput = currentInput$1;
     tippy$1.setDefaultProps({
         animation: false
     });
@@ -32535,15 +35259,15 @@
             popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
                 modifiers: [].concat((((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || []).filter(function(modifier) {
                     return modifier.name.indexOf("tippy") >= 0;
                 }), ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || [])
             })
         });
     }
-    var useIsomorphicLayoutEffect$3 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
+    var useIsomorphicLayoutEffect$2 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
 
     function useMutableBox(initialValue) {
         var ref = React.useRef();
         if (!ref.current) {
             ref.current = typeof initialValue === "function" ? initialValue() : initialValue;
         }
         return ref.current;
@@ -32652,15 +35376,15 @@
                         return {
                             popper: mutableBox.container
                         };
                     }
                 });
             }
             var deps = [reference2].concat(children ? [children.type] : []);
-            useIsomorphicLayoutEffect$3(function() {
+            useIsomorphicLayoutEffect$2(function() {
                 var element = reference2;
                 if (reference2 && reference2.hasOwnProperty("current")) {
                     element = reference2.current;
                 }
                 var instance = tippy2(element || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
                     plugins: [classNamePlugin].concat(props.plugins || [])
                 }));
@@ -32680,15 +35404,15 @@
                 }
                 setMounted(true);
                 return function() {
                     instance.destroy();
                     singleton == null ? void 0 : singleton.cleanup(instance);
                 };
             }, deps);
-            useIsomorphicLayoutEffect$3(function() {
+            useIsomorphicLayoutEffect$2(function() {
                 if (mutableBox.renders === 1) {
                     mutableBox.renders++;
                     return;
                 }
                 var instance = mutableBox.instance;
                 instance.setProps(deepPreserveProps(instance.props, computedProps));
                 if (disabled2) {
@@ -32707,15 +35431,15 @@
                     singleton.hook({
                         instance,
                         content,
                         props: computedProps
                     });
                 }
             });
-            useIsomorphicLayoutEffect$3(function() {
+            useIsomorphicLayoutEffect$2(function() {
                 var _instance$props$poppe;
                 if (!render2) {
                     return;
                 }
                 var instance = mutableBox.instance;
                 instance.setProps({
                     popperOptions: Object.assign({}, instance.props.popperOptions, {
@@ -32791,15 +35515,15 @@
         return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
     }
 
     function invokeWithArgsOrReturn(value, args) {
         return typeof value === "function" ? value.apply(void 0, args) : value;
     }
 
-    function debounce$2(fn, ms) {
+    function debounce$1(fn, ms) {
         if (ms === 0) {
             return fn;
         }
         var timeout;
         return function(arg) {
             clearTimeout(timeout);
             timeout = setTimeout(function() {
@@ -32824,15 +35548,15 @@
 
     function unique(arr) {
         return arr.filter(function(item, index2) {
             return arr.indexOf(item) === index2;
         });
     }
 
-    function getBasePlacement$1(placement) {
+    function getBasePlacement(placement) {
         return placement.split("-")[0];
     }
 
     function arrayFrom(value) {
         return [].slice.call(value);
     }
 
@@ -32845,15 +35569,15 @@
         }, {});
     }
 
     function div() {
         return document.createElement("div");
     }
 
-    function isElement$1(value) {
+    function isElement(value) {
         return ["Element", "Fragment"].some(function(type) {
             return isType(value, type);
         });
     }
 
     function isNodeList(value) {
         return isType(value, "NodeList");
@@ -32864,15 +35588,15 @@
     }
 
     function isReferenceElement(value) {
         return !!(value && value._tippy && value._tippy.reference === value);
     }
 
     function getArrayOfElements(value) {
-        if (isElement$1(value)) {
+        if (isElement(value)) {
             return [value];
         }
         if (isNodeList(value)) {
             return arrayFrom(value);
         }
         if (Array.isArray(value)) {
             return value;
@@ -32906,15 +35630,15 @@
         var clientX = event.clientX,
             clientY = event.clientY;
         return popperTreeData.every(function(_ref2) {
             var popperRect = _ref2.popperRect,
                 popperState = _ref2.popperState,
                 props = _ref2.props;
             var interactiveBorder = props.interactiveBorder;
-            var basePlacement = getBasePlacement$1(popperState.placement);
+            var basePlacement = getBasePlacement(popperState.placement);
             var offsetData = popperState.modifiersData.offset;
             if (!offsetData) {
                 return true;
             }
             var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
             var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
             var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
@@ -33095,25 +35819,25 @@
 
     function createArrowElement(value) {
         var arrow2 = div();
         if (value === true) {
             arrow2.className = ARROW_CLASS;
         } else {
             arrow2.className = SVG_ARROW_CLASS;
-            if (isElement$1(value)) {
+            if (isElement(value)) {
                 arrow2.appendChild(value);
             } else {
                 dangerouslySetInnerHTML(arrow2, value);
             }
         }
         return arrow2;
     }
 
     function setContent(content, props) {
-        if (isElement$1(props.content)) {
+        if (isElement(props.content)) {
             dangerouslySetInnerHTML(content, "");
             content.appendChild(props.content);
         } else if (typeof props.content !== "function") {
             if (props.allowHTML) {
                 dangerouslySetInnerHTML(content, props.content);
             } else {
                 content.textContent = props.content;
@@ -33211,15 +35935,15 @@
         var didHideDueToDocumentMouseDown = false;
         var didTouchMove = false;
         var ignoreOnFirstUpdate = false;
         var lastTriggerEvent;
         var currentTransitionEndListener;
         var onFirstUpdate;
         var listeners = [];
-        var debouncedOnMouseMove = debounce$2(onMouseMove, props.interactiveDebounce);
+        var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
         var currentTarget;
         var doc = getOwnerDocument(props.triggerTarget || reference2);
         var id = idCounter$1++;
         var popperInstance = null;
         var plugins2 = unique(props.plugins);
         var state = {
             isEnabled: true,
@@ -33662,15 +36386,15 @@
                     options: {
                         element: arrow2,
                         padding: 3
                     }
                 });
             }
             modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
-            instance.popperInstance = createPopper$1(computedReference, popper2, Object.assign({}, popperOptions, {
+            instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
                 placement,
                 onFirstUpdate,
                 modifiers
             }));
         }
 
         function destroyPopperInstance() {
@@ -33770,15 +36494,15 @@
             var nextProps = evaluateProps(reference2, Object.assign({}, instance.props, {}, partialProps, {
                 ignoreAttributes: true
             }));
             instance.props = nextProps;
             addListeners();
             if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
                 cleanupInteractiveMouseListeners();
-                debouncedOnMouseMove = debounce$2(onMouseMove, nextProps.interactiveDebounce);
+                debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
             }
             if (prevProps.triggerTarget && !nextProps.triggerTarget) {
                 normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
                     node.removeAttribute("aria-expanded");
                 });
             } else if (nextProps.triggerTarget) {
                 reference2.removeAttribute("aria-expanded");
@@ -33958,15 +36682,15 @@
         var instances = elements.reduce(function(acc, reference2) {
             var instance = reference2 && createTippy(reference2, passedProps);
             if (instance) {
                 acc.push(instance);
             }
             return acc;
         }, []);
-        return isElement$1(targets) ? instances[0] : instances;
+        return isElement(targets) ? instances[0] : instances;
     }
     tippy.defaultProps = defaultProps;
     tippy.setDefaultProps = setDefaultProps;
     tippy.currentInput = currentInput;
     var mouseCoords = {
         clientX: 0,
         clientY: 0
@@ -34373,15 +37097,14 @@
     overflow-y: auto;
     display: flex;
     flex-direction: column;
     gap: 1rem;
 
     width: 350px;
     height: calc(100vh - 2rem);
-    margin: 1rem;
     padding: 1.5rem;
 
     background-color: ${(props) => props.theme.colors.background}e6;
     border-radius: 0.4rem;
     box-shadow: ${(props) => props.theme.shadow.medium};
 `;
     styled__default.default.div`
@@ -34988,21 +37711,20 @@
         });
     }
 
     function _objectWithoutPropertiesLoose$2(source, excluded) {
         if (source == null)
             return {};
         var target = {};
-        var sourceKeys = Object.keys(source);
-        var key, i2;
-        for (i2 = 0; i2 < sourceKeys.length; i2++) {
-            key = sourceKeys[i2];
-            if (excluded.indexOf(key) >= 0)
-                continue;
-            target[key] = source[key];
+        for (var key in source) {
+            if (Object.prototype.hasOwnProperty.call(source, key)) {
+                if (excluded.indexOf(key) >= 0)
+                    continue;
+                target[key] = source[key];
+            }
         }
         return target;
     }
     var reactIs = {
         exports: {}
     };
     var reactIs_production_min = {};
@@ -35580,15 +38302,15 @@
     }
 
     function isOrContainsNode(parent, child, environment) {
         var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
         return result;
     }
 
-    function debounce$1(fn, time) {
+    function debounce(fn, time) {
         var timeoutId;
 
         function cancel() {
             if (timeoutId) {
                 clearTimeout(timeoutId);
             }
         }
@@ -35731,15 +38453,15 @@
         if (checkActiveElement === void 0) {
             checkActiveElement = true;
         }
         return downshiftElements.some(function(contextNode) {
             return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
         });
     }
-    var cleanupStatus = debounce$1(function(documentProp) {
+    var cleanupStatus = debounce(function(documentProp) {
         getStatusDiv(documentProp).textContent = "";
     }, 500);
 
     function setStatus(status, documentProp) {
         var div2 = getStatusDiv(documentProp);
         if (!status) {
             return;
@@ -35815,18 +38537,18 @@
     }
 
     function getA11ySelectionMessage(selectionParameters) {
         var selectedItem = selectionParameters.selectedItem,
             itemToStringLocal = selectionParameters.itemToString;
         return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
     }
-    var updateA11yStatus = debounce$1(function(getA11yMessage, document2) {
+    var updateA11yStatus = debounce(function(getA11yMessage, document2) {
         setStatus(getA11yMessage(), document2);
     }, 200);
-    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
+    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
 
     function useElementIds(_ref2) {
         var _ref$id = _ref2.id,
             id = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id,
             labelId = _ref2.labelId,
             menuId = _ref2.menuId,
             getItemId = _ref2.getItemId,
@@ -36061,15 +38783,15 @@
         var highlightedIndex = _ref3.highlightedIndex,
             isOpen = _ref3.isOpen,
             itemRefs = _ref3.itemRefs,
             getItemNodeFromIndex = _ref3.getItemNodeFromIndex,
             menuElement = _ref3.menuElement,
             scrollIntoViewProp = _ref3.scrollIntoView;
         var shouldScrollRef = React.useRef(true);
-        useIsomorphicLayoutEffect$2(function() {
+        useIsomorphicLayoutEffect$1(function() {
             if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
                 return;
             }
             if (shouldScrollRef.current === false) {
                 shouldScrollRef.current = true;
             } else {
                 scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
@@ -36432,15 +39154,15 @@
             highlightedIndex,
             isOpen,
             itemRefs,
             scrollIntoView: scrollIntoView2,
             getItemNodeFromIndex
         });
         React.useEffect(function() {
-            clearTimeoutRef.current = debounce$1(function(outerDispatch) {
+            clearTimeoutRef.current = debounce(function(outerDispatch) {
                 outerDispatch({
                     type: FunctionSetInputValue$1,
                     inputValue: ""
                 });
             }, 500);
             return function() {
                 clearTimeoutRef.current.cancel();
@@ -37413,1547 +40135,14 @@
         itemToString: defaultProps$3.itemToString,
         stateReducer: defaultProps$3.stateReducer,
         environment: defaultProps$3.environment,
         getA11yRemovalMessage,
         keyNavigationNext: "ArrowRight",
         keyNavigationPrevious: "ArrowLeft"
     });
-    var fromEntries$1 = function fromEntries2(entries) {
-        return entries.reduce(function(acc, _ref2) {
-            var key = _ref2[0],
-                value = _ref2[1];
-            acc[key] = value;
-            return acc;
-        }, {});
-    };
-    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
-
-    function getBoundingClientRect(element) {
-        var rect = element.getBoundingClientRect();
-        return {
-            width: rect.width,
-            height: rect.height,
-            top: rect.top,
-            right: rect.right,
-            bottom: rect.bottom,
-            left: rect.left,
-            x: rect.left,
-            y: rect.top
-        };
-    }
-
-    function getWindow(node) {
-        if (node.toString() !== "[object Window]") {
-            var ownerDocument = node.ownerDocument;
-            return ownerDocument ? ownerDocument.defaultView : window;
-        }
-        return node;
-    }
-
-    function getWindowScroll(node) {
-        var win = getWindow(node);
-        var scrollLeft = win.pageXOffset;
-        var scrollTop = win.pageYOffset;
-        return {
-            scrollLeft,
-            scrollTop
-        };
-    }
-
-    function isElement(node) {
-        var OwnElement = getWindow(node).Element;
-        return node instanceof OwnElement || node instanceof Element;
-    }
-
-    function isHTMLElement(node) {
-        var OwnElement = getWindow(node).HTMLElement;
-        return node instanceof OwnElement || node instanceof HTMLElement;
-    }
-
-    function getHTMLElementScroll(element) {
-        return {
-            scrollLeft: element.scrollLeft,
-            scrollTop: element.scrollTop
-        };
-    }
-
-    function getNodeScroll(node) {
-        if (node === getWindow(node) || !isHTMLElement(node)) {
-            return getWindowScroll(node);
-        } else {
-            return getHTMLElementScroll(node);
-        }
-    }
-
-    function getNodeName(element) {
-        return element ? (element.nodeName || "").toLowerCase() : null;
-    }
-
-    function getDocumentElement(element) {
-        return (isElement(element) ? element.ownerDocument : element.document).documentElement;
-    }
-
-    function getWindowScrollBarX(element) {
-        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
-    }
-
-    function getComputedStyle$1(element) {
-        return getWindow(element).getComputedStyle(element);
-    }
-
-    function isScrollParent(element) {
-        var _getComputedStyle = getComputedStyle$1(element),
-            overflow = _getComputedStyle.overflow,
-            overflowX = _getComputedStyle.overflowX,
-            overflowY = _getComputedStyle.overflowY;
-        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
-    }
-
-    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
-        if (isFixed === void 0) {
-            isFixed = false;
-        }
-        var documentElement = getDocumentElement(offsetParent);
-        var rect = getBoundingClientRect(elementOrVirtualElement);
-        var scroll = {
-            scrollLeft: 0,
-            scrollTop: 0
-        };
-        var offsets = {
-            x: 0,
-            y: 0
-        };
-        if (!isFixed) {
-            if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
-                scroll = getNodeScroll(offsetParent);
-            }
-            if (isHTMLElement(offsetParent)) {
-                offsets = getBoundingClientRect(offsetParent);
-                offsets.x += offsetParent.clientLeft;
-                offsets.y += offsetParent.clientTop;
-            } else if (documentElement) {
-                offsets.x = getWindowScrollBarX(documentElement);
-            }
-        }
-        return {
-            x: rect.left + scroll.scrollLeft - offsets.x,
-            y: rect.top + scroll.scrollTop - offsets.y,
-            width: rect.width,
-            height: rect.height
-        };
-    }
-
-    function getLayoutRect(element) {
-        return {
-            x: element.offsetLeft,
-            y: element.offsetTop,
-            width: element.offsetWidth,
-            height: element.offsetHeight
-        };
-    }
-
-    function getParentNode(element) {
-        if (getNodeName(element) === "html") {
-            return element;
-        }
-        return element.assignedSlot || element.parentNode || element.host || getDocumentElement(element);
-    }
-
-    function getScrollParent(node) {
-        if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
-            return node.ownerDocument.body;
-        }
-        if (isHTMLElement(node) && isScrollParent(node)) {
-            return node;
-        }
-        return getScrollParent(getParentNode(node));
-    }
-
-    function listScrollParents(element, list) {
-        if (list === void 0) {
-            list = [];
-        }
-        var scrollParent = getScrollParent(element);
-        var isBody = getNodeName(scrollParent) === "body";
-        var win = getWindow(scrollParent);
-        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
-        var updatedList = list.concat(target);
-        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
-    }
-
-    function isTableElement(element) {
-        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
-    }
-
-    function getTrueOffsetParent(element) {
-        if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
-            return null;
-        }
-        return element.offsetParent;
-    }
-
-    function getOffsetParent(element) {
-        var window2 = getWindow(element);
-        var offsetParent = getTrueOffsetParent(element);
-        while (offsetParent && isTableElement(offsetParent)) {
-            offsetParent = getTrueOffsetParent(offsetParent);
-        }
-        if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static") {
-            return window2;
-        }
-        return offsetParent || window2;
-    }
-    var top = "top";
-    var bottom = "bottom";
-    var right = "right";
-    var left = "left";
-    var auto = "auto";
-    var basePlacements = [top, bottom, right, left];
-    var start = "start";
-    var end = "end";
-    var clippingParents = "clippingParents";
-    var viewport = "viewport";
-    var popper = "popper";
-    var reference = "reference";
-    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
-        return acc.concat([placement + "-" + start, placement + "-" + end]);
-    }, []);
-    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
-        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
-    }, []);
-    var beforeRead = "beforeRead";
-    var read = "read";
-    var afterRead = "afterRead";
-    var beforeMain = "beforeMain";
-    var main = "main";
-    var afterMain = "afterMain";
-    var beforeWrite = "beforeWrite";
-    var write = "write";
-    var afterWrite = "afterWrite";
-    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
-
-    function order(modifiers) {
-        var map2 = /* @__PURE__ */ new Map();
-        var visited = /* @__PURE__ */ new Set();
-        var result = [];
-        modifiers.forEach(function(modifier) {
-            map2.set(modifier.name, modifier);
-        });
-
-        function sort(modifier) {
-            visited.add(modifier.name);
-            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
-            requires.forEach(function(dep) {
-                if (!visited.has(dep)) {
-                    var depModifier = map2.get(dep);
-                    if (depModifier) {
-                        sort(depModifier);
-                    }
-                }
-            });
-            result.push(modifier);
-        }
-        modifiers.forEach(function(modifier) {
-            if (!visited.has(modifier.name)) {
-                sort(modifier);
-            }
-        });
-        return result;
-    }
-
-    function orderModifiers(modifiers) {
-        var orderedModifiers = order(modifiers);
-        return modifierPhases.reduce(function(acc, phase) {
-            return acc.concat(orderedModifiers.filter(function(modifier) {
-                return modifier.phase === phase;
-            }));
-        }, []);
-    }
-
-    function debounce(fn) {
-        var pending;
-        return function() {
-            if (!pending) {
-                pending = new Promise(function(resolve) {
-                    Promise.resolve().then(function() {
-                        pending = void 0;
-                        resolve(fn());
-                    });
-                });
-            }
-            return pending;
-        };
-    }
-
-    function getBasePlacement(placement) {
-        return placement.split("-")[0];
-    }
-
-    function mergeByName(modifiers) {
-        var merged = modifiers.reduce(function(merged2, current) {
-            var existing = merged2[current.name];
-            merged2[current.name] = existing ? Object.assign({}, existing, {}, current, {
-                options: Object.assign({}, existing.options, {}, current.options),
-                data: Object.assign({}, existing.data, {}, current.data)
-            }) : current;
-            return merged2;
-        }, {});
-        return Object.keys(merged).map(function(key) {
-            return merged[key];
-        });
-    }
-    var DEFAULT_OPTIONS = {
-        placement: "bottom",
-        modifiers: [],
-        strategy: "absolute"
-    };
-
-    function areValidElements() {
-        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-            args[_key] = arguments[_key];
-        }
-        return !args.some(function(element) {
-            return !(element && typeof element.getBoundingClientRect === "function");
-        });
-    }
-
-    function popperGenerator(generatorOptions) {
-        if (generatorOptions === void 0) {
-            generatorOptions = {};
-        }
-        var _generatorOptions = generatorOptions,
-            _generatorOptions$def = _generatorOptions.defaultModifiers,
-            defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
-            _generatorOptions$def2 = _generatorOptions.defaultOptions,
-            defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
-        return function createPopper2(reference2, popper2, options) {
-            if (options === void 0) {
-                options = defaultOptions2;
-            }
-            var state = {
-                placement: "bottom",
-                orderedModifiers: [],
-                options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions2),
-                modifiersData: {},
-                elements: {
-                    reference: reference2,
-                    popper: popper2
-                },
-                attributes: {},
-                styles: {}
-            };
-            var effectCleanupFns = [];
-            var isDestroyed = false;
-            var instance = {
-                state,
-                setOptions: function setOptions(options2) {
-                    cleanupModifierEffects();
-                    state.options = Object.assign({}, defaultOptions2, {}, state.options, {}, options2);
-                    state.scrollParents = {
-                        reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
-                        popper: listScrollParents(popper2)
-                    };
-                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
-                    state.orderedModifiers = orderedModifiers.filter(function(m2) {
-                        return m2.enabled;
-                    });
-                    runModifierEffects();
-                    return instance.update();
-                },
-                forceUpdate: function forceUpdate() {
-                    if (isDestroyed) {
-                        return;
-                    }
-                    var _state$elements = state.elements,
-                        reference3 = _state$elements.reference,
-                        popper3 = _state$elements.popper;
-                    if (!areValidElements(reference3, popper3)) {
-                        return;
-                    }
-                    state.rects = {
-                        reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
-                        popper: getLayoutRect(popper3)
-                    };
-                    state.reset = false;
-                    state.placement = state.options.placement;
-                    state.orderedModifiers.forEach(function(modifier) {
-                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
-                    });
-                    for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
-                        if (state.reset === true) {
-                            state.reset = false;
-                            index2 = -1;
-                            continue;
-                        }
-                        var _state$orderedModifie = state.orderedModifiers[index2],
-                            fn = _state$orderedModifie.fn,
-                            _state$orderedModifie2 = _state$orderedModifie.options,
-                            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
-                            name = _state$orderedModifie.name;
-                        if (typeof fn === "function") {
-                            state = fn({
-                                state,
-                                options: _options,
-                                name,
-                                instance
-                            }) || state;
-                        }
-                    }
-                },
-                update: debounce(function() {
-                    return new Promise(function(resolve) {
-                        instance.forceUpdate();
-                        resolve(state);
-                    });
-                }),
-                destroy: function destroy() {
-                    cleanupModifierEffects();
-                    isDestroyed = true;
-                }
-            };
-            if (!areValidElements(reference2, popper2)) {
-                return instance;
-            }
-            instance.setOptions(options).then(function(state2) {
-                if (!isDestroyed && options.onFirstUpdate) {
-                    options.onFirstUpdate(state2);
-                }
-            });
-
-            function runModifierEffects() {
-                state.orderedModifiers.forEach(function(_ref3) {
-                    var name = _ref3.name,
-                        _ref3$options = _ref3.options,
-                        options2 = _ref3$options === void 0 ? {} : _ref3$options,
-                        effect2 = _ref3.effect;
-                    if (typeof effect2 === "function") {
-                        var cleanupFn = effect2({
-                            state,
-                            name,
-                            instance,
-                            options: options2
-                        });
-                        var noopFn = function noopFn2() {};
-                        effectCleanupFns.push(cleanupFn || noopFn);
-                    }
-                });
-            }
-
-            function cleanupModifierEffects() {
-                effectCleanupFns.forEach(function(fn) {
-                    return fn();
-                });
-                effectCleanupFns = [];
-            }
-            return instance;
-        };
-    }
-    var passive = {
-        passive: true
-    };
-
-    function effect$2(_ref2) {
-        var state = _ref2.state,
-            instance = _ref2.instance,
-            options = _ref2.options;
-        var _options$scroll = options.scroll,
-            scroll = _options$scroll === void 0 ? true : _options$scroll,
-            _options$resize = options.resize,
-            resize = _options$resize === void 0 ? true : _options$resize;
-        var window2 = getWindow(state.elements.popper);
-        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
-        if (scroll) {
-            scrollParents.forEach(function(scrollParent) {
-                scrollParent.addEventListener("scroll", instance.update, passive);
-            });
-        }
-        if (resize) {
-            window2.addEventListener("resize", instance.update, passive);
-        }
-        return function() {
-            if (scroll) {
-                scrollParents.forEach(function(scrollParent) {
-                    scrollParent.removeEventListener("scroll", instance.update, passive);
-                });
-            }
-            if (resize) {
-                window2.removeEventListener("resize", instance.update, passive);
-            }
-        };
-    }
-    const eventListeners = {
-        name: "eventListeners",
-        enabled: true,
-        phase: "write",
-        fn: function fn() {},
-        effect: effect$2,
-        data: {}
-    };
-
-    function getVariation(placement) {
-        return placement.split("-")[1];
-    }
-
-    function getMainAxisFromPlacement(placement) {
-        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
-    }
-
-    function computeOffsets(_ref2) {
-        var reference2 = _ref2.reference,
-            element = _ref2.element,
-            placement = _ref2.placement;
-        var basePlacement = placement ? getBasePlacement(placement) : null;
-        var variation = placement ? getVariation(placement) : null;
-        var commonX = reference2.x + reference2.width / 2 - element.width / 2;
-        var commonY = reference2.y + reference2.height / 2 - element.height / 2;
-        var offsets;
-        switch (basePlacement) {
-            case top:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y - element.height
-                };
-                break;
-            case bottom:
-                offsets = {
-                    x: commonX,
-                    y: reference2.y + reference2.height
-                };
-                break;
-            case right:
-                offsets = {
-                    x: reference2.x + reference2.width,
-                    y: commonY
-                };
-                break;
-            case left:
-                offsets = {
-                    x: reference2.x - element.width,
-                    y: commonY
-                };
-                break;
-            default:
-                offsets = {
-                    x: reference2.x,
-                    y: reference2.y
-                };
-        }
-        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
-        if (mainAxis != null) {
-            var len = mainAxis === "y" ? "height" : "width";
-            switch (variation) {
-                case start:
-                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element[len] / 2);
-                    break;
-                case end:
-                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element[len] / 2);
-                    break;
-            }
-        }
-        return offsets;
-    }
-
-    function popperOffsets(_ref2) {
-        var state = _ref2.state,
-            name = _ref2.name;
-        state.modifiersData[name] = computeOffsets({
-            reference: state.rects.reference,
-            element: state.rects.popper,
-            strategy: "absolute",
-            placement: state.placement
-        });
-    }
-    const popperOffsets$1 = {
-        name: "popperOffsets",
-        enabled: true,
-        phase: "read",
-        fn: popperOffsets,
-        data: {}
-    };
-    var unsetSides = {
-        top: "auto",
-        right: "auto",
-        bottom: "auto",
-        left: "auto"
-    };
-
-    function roundOffsets(_ref2) {
-        var x2 = _ref2.x,
-            y2 = _ref2.y;
-        var win = window;
-        var dpr = win.devicePixelRatio || 1;
-        return {
-            x: Math.round(x2 * dpr) / dpr || 0,
-            y: Math.round(y2 * dpr) / dpr || 0
-        };
-    }
-
-    function mapToStyles(_ref2) {
-        var _Object$assign2;
-        var popper2 = _ref2.popper,
-            popperRect = _ref2.popperRect,
-            placement = _ref2.placement,
-            offsets = _ref2.offsets,
-            position = _ref2.position,
-            gpuAcceleration = _ref2.gpuAcceleration,
-            adaptive = _ref2.adaptive;
-        var _roundOffsets = roundOffsets(offsets),
-            x2 = _roundOffsets.x,
-            y2 = _roundOffsets.y;
-        var hasX = offsets.hasOwnProperty("x");
-        var hasY = offsets.hasOwnProperty("y");
-        var sideX = left;
-        var sideY = top;
-        var win = window;
-        if (adaptive) {
-            var offsetParent = getOffsetParent(popper2);
-            if (offsetParent === getWindow(popper2)) {
-                offsetParent = getDocumentElement(popper2);
-            }
-            if (placement === top) {
-                sideY = bottom;
-                y2 -= offsetParent.clientHeight - popperRect.height;
-                y2 *= gpuAcceleration ? 1 : -1;
-            }
-            if (placement === left) {
-                sideX = right;
-                x2 -= offsetParent.clientWidth - popperRect.width;
-                x2 *= gpuAcceleration ? 1 : -1;
-            }
-        }
-        var commonStyles = Object.assign({
-            position
-        }, adaptive && unsetSides);
-        if (gpuAcceleration) {
-            var _Object$assign;
-            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
-        }
-        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
-    }
-
-    function computeStyles(_ref3) {
-        var state = _ref3.state,
-            options = _ref3.options;
-        var _options$gpuAccelerat = options.gpuAcceleration,
-            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
-            _options$adaptive = options.adaptive,
-            adaptive = _options$adaptive === void 0 ? true : _options$adaptive;
-        var commonStyles = {
-            placement: getBasePlacement(state.placement),
-            popper: state.elements.popper,
-            popperRect: state.rects.popper,
-            gpuAcceleration
-        };
-        if (state.modifiersData.popperOffsets != null) {
-            state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.popperOffsets,
-                position: state.options.strategy,
-                adaptive
-            })));
-        }
-        if (state.modifiersData.arrow != null) {
-            state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
-                offsets: state.modifiersData.arrow,
-                position: "absolute",
-                adaptive: false
-            })));
-        }
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-placement": state.placement
-        });
-    }
-    const computeStyles$1 = {
-        name: "computeStyles",
-        enabled: true,
-        phase: "beforeWrite",
-        fn: computeStyles,
-        data: {}
-    };
-
-    function applyStyles(_ref2) {
-        var state = _ref2.state;
-        Object.keys(state.elements).forEach(function(name) {
-            var style = state.styles[name] || {};
-            var attributes = state.attributes[name] || {};
-            var element = state.elements[name];
-            if (!isHTMLElement(element) || !getNodeName(element)) {
-                return;
-            }
-            Object.assign(element.style, style);
-            Object.keys(attributes).forEach(function(name2) {
-                var value = attributes[name2];
-                if (value === false) {
-                    element.removeAttribute(name2);
-                } else {
-                    element.setAttribute(name2, value === true ? "" : value);
-                }
-            });
-        });
-    }
-
-    function effect$1(_ref2) {
-        var state = _ref2.state;
-        var initialStyles = {
-            popper: {
-                position: state.options.strategy,
-                left: "0",
-                top: "0",
-                margin: "0"
-            },
-            arrow: {
-                position: "absolute"
-            },
-            reference: {}
-        };
-        Object.assign(state.elements.popper.style, initialStyles.popper);
-        if (state.elements.arrow) {
-            Object.assign(state.elements.arrow.style, initialStyles.arrow);
-        }
-        return function() {
-            Object.keys(state.elements).forEach(function(name) {
-                var element = state.elements[name];
-                var attributes = state.attributes[name] || {};
-                var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
-                var style = styleProperties.reduce(function(style2, property2) {
-                    style2[property2] = "";
-                    return style2;
-                }, {});
-                if (!isHTMLElement(element) || !getNodeName(element)) {
-                    return;
-                }
-                Object.assign(element.style, style);
-                Object.keys(attributes).forEach(function(attribute) {
-                    element.removeAttribute(attribute);
-                });
-            });
-        };
-    }
-    const applyStyles$1 = {
-        name: "applyStyles",
-        enabled: true,
-        phase: "write",
-        fn: applyStyles,
-        effect: effect$1,
-        requires: ["computeStyles"]
-    };
-
-    function distanceAndSkiddingToXY(placement, rects, offset2) {
-        var basePlacement = getBasePlacement(placement);
-        var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
-        var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
-                placement
-            })) : offset2,
-            skidding = _ref2[0],
-            distance = _ref2[1];
-        skidding = skidding || 0;
-        distance = (distance || 0) * invertDistance;
-        return [left, right].indexOf(basePlacement) >= 0 ? {
-            x: distance,
-            y: skidding
-        } : {
-            x: skidding,
-            y: distance
-        };
-    }
-
-    function offset(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name = _ref2.name;
-        var _options$offset = options.offset,
-            offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
-        var data = placements.reduce(function(acc, placement) {
-            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
-            return acc;
-        }, {});
-        var _data$state$placement = data[state.placement],
-            x2 = _data$state$placement.x,
-            y2 = _data$state$placement.y;
-        if (state.modifiersData.popperOffsets != null) {
-            state.modifiersData.popperOffsets.x += x2;
-            state.modifiersData.popperOffsets.y += y2;
-        }
-        state.modifiersData[name] = data;
-    }
-    const offset$1 = {
-        name: "offset",
-        enabled: true,
-        phase: "main",
-        requires: ["popperOffsets"],
-        fn: offset
-    };
-    var hash$2 = {
-        left: "right",
-        right: "left",
-        bottom: "top",
-        top: "bottom"
-    };
-
-    function getOppositePlacement(placement) {
-        return placement.replace(/left|right|bottom|top/g, function(matched) {
-            return hash$2[matched];
-        });
-    }
-    var hash$1 = {
-        start: "end",
-        end: "start"
-    };
-
-    function getOppositeVariationPlacement(placement) {
-        return placement.replace(/start|end/g, function(matched) {
-            return hash$1[matched];
-        });
-    }
-
-    function getViewportRect(element) {
-        var win = getWindow(element);
-        var visualViewport = win.visualViewport;
-        var width = win.innerWidth;
-        var height = win.innerHeight;
-        if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
-            width = visualViewport.width;
-            height = visualViewport.height;
-        }
-        return {
-            width,
-            height,
-            x: 0,
-            y: 0
-        };
-    }
-
-    function getDocumentRect(element) {
-        var win = getWindow(element);
-        var winScroll = getWindowScroll(element);
-        var documentRect = getCompositeRect(getDocumentElement(element), win);
-        documentRect.height = Math.max(documentRect.height, win.innerHeight);
-        documentRect.width = Math.max(documentRect.width, win.innerWidth);
-        documentRect.x = -winScroll.scrollLeft;
-        documentRect.y = -winScroll.scrollTop;
-        return documentRect;
-    }
-
-    function toNumber$1(cssValue) {
-        return parseFloat(cssValue) || 0;
-    }
-
-    function getBorders(element) {
-        var computedStyle = isHTMLElement(element) ? getComputedStyle$1(element) : {};
-        return {
-            top: toNumber$1(computedStyle.borderTopWidth),
-            right: toNumber$1(computedStyle.borderRightWidth),
-            bottom: toNumber$1(computedStyle.borderBottomWidth),
-            left: toNumber$1(computedStyle.borderLeftWidth)
-        };
-    }
-
-    function getDecorations(element) {
-        var win = getWindow(element);
-        var borders = getBorders(element);
-        var isHTML = getNodeName(element) === "html";
-        var winScrollBarX = getWindowScrollBarX(element);
-        var x2 = element.clientWidth + borders.right;
-        var y2 = element.clientHeight + borders.bottom;
-        if (isHTML && win.innerHeight - element.clientHeight > 50) {
-            y2 = win.innerHeight - borders.bottom;
-        }
-        return {
-            top: isHTML ? 0 : element.clientTop,
-            right: element.clientLeft > borders.left ? borders.right : isHTML ? win.innerWidth - x2 - winScrollBarX : element.offsetWidth - x2,
-            bottom: isHTML ? win.innerHeight - y2 : element.offsetHeight - y2,
-            left: isHTML ? winScrollBarX : element.clientLeft
-        };
-    }
-
-    function contains(parent, child) {
-        var isShadow = Boolean(child.getRootNode && child.getRootNode().host);
-        if (parent.contains(child)) {
-            return true;
-        } else if (isShadow) {
-            var next = child;
-            do {
-                if (next && parent.isSameNode(next)) {
-                    return true;
-                }
-                next = next.parentNode || next.host;
-            } while (next);
-        }
-        return false;
-    }
-
-    function rectToClientRect(rect) {
-        return Object.assign({}, rect, {
-            left: rect.x,
-            top: rect.y,
-            right: rect.x + rect.width,
-            bottom: rect.y + rect.height
-        });
-    }
-
-    function getClientRectFromMixedType(element, clippingParent) {
-        return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
-    }
-
-    function getClippingParents(element) {
-        var clippingParents2 = listScrollParents(element);
-        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
-        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
-        if (!isElement(clipperElement)) {
-            return [];
-        }
-        return clippingParents2.filter(function(clippingParent) {
-            return isElement(clippingParent) && contains(clippingParent, clipperElement);
-        });
-    }
-
-    function getClippingRect(element, boundary, rootBoundary) {
-        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
-        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
-        var firstClippingParent = clippingParents2[0];
-        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
-            var rect = getClientRectFromMixedType(element, clippingParent);
-            var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));
-            accRect.top = Math.max(rect.top + decorations.top, accRect.top);
-            accRect.right = Math.min(rect.right - decorations.right, accRect.right);
-            accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
-            accRect.left = Math.max(rect.left + decorations.left, accRect.left);
-            return accRect;
-        }, getClientRectFromMixedType(element, firstClippingParent));
-        clippingRect.width = clippingRect.right - clippingRect.left;
-        clippingRect.height = clippingRect.bottom - clippingRect.top;
-        clippingRect.x = clippingRect.left;
-        clippingRect.y = clippingRect.top;
-        return clippingRect;
-    }
-
-    function getFreshSideObject() {
-        return {
-            top: 0,
-            right: 0,
-            bottom: 0,
-            left: 0
-        };
-    }
-
-    function mergePaddingObject(paddingObject) {
-        return Object.assign({}, getFreshSideObject(), {}, paddingObject);
-    }
-
-    function expandToHashMap(value, keys2) {
-        return keys2.reduce(function(hashMap, key) {
-            hashMap[key] = value;
-            return hashMap;
-        }, {});
-    }
-
-    function detectOverflow(state, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var _options = options,
-            _options$placement = _options.placement,
-            placement = _options$placement === void 0 ? state.placement : _options$placement,
-            _options$boundary = _options.boundary,
-            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
-            _options$rootBoundary = _options.rootBoundary,
-            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
-            _options$elementConte = _options.elementContext,
-            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
-            _options$altBoundary = _options.altBoundary,
-            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
-            _options$padding = _options.padding,
-            padding = _options$padding === void 0 ? 0 : _options$padding;
-        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
-        var altContext = elementContext === popper ? reference : popper;
-        var referenceElement = state.elements.reference;
-        var popperRect = state.rects.popper;
-        var element = state.elements[altBoundary ? altContext : elementContext];
-        var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
-        var referenceClientRect = getBoundingClientRect(referenceElement);
-        var popperOffsets2 = computeOffsets({
-            reference: referenceClientRect,
-            element: popperRect,
-            strategy: "absolute",
-            placement
-        });
-        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets2));
-        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
-        var overflowOffsets = {
-            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
-            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
-            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
-            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
-        };
-        var offsetData = state.modifiersData.offset;
-        if (elementContext === popper && offsetData) {
-            var offset2 = offsetData[placement];
-            Object.keys(overflowOffsets).forEach(function(key) {
-                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
-                var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
-                overflowOffsets[key] += offset2[axis] * multiply;
-            });
-        }
-        return overflowOffsets;
-    }
-
-    function computeAutoPlacement(state, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var _options = options,
-            placement = _options.placement,
-            boundary = _options.boundary,
-            rootBoundary = _options.rootBoundary,
-            padding = _options.padding,
-            flipVariations = _options.flipVariations,
-            _options$allowedAutoP = _options.allowedAutoPlacements,
-            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
-        var variation = getVariation(placement);
-        var placements$12 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
-            return getVariation(placement2) === variation;
-        }) : basePlacements).filter(function(placement2) {
-            return allowedAutoPlacements.indexOf(placement2) >= 0;
-        });
-        var overflows = placements$12.reduce(function(acc, placement2) {
-            acc[placement2] = detectOverflow(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding
-            })[getBasePlacement(placement2)];
-            return acc;
-        }, {});
-        return Object.keys(overflows).sort(function(a2, b2) {
-            return overflows[a2] - overflows[b2];
-        });
-    }
-
-    function getExpandedFallbackPlacements(placement) {
-        if (getBasePlacement(placement) === auto) {
-            return [];
-        }
-        var oppositePlacement = getOppositePlacement(placement);
-        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
-    }
-
-    function flip(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name = _ref2.name;
-        if (state.modifiersData[name]._skip) {
-            return;
-        }
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
-            specifiedFallbackPlacements = options.fallbackPlacements,
-            padding = options.padding,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            _options$flipVariatio = options.flipVariations,
-            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
-            allowedAutoPlacements = options.allowedAutoPlacements;
-        var preferredPlacement = state.options.placement;
-        var basePlacement = getBasePlacement(preferredPlacement);
-        var isBasePlacement = basePlacement === preferredPlacement;
-        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
-        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
-            return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
-                placement: placement2,
-                boundary,
-                rootBoundary,
-                padding,
-                flipVariations,
-                allowedAutoPlacements
-            }) : placement2);
-        }, []);
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var checksMap = /* @__PURE__ */ new Map();
-        var makeFallbackChecks = true;
-        var firstFittingPlacement = placements2[0];
-        for (var i2 = 0; i2 < placements2.length; i2++) {
-            var placement = placements2[i2];
-            var _basePlacement = getBasePlacement(placement);
-            var isStartVariation = getVariation(placement) === start;
-            var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
-            var len = isVertical ? "width" : "height";
-            var overflow = detectOverflow(state, {
-                placement,
-                boundary,
-                rootBoundary,
-                altBoundary,
-                padding
-            });
-            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
-            if (referenceRect[len] > popperRect[len]) {
-                mainVariationSide = getOppositePlacement(mainVariationSide);
-            }
-            var altVariationSide = getOppositePlacement(mainVariationSide);
-            var checks = [];
-            if (checkMainAxis) {
-                checks.push(overflow[_basePlacement] <= 0);
-            }
-            if (checkAltAxis) {
-                checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
-            }
-            if (checks.every(function(check) {
-                    return check;
-                })) {
-                firstFittingPlacement = placement;
-                makeFallbackChecks = false;
-                break;
-            }
-            checksMap.set(placement, checks);
-        }
-        if (makeFallbackChecks) {
-            var numberOfChecks = flipVariations ? 3 : 1;
-            var _loop = function _loop2(_i2) {
-                var fittingPlacement = placements2.find(function(placement2) {
-                    var checks2 = checksMap.get(placement2);
-                    if (checks2) {
-                        return checks2.slice(0, _i2).every(function(check) {
-                            return check;
-                        });
-                    }
-                });
-                if (fittingPlacement) {
-                    firstFittingPlacement = fittingPlacement;
-                    return "break";
-                }
-            };
-            for (var _i = numberOfChecks; _i > 0; _i--) {
-                var _ret = _loop(_i);
-                if (_ret === "break")
-                    break;
-            }
-        }
-        if (state.placement !== firstFittingPlacement) {
-            state.modifiersData[name]._skip = true;
-            state.placement = firstFittingPlacement;
-            state.reset = true;
-        }
-    }
-    const flip$1 = {
-        name: "flip",
-        enabled: true,
-        phase: "main",
-        fn: flip,
-        requiresIfExists: ["offset"],
-        data: {
-            _skip: false
-        }
-    };
-
-    function getAltAxis(axis) {
-        return axis === "x" ? "y" : "x";
-    }
-
-    function within(min2, value, max2) {
-        return Math.max(min2, Math.min(value, max2));
-    }
-
-    function preventOverflow(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name = _ref2.name;
-        var _options$mainAxis = options.mainAxis,
-            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
-            _options$altAxis = options.altAxis,
-            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
-            boundary = options.boundary,
-            rootBoundary = options.rootBoundary,
-            altBoundary = options.altBoundary,
-            padding = options.padding,
-            _options$tether = options.tether,
-            tether = _options$tether === void 0 ? true : _options$tether,
-            _options$tetherOffset = options.tetherOffset,
-            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
-        var overflow = detectOverflow(state, {
-            boundary,
-            rootBoundary,
-            padding,
-            altBoundary
-        });
-        var basePlacement = getBasePlacement(state.placement);
-        var variation = getVariation(state.placement);
-        var isBasePlacement = !variation;
-        var mainAxis = getMainAxisFromPlacement(basePlacement);
-        var altAxis = getAltAxis(mainAxis);
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
-            placement: state.placement
-        })) : tetherOffset;
-        var data = {
-            x: 0,
-            y: 0
-        };
-        if (!popperOffsets2) {
-            return;
-        }
-        if (checkMainAxis) {
-            var mainSide = mainAxis === "y" ? top : left;
-            var altSide = mainAxis === "y" ? bottom : right;
-            var len = mainAxis === "y" ? "height" : "width";
-            var offset2 = popperOffsets2[mainAxis];
-            var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
-            var max2 = popperOffsets2[mainAxis] - overflow[altSide];
-            var additive = tether ? -popperRect[len] / 2 : 0;
-            var minLen = variation === start ? referenceRect[len] : popperRect[len];
-            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
-            var arrowElement = state.elements.arrow;
-            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
-                width: 0,
-                height: 0
-            };
-            var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
-            var arrowPaddingMin = arrowPaddingObject[mainSide];
-            var arrowPaddingMax = arrowPaddingObject[altSide];
-            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
-            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
-            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
-            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
-            var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
-            var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
-            var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
-            var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
-            var preventedOffset = within(tether ? Math.min(min2, tetherMin) : min2, offset2, tether ? Math.max(max2, tetherMax) : max2);
-            popperOffsets2[mainAxis] = preventedOffset;
-            data[mainAxis] = preventedOffset - offset2;
-        }
-        if (checkAltAxis) {
-            var _mainSide = mainAxis === "x" ? top : left;
-            var _altSide = mainAxis === "x" ? bottom : right;
-            var _offset = popperOffsets2[altAxis];
-            var _min = _offset + overflow[_mainSide];
-            var _max = _offset - overflow[_altSide];
-            var _preventedOffset = within(_min, _offset, _max);
-            popperOffsets2[altAxis] = _preventedOffset;
-            data[altAxis] = _preventedOffset - _offset;
-        }
-        state.modifiersData[name] = data;
-    }
-    const preventOverflow$1 = {
-        name: "preventOverflow",
-        enabled: true,
-        phase: "main",
-        fn: preventOverflow,
-        requiresIfExists: ["offset"]
-    };
-
-    function arrow(_ref2) {
-        var _state$modifiersData$;
-        var state = _ref2.state,
-            name = _ref2.name;
-        var arrowElement = state.elements.arrow;
-        var popperOffsets2 = state.modifiersData.popperOffsets;
-        var basePlacement = getBasePlacement(state.placement);
-        var axis = getMainAxisFromPlacement(basePlacement);
-        var isVertical = [left, right].indexOf(basePlacement) >= 0;
-        var len = isVertical ? "height" : "width";
-        if (!arrowElement || !popperOffsets2) {
-            return;
-        }
-        var paddingObject = state.modifiersData[name + "#persistent"].padding;
-        var arrowRect = getLayoutRect(arrowElement);
-        var minProp = axis === "y" ? top : left;
-        var maxProp = axis === "y" ? bottom : right;
-        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
-        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
-        var arrowOffsetParent = getOffsetParent(arrowElement);
-        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
-        var centerToReference = endDiff / 2 - startDiff / 2;
-        var min2 = paddingObject[minProp];
-        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
-        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
-        var offset2 = within(min2, center, max2);
-        var axisProp = axis;
-        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
-    }
-
-    function effect(_ref2) {
-        var state = _ref2.state,
-            options = _ref2.options,
-            name = _ref2.name;
-        var _options$element = options.element,
-            arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element,
-            _options$padding = options.padding,
-            padding = _options$padding === void 0 ? 0 : _options$padding;
-        if (arrowElement == null) {
-            return;
-        }
-        if (typeof arrowElement === "string") {
-            arrowElement = state.elements.popper.querySelector(arrowElement);
-            if (!arrowElement) {
-                return;
-            }
-        }
-        if (!contains(state.elements.popper, arrowElement)) {
-            return;
-        }
-        state.elements.arrow = arrowElement;
-        state.modifiersData[name + "#persistent"] = {
-            padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
-        };
-    }
-    const arrow$1 = {
-        name: "arrow",
-        enabled: true,
-        phase: "main",
-        fn: arrow,
-        effect,
-        requires: ["popperOffsets"],
-        requiresIfExists: ["preventOverflow"]
-    };
-
-    function getSideOffsets(overflow, rect, preventedOffsets) {
-        if (preventedOffsets === void 0) {
-            preventedOffsets = {
-                x: 0,
-                y: 0
-            };
-        }
-        return {
-            top: overflow.top - rect.height - preventedOffsets.y,
-            right: overflow.right - rect.width + preventedOffsets.x,
-            bottom: overflow.bottom - rect.height + preventedOffsets.y,
-            left: overflow.left - rect.width - preventedOffsets.x
-        };
-    }
-
-    function isAnySideFullyClipped(overflow) {
-        return [top, right, bottom, left].some(function(side) {
-            return overflow[side] >= 0;
-        });
-    }
-
-    function hide(_ref2) {
-        var state = _ref2.state,
-            name = _ref2.name;
-        var referenceRect = state.rects.reference;
-        var popperRect = state.rects.popper;
-        var preventedOffsets = state.modifiersData.preventOverflow;
-        var referenceOverflow = detectOverflow(state, {
-            elementContext: "reference"
-        });
-        var popperAltOverflow = detectOverflow(state, {
-            altBoundary: true
-        });
-        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
-        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
-        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
-        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
-        state.modifiersData[name] = {
-            referenceClippingOffsets,
-            popperEscapeOffsets,
-            isReferenceHidden,
-            hasPopperEscaped
-        };
-        state.attributes.popper = Object.assign({}, state.attributes.popper, {
-            "data-popper-reference-hidden": isReferenceHidden,
-            "data-popper-escaped": hasPopperEscaped
-        });
-    }
-    const hide$1 = {
-        name: "hide",
-        enabled: true,
-        phase: "main",
-        requiresIfExists: ["preventOverflow"],
-        fn: hide
-    };
-    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
-    var createPopper = /* @__PURE__ */ popperGenerator({
-        defaultModifiers
-    });
-    var hasElementType = typeof Element !== "undefined";
-    var hasMap = typeof Map === "function";
-    var hasSet = typeof Set === "function";
-    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
-
-    function equal$1(a2, b2) {
-        if (a2 === b2)
-            return true;
-        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
-            if (a2.constructor !== b2.constructor)
-                return false;
-            var length, i2, keys2;
-            if (Array.isArray(a2)) {
-                length = a2.length;
-                if (length != b2.length)
-                    return false;
-                for (i2 = length; i2-- !== 0;)
-                    if (!equal$1(a2[i2], b2[i2]))
-                        return false;
-                return true;
-            }
-            var it2;
-            if (hasMap && a2 instanceof Map && b2 instanceof Map) {
-                if (a2.size !== b2.size)
-                    return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!b2.has(i2.value[0]))
-                        return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!equal$1(i2.value[1], b2.get(i2.value[0])))
-                        return false;
-                return true;
-            }
-            if (hasSet && a2 instanceof Set && b2 instanceof Set) {
-                if (a2.size !== b2.size)
-                    return false;
-                it2 = a2.entries();
-                while (!(i2 = it2.next()).done)
-                    if (!b2.has(i2.value[0]))
-                        return false;
-                return true;
-            }
-            if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
-                length = a2.length;
-                if (length != b2.length)
-                    return false;
-                for (i2 = length; i2-- !== 0;)
-                    if (a2[i2] !== b2[i2])
-                        return false;
-                return true;
-            }
-            if (a2.constructor === RegExp)
-                return a2.source === b2.source && a2.flags === b2.flags;
-            if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
-                return a2.valueOf() === b2.valueOf();
-            if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
-                return a2.toString() === b2.toString();
-            keys2 = Object.keys(a2);
-            length = keys2.length;
-            if (length !== Object.keys(b2).length)
-                return false;
-            for (i2 = length; i2-- !== 0;)
-                if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
-                    return false;
-            if (hasElementType && a2 instanceof Element)
-                return false;
-            for (i2 = length; i2-- !== 0;) {
-                if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
-                    continue;
-                }
-                if (!equal$1(a2[keys2[i2]], b2[keys2[i2]]))
-                    return false;
-            }
-            return true;
-        }
-        return a2 !== a2 && b2 !== b2;
-    }
-    var reactFastCompare = function isEqual2(a2, b2) {
-        try {
-            return equal$1(a2, b2);
-        } catch (error) {
-            if ((error.message || "").match(/stack|recursion/i)) {
-                console.warn("react-fast-compare cannot handle circular refs");
-                return false;
-            }
-            throw error;
-        }
-    };
-    var EMPTY_MODIFIERS$2 = [];
-    var usePopper$1 = function usePopper2(referenceElement, popperElement, options) {
-        if (options === void 0) {
-            options = {};
-        }
-        var prevOptions = React__namespace.useRef(null);
-        var optionsWithDefaults = {
-            onFirstUpdate: options.onFirstUpdate,
-            placement: options.placement || "bottom",
-            strategy: options.strategy || "absolute",
-            modifiers: options.modifiers || EMPTY_MODIFIERS$2
-        };
-        var _React$useState = React__namespace.useState({
-                styles: {
-                    popper: {
-                        position: optionsWithDefaults.strategy,
-                        left: "0",
-                        top: "0"
-                    },
-                    arrow: {
-                        position: "absolute"
-                    }
-                },
-                attributes: {}
-            }),
-            state = _React$useState[0],
-            setState = _React$useState[1];
-        var updateStateModifier = React__namespace.useMemo(function() {
-            return {
-                name: "updateState",
-                enabled: true,
-                phase: "write",
-                fn: function fn(_ref2) {
-                    var state2 = _ref2.state;
-                    var elements = Object.keys(state2.elements);
-                    ReactDOM__namespace.flushSync(function() {
-                        setState({
-                            styles: fromEntries$1(elements.map(function(element) {
-                                return [element, state2.styles[element] || {}];
-                            })),
-                            attributes: fromEntries$1(elements.map(function(element) {
-                                return [element, state2.attributes[element]];
-                            }))
-                        });
-                    });
-                },
-                requires: ["computeStyles"]
-            };
-        }, []);
-        var popperOptions = React__namespace.useMemo(function() {
-            var newOptions = {
-                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
-                placement: optionsWithDefaults.placement,
-                strategy: optionsWithDefaults.strategy,
-                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
-                    name: "applyStyles",
-                    enabled: false
-                }])
-            };
-            if (reactFastCompare(prevOptions.current, newOptions)) {
-                return prevOptions.current || newOptions;
-            } else {
-                prevOptions.current = newOptions;
-                return newOptions;
-            }
-        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
-        var popperInstanceRef = React__namespace.useRef();
-        useIsomorphicLayoutEffect$1(function() {
-            if (popperInstanceRef.current) {
-                popperInstanceRef.current.setOptions(popperOptions);
-            }
-        }, [popperOptions]);
-        useIsomorphicLayoutEffect$1(function() {
-            if (referenceElement == null || popperElement == null) {
-                return;
-            }
-            var createPopper$12 = options.createPopper || createPopper;
-            var popperInstance = createPopper$12(referenceElement, popperElement, popperOptions);
-            popperInstanceRef.current = popperInstance;
-            return function() {
-                popperInstance.destroy();
-                popperInstanceRef.current = null;
-            };
-        }, [referenceElement, popperElement, options.createPopper]);
-        return {
-            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
-            styles: state.styles,
-            attributes: state.attributes,
-            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
-            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
-        };
-    };
     const Wrapper$6 = styled__default.default.div`
     display: inline-flex;
 
     width: 100%;
     min-width: 4rem;
     height: 2.5rem;
 
@@ -40201,23 +41390,23 @@
             other: "over {{count}} years"
         },
         almostXYears: {
             one: "almost 1 year",
             other: "almost {{count}} years"
         }
     };
-    var formatDistance = function formatDistance2(token, count, options) {
+    var formatDistance = function formatDistance2(token, count2, options) {
         var result;
         var tokenValue = formatDistanceLocale[token];
         if (typeof tokenValue === "string") {
             result = tokenValue;
-        } else if (count === 1) {
+        } else if (count2 === 1) {
             result = tokenValue.one;
         } else {
-            result = tokenValue.other.replace("{{count}}", count.toString());
+            result = tokenValue.other.replace("{{count}}", count2.toString());
         }
         if (options !== null && options !== void 0 && options.addSuffix) {
             if (options.comparison && options.comparison > 0) {
                 return "in " + result;
             } else {
                 return result + " ago";
             }
@@ -43993,14 +45182,104 @@
             var key = _ref2[0],
                 value = _ref2[1];
             acc[key] = value;
             return acc;
         }, {});
     };
     var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
+    var hasElementType = typeof Element !== "undefined";
+    var hasMap = typeof Map === "function";
+    var hasSet = typeof Set === "function";
+    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
+
+    function equal$1(a2, b2) {
+        if (a2 === b2)
+            return true;
+        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
+            if (a2.constructor !== b2.constructor)
+                return false;
+            var length, i2, keys2;
+            if (Array.isArray(a2)) {
+                length = a2.length;
+                if (length != b2.length)
+                    return false;
+                for (i2 = length; i2-- !== 0;)
+                    if (!equal$1(a2[i2], b2[i2]))
+                        return false;
+                return true;
+            }
+            var it2;
+            if (hasMap && a2 instanceof Map && b2 instanceof Map) {
+                if (a2.size !== b2.size)
+                    return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!b2.has(i2.value[0]))
+                        return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!equal$1(i2.value[1], b2.get(i2.value[0])))
+                        return false;
+                return true;
+            }
+            if (hasSet && a2 instanceof Set && b2 instanceof Set) {
+                if (a2.size !== b2.size)
+                    return false;
+                it2 = a2.entries();
+                while (!(i2 = it2.next()).done)
+                    if (!b2.has(i2.value[0]))
+                        return false;
+                return true;
+            }
+            if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
+                length = a2.length;
+                if (length != b2.length)
+                    return false;
+                for (i2 = length; i2-- !== 0;)
+                    if (a2[i2] !== b2[i2])
+                        return false;
+                return true;
+            }
+            if (a2.constructor === RegExp)
+                return a2.source === b2.source && a2.flags === b2.flags;
+            if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
+                return a2.valueOf() === b2.valueOf();
+            if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
+                return a2.toString() === b2.toString();
+            keys2 = Object.keys(a2);
+            length = keys2.length;
+            if (length !== Object.keys(b2).length)
+                return false;
+            for (i2 = length; i2-- !== 0;)
+                if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
+                    return false;
+            if (hasElementType && a2 instanceof Element)
+                return false;
+            for (i2 = length; i2-- !== 0;) {
+                if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
+                    continue;
+                }
+                if (!equal$1(a2[keys2[i2]], b2[keys2[i2]]))
+                    return false;
+            }
+            return true;
+        }
+        return a2 !== a2 && b2 !== b2;
+    }
+    var reactFastCompare = function isEqual2(a2, b2) {
+        try {
+            return equal$1(a2, b2);
+        } catch (error) {
+            if ((error.message || "").match(/stack|recursion/i)) {
+                console.warn("react-fast-compare cannot handle circular refs");
+                return false;
+            }
+            throw error;
+        }
+    };
     var EMPTY_MODIFIERS$1 = [];
     var usePopper = function usePopper2(referenceElement, popperElement, options) {
         if (options === void 0) {
             options = {};
         }
         var prevOptions = React__namespace.useRef(null);
         var optionsWithDefaults = {
@@ -44069,16 +45348,16 @@
                 popperInstanceRef.current.setOptions(popperOptions);
             }
         }, [popperOptions]);
         useIsomorphicLayoutEffect(function() {
             if (referenceElement == null || popperElement == null) {
                 return;
             }
-            var createPopper2 = options.createPopper || createPopper$1;
-            var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
+            var createPopper$1 = options.createPopper || createPopper;
+            var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
             popperInstanceRef.current = popperInstance;
             return function() {
                 popperInstance.destroy();
                 popperInstanceRef.current = null;
             };
         }, [referenceElement, popperElement, options.createPopper]);
         return {
@@ -47392,25 +48671,15 @@
 
     background-color: ${(props) => props.theme.colors.grey1};
     border: none;
     outline: 0;
 `;
 
     function DatepickerSelect(props) {
-        var _a, _b, _c;
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes,
-            update
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: props.placement || "bottom-start"
-        });
+        var _a;
         const [pendingHighlight, setPendingHighlight] = React.useState(null);
         const {
             isOpen,
             selectedItem,
             getToggleButtonProps,
             getMenuProps,
             highlightedIndex,
@@ -47440,67 +48709,74 @@
         }));
         React.useEffect(() => {
             if (isOpen && pendingHighlight !== null) {
                 setHighlightedIndex(pendingHighlight);
                 setPendingHighlight(null);
             }
         }, [isOpen, pendingHighlight, setHighlightedIndex]);
-        React.useEffect(() => {
-            if (isOpen && update) {
-                update();
-            }
-        }, [isOpen, update]);
-        const buttonProps = getToggleButtonProps({
-            disabled: props.disabled
-        });
-        const setButtonRef = buttonProps.ref;
-        delete buttonProps.ref;
-        const setButtonReference = (value) => {
-            setButtonRef(value);
-            referenceElement.current = value;
-        };
+        const {
+            refs,
+            floatingStyles,
+            context: context2
+        } = useFloating({
+            open: isOpen,
+            placement: props.placement || "bottom-start",
+            middleware: [offset$2(8), flip$2(), shift()],
+            whileElementsMounted: isOpen ? autoUpdate : void 0
+        });
+        const role = useRole(context2, {
+            role: "listbox"
+        });
+        const {
+            getReferenceProps,
+            getFloatingProps
+        } = useInteractions([role]);
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            var _a2;
-            setMenuRef(value);
-            popperElement.current = value;
-            (_a2 = props.dropdownRef) === null || _a2 === void 0 ? void 0 : _a2.call(props, value);
-        };
+        const setFloatingRef = refs.setFloating;
+        const {
+            dropdownRef
+        } = props;
+        const mergedRefs = React__namespace.useCallback((node) => {
+            setFloatingRef(node);
+            setMenuRef(node);
+            dropdownRef === null || dropdownRef === void 0 ? void 0 : dropdownRef(node);
+        }, [setFloatingRef, setMenuRef, dropdownRef]);
         return jsxRuntime.exports.jsx(Tooltip, {
             content: props.errorMsg,
             disabled: !props.errorMsg,
             styling: "error",
             children: jsxRuntime.exports.jsxs(Wrapper$5, {
                 className: props.className,
                 isDisabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 onClick: props.onClick,
                 style: props.style,
                 children: [jsxRuntime.exports.jsxs(SelectButtonPrimary, Object.assign({
                     disabled: props.disabled
-                }, buttonProps, {
-                    ref: setButtonReference,
+                }, getToggleButtonProps({
+                    disabled: props.disabled
+                }), {
+                    ref: refs.setReference
+                }, getReferenceProps(), {
                     type: "button",
                     children: [jsxRuntime.exports.jsx(SelectedItem$1, {
                         size: props.size,
                         children: selectedItem ? selectedItem.label : "Select"
                     }), jsxRuntime.exports.jsx(Chevron$2, {
                         disabled: props.disabled,
                         isOpen
                     })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$1, Object.assign({}, menuProps, attributes.popper, {
-                    className: `${(_a = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a !== void 0 ? _a : ""} ${(_c = (_b = attributes === null || attributes === void 0 ? void 0 : attributes.popper) === null || _b === void 0 ? void 0 : _b.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$1, Object.assign({}, menuProps, getFloatingProps(), {
+                    ref: mergedRefs,
+                    className: `${(_a = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a !== void 0 ? _a : ""} ${props.itemClass}`,
                     displacement: props.displacement,
                     isOpen,
                     maxItems: 7,
-                    ref: setMenuReference,
-                    style: Object.assign(Object.assign({}, styles2.popper), {
-                        marginTop: `0.8rem`,
+                    style: Object.assign(Object.assign({}, floatingStyles), {
                         width: "16.25rem",
                         zIndex: 9999
                     }),
                     children: props.items.map((item, index2) => {
                         const _a2 = getItemProps({
                                 index: index2,
                                 item
@@ -49711,25 +50987,18 @@
     margin-left: -1px;
     border-radius: 0 0 0.25rem 0.25rem;
     outline: 0;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
 
     function Select(props) {
-        var _a, _b, _c, _d, _e2, _f;
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
+        var _a, _b, _c;
         const {
-            styles: styles2,
-            attributes,
-            update
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier],
-            placement: props.placement || "bottom-start"
-        });
+            applySameWidthModifier = true
+        } = props;
         const {
             isOpen,
             selectedItem,
             getToggleButtonProps,
             getMenuProps,
             highlightedIndex,
             getItemProps
@@ -49742,68 +51011,75 @@
                 var _a2;
                 const selected = changes.selectedItem;
                 (_a2 = props.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(props, selected);
             }
         }, "selectedItem" in props && {
             selectedItem: props.selectedItem
         }));
-        React.useEffect(() => {
-            if (isOpen && update) {
-                update();
-            }
-        }, [isOpen, update]);
-        const buttonProps = getToggleButtonProps({
-            disabled: props.disabled
-        });
-        const setButtonRef = buttonProps.ref;
-        delete buttonProps.ref;
-        const setButtonReference = (value) => {
-            setButtonRef(value);
-            referenceElement.current = value;
-        };
+        const {
+            refs,
+            floatingStyles,
+            context: context2
+        } = useFloating({
+            open: isOpen,
+            placement: props.placement || "bottom-start",
+            middleware: [flip$2(), shift(), ...applySameWidthModifier ? [matchWidthToReference(2)] : []],
+            whileElementsMounted: isOpen ? autoUpdate : void 0
+        });
+        const role = useRole(context2, {
+            role: "listbox"
+        });
+        const {
+            getReferenceProps,
+            getFloatingProps
+        } = useInteractions([role]);
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            var _a2;
-            setMenuRef(value);
-            popperElement.current = value;
-            (_a2 = props.dropdownRef) === null || _a2 === void 0 ? void 0 : _a2.call(props, value);
-        };
+        const setFloatingRef = refs.setFloating;
+        const {
+            dropdownRef
+        } = props;
+        const mergedRefs = React__namespace.useCallback((node) => {
+            setFloatingRef(node);
+            setMenuRef(node);
+            dropdownRef === null || dropdownRef === void 0 ? void 0 : dropdownRef(node);
+        }, [setFloatingRef, setMenuRef, dropdownRef]);
         return jsxRuntime.exports.jsx(Tooltip, {
             content: props.errorMsg,
             disabled: !props.errorMsg,
             styling: "error",
             children: jsxRuntime.exports.jsxs(Wrapper$4, {
                 className: props.className,
                 isDisabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 isOpen,
                 onClick: props.onClick,
                 style: props.style,
                 children: [jsxRuntime.exports.jsxs(SelectButton, Object.assign({
                     disabled: props.disabled,
                     isOpen
-                }, buttonProps, {
-                    ref: setButtonReference,
+                }, getToggleButtonProps({
+                    disabled: props.disabled
+                }), {
+                    ref: refs.setReference
+                }, getReferenceProps(), {
                     type: "button",
                     children: [jsxRuntime.exports.jsx(SelectedItem, {
                         size: props.size,
                         children: (_b = (_a = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a !== void 0 ? _a : props.placeholder) !== null && _b !== void 0 ? _b : "Select"
                     }), jsxRuntime.exports.jsx(Chevron$2, {
                         disabled: props.disabled,
                         isOpen
                     })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, attributes.popper, {
-                    className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${(_e2 = (_d = attributes === null || attributes === void 0 ? void 0 : attributes.popper) === null || _d === void 0 ? void 0 : _d.className) !== null && _e2 !== void 0 ? _e2 : ""} ${props.itemClass}`,
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, getFloatingProps(), {
+                    ref: mergedRefs,
+                    className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
                     isOpen,
                     maxItems: props.maxItems,
-                    ref: setMenuReference,
-                    style: Object.assign(Object.assign({}, styles2.popper), {
-                        width: props.applySameWidthModifier === false ? void 0 : parseFloat((_f = styles2.popper) === null || _f === void 0 ? void 0 : _f.width) + 2,
+                    style: Object.assign(Object.assign({}, floatingStyles), {
                         zIndex: 9999
                     }),
                     children: props.items.map((item, index2) => {
                         const _a2 = getItemProps({
                                 index: index2,
                                 item
                             }),
@@ -50528,26 +51804,16 @@
                 return [...acc, sectionHeading, ...sectionItems];
             }
             return [...acc, item];
         }, []);
     }
 
     function SectionedList(props) {
-        var _a, _b, _c, _d;
+        var _a, _b, _c;
         const theme2 = useClTheme();
-        const referenceElement = React.useRef(null);
-        const popperElement = React.useRef(null);
-        const {
-            styles: styles2,
-            attributes,
-            update
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
-            placement: "bottom-start"
-        });
         const unpackedItems = React.useMemo(() => unpackSectionedList(props.items), [props.items]);
         const [pendingHighlight, setPendingHighlight] = React.useState(null);
         const [items, setItems] = React.useState(unpackedItems);
         const [inputValue, setInputValue] = React.useState((_b = (_a = props.selectedItem) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "");
         const {
             selectedItem,
             isOpen,
@@ -50646,49 +51912,60 @@
             }
         }, [isOpen, pendingHighlight, setHighlightedIndex]);
         React.useEffect(() => {
             if (props.selectedItem === null) {
                 setInputValue("");
             }
         }, [props.selectedItem]);
-        React.useEffect(() => {
-            if (isOpen && update) {
-                update();
-            }
-        }, [isOpen, update]);
+        const {
+            refs,
+            floatingStyles,
+            context: context2
+        } = useFloating({
+            open: isOpen,
+            placement: "bottom-start",
+            middleware: [flip$2(), shift(), matchWidthToReference(2)],
+            whileElementsMounted: isOpen ? autoUpdate : void 0
+        });
+        const role = useRole(context2, {
+            role: "listbox"
+        });
+        const {
+            getReferenceProps,
+            getFloatingProps
+        } = useInteractions([role]);
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
-        delete menuProps.ref;
-        const setMenuReference = (value) => {
-            setMenuRef(value);
-            popperElement.current = value;
-        };
+        const setFloatingRef = refs.setFloating;
+        const mergedRefs = React.useCallback((node) => {
+            setFloatingRef(node);
+            setMenuRef(node);
+        }, [setFloatingRef, setMenuRef]);
         return jsxRuntime.exports.jsxs(Wrapper$6, {
             className: props.className,
             isDisabled: props.disabled,
             isErrored: false,
             isOpen,
             style: props.style,
             children: [jsxRuntime.exports.jsxs(InputWrapper$2, {
                 disabled: props.disabled,
                 isOpen,
-                ref: referenceElement,
+                ref: refs.setReference,
                 children: [jsxRuntime.exports.jsx(Input, Object.assign({}, getInputProps({
                     value: inputValue
-                }))), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
+                }), getReferenceProps())), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
                     children: jsxRuntime.exports.jsx(Chevron$2, {
                         disabled: props.disabled,
                         isOpen
                     })
                 }))]
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, attributes.popper, {
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, getFloatingProps(), {
+                ref: mergedRefs,
                 isOpen,
-                ref: setMenuReference,
-                style: Object.assign(Object.assign({}, styles2.popper), {
-                    width: parseFloat((_d = styles2.popper) === null || _d === void 0 ? void 0 : _d.width) + 2,
+                style: Object.assign(Object.assign({}, floatingStyles), {
                     zIndex: 9999
                 }),
                 children: [items.length > 0 && items.map((item, index2) => {
                     const itemProps = getItemProps({
                         index: index2,
                         item
                     });
@@ -51343,17 +52620,17 @@
             key: "setRange",
             value: function setRange(val) {
                 this.range = [val[0], val[1]];
                 return this;
             }
         }, {
             key: "getTicks",
-            value: function getTicks(count) {
+            value: function getTicks(count2) {
                 var d2 = this.domain;
-                return ticks(d2[0], d2[d2.length - 1], count ? count : 10);
+                return ticks(d2[0], d2[d2.length - 1], count2 ? count2 : 10);
             }
         }]);
         return LinearScale2;
     }();
     var defaultGetEventData = function defaultGetEventData2() {
         return {
             value: 0,
@@ -51373,20 +52650,20 @@
             value: function render2() {
                 var _this$props = this.props,
                     children = _this$props.children,
                     values = _this$props.values,
                     _this$props$scale = _this$props.scale,
                     scale = _this$props$scale === void 0 ? new LinearScale() : _this$props$scale,
                     _this$props$count = _this$props.count,
-                    count = _this$props$count === void 0 ? 10 : _this$props$count,
+                    count2 = _this$props$count === void 0 ? 10 : _this$props$count,
                     _this$props$getEventD = _this$props.getEventData,
                     getEventData = _this$props$getEventD === void 0 ? defaultGetEventData : _this$props$getEventD,
                     _this$props$activeHan = _this$props.activeHandleID,
                     activeHandleID = _this$props$activeHan === void 0 ? "" : _this$props$activeHan;
-                var ticks2 = (values ? values : scale.getTicks(count)).map(function(value) {
+                var ticks2 = (values ? values : scale.getTicks(count2)).map(function(value) {
                     return {
                         id: "$$-".concat(value),
                         value,
                         percent: scale.getValue(value)
                     };
                 });
                 var renderedChildren = children({
@@ -57384,41 +58661,45 @@
         allColumns,
         allowColumnHiding,
         numVisibleColumns,
         resetResizing,
         setAllFilters,
         style
     }) => {
-        const [optionsElement, setOptionsElement] = React.useState(null);
-        const [popperElement, setPopperElement] = React.useState(null);
-        const [showOptions, setShowOptions] = React.useState(false);
-        const {
-            styles: styles2,
-            attributes,
-            update
-        } = usePopper$1(optionsElement, popperElement, {
-            placement: "left-end"
-        });
-        const toggleOptions = () => {
-            setShowOptions(!showOptions);
-        };
-        const onOptionSelect = (option) => {
+        const [isOpen, setIsOpen] = React.useState(false);
+        const toggleOptions = React.useCallback(() => {
+            setIsOpen((prev) => !prev);
+        }, []);
+        const onOptionSelect = React.useCallback((option) => {
             option.onClick();
-        };
-        const clickOutsideOptionsHandler = () => {
-            if (showOptions) {
-                toggleOptions();
-            }
-        };
-        useOnClickOutside(popperElement, clickOutsideOptionsHandler);
-        React.useEffect(() => {
-            if (showOptions) {
-                update();
-            }
-        }, [showOptions, update]);
+            setIsOpen(false);
+        }, []);
+        const {
+            refs,
+            floatingStyles,
+            context: context2
+        } = useFloating({
+            open: isOpen,
+            onOpenChange: setIsOpen,
+            placement: "left-end",
+            middleware: [flip$2(), shift()],
+            whileElementsMounted: isOpen ? autoUpdate : void 0
+        });
+        const interactions = useInteractions([
+            useClick(context2, {
+                event: "mousedown"
+            }),
+            useDismiss(context2, {
+                outsidePress: true,
+                outsidePressEvent: "mousedown"
+            }),
+            useRole(context2, {
+                role: "menu"
+            })
+        ]);
         const resetFunctions = React.useMemo(() => {
             const functions2 = {
                 items: [{
                     label: "Reset Column Widths",
                     onClick: resetResizing,
                     value: "resetResizing"
                 }, {
@@ -57450,30 +58731,31 @@
                     onClick: () => !(column.isVisible && numVisibleColumns === 1) ? column.toggleHidden() : null,
                     value: `${column.isVisible ? "hide" : "show"}${String(column.Header)}`
                 })),
                 label: "Columns"
             };
         }, [allColumns, allowColumnHiding, numVisibleColumns]);
         return jsxRuntime.exports.jsxs(HeaderOptions, {
-            ref: setOptionsElement,
+            ref: refs.setReference,
             children: [jsxRuntime.exports.jsx(HeaderOptionsIcon, {
                 icon: faEllipsisV,
                 onClick: toggleOptions
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, attributes.popper, {
-                isOpen: showOptions,
-                ref: setPopperElement,
-                style: Object.assign(Object.assign(Object.assign({}, styles2.popper), {
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, interactions.getFloatingProps({
+                ref: refs.setFloating,
+                style: Object.assign(Object.assign(Object.assign({}, floatingStyles), {
                     maxHeight: 800,
                     minWidth: 150,
                     zIndex: 9999
-                }), style),
+                }), style)
+            }), {
+                isOpen,
                 children: jsxRuntime.exports.jsx(SectionedList, {
                     items: allowColumnHiding ? [resetFunctions, columnToggles] : [resetFunctions],
                     onSelect: onOptionSelect
-                })
+                }, isOpen ? "open" : "closed")
             })), document.body)]
         });
     };
     var __rest$1 = globalThis && globalThis.__rest || function(s, e3) {
         var t2 = {};
         for (var p2 in s)
             if (Object.prototype.hasOwnProperty.call(s, p2) && e3.indexOf(p2) < 0)
@@ -59700,23 +60982,23 @@
                 subscriber.complete();
             }, void 0, function() {
                 lastValue = activeTask = null;
             }));
         });
     }
 
-    function take(count) {
-        return count <= 0 ? function() {
+    function take(count2) {
+        return count2 <= 0 ? function() {
             return EMPTY;
         } : operate(function(source, subscriber) {
             var seen = 0;
             source.subscribe(createOperatorSubscriber(subscriber, function(value) {
-                if (++seen <= count) {
+                if (++seen <= count2) {
                     subscriber.next(value);
-                    if (count <= seen) {
+                    if (count2 <= seen) {
                         subscriber.complete();
                     }
                 }
             }));
         });
     }
 
@@ -60832,26 +62114,26 @@
     }
     var _isLaziable = isLaziable$1;
     var HOT_COUNT = 800,
         HOT_SPAN = 16;
     var nativeNow = Date.now;
 
     function shortOut$2(func) {
-        var count = 0,
+        var count2 = 0,
             lastCalled = 0;
         return function() {
             var stamp = nativeNow(),
                 remaining = HOT_SPAN - (stamp - lastCalled);
             lastCalled = stamp;
             if (remaining > 0) {
-                if (++count >= HOT_COUNT) {
+                if (++count2 >= HOT_COUNT) {
                     return arguments[0];
                 }
             } else {
-                count = 0;
+                count2 = 0;
             }
             return func.apply(void 0, arguments);
         };
     }
     var _shortOut = shortOut$2;
     var baseSetData$1 = _baseSetData,
         shortOut$1 = _shortOut;
```

## Comparing `dara_core-1.8.5.dist-info/LICENSE` & `dara_core-1.8.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dara_core-1.8.5.dist-info/METADATA` & `dara_core-1.8.6.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dara-core
-Version: 1.8.5
+Version: 1.8.6
 Summary: Dara Framework Core
 Home-page: https://dara.causalens.com/
 License: Apache-2.0
 Author: Sam Smith
 Author-email: sam@causalens.com
 Requires-Python: >=3.8.0,<3.12.0
 Classifier: License :: OSI Approved :: Apache Software License
@@ -15,18 +15,18 @@
 Classifier: Programming Language :: Python :: 3.11
 Provides-Extra: all
 Requires-Dist: aiorwlock (>=1.4.0,<2.0.0)
 Requires-Dist: anyio (>=4.0.0)
 Requires-Dist: async-asgi-testclient (>=1.4.11,<2.0.0)
 Requires-Dist: click (==8.1.3)
 Requires-Dist: colorama (>=0.4.6,<0.5.0)
-Requires-Dist: create-dara-app (==1.8.5)
+Requires-Dist: create-dara-app (==1.8.6)
 Requires-Dist: croniter (>=1.0.15,<2.0.0)
 Requires-Dist: cryptography (>=42.0.4)
-Requires-Dist: dara-components (==1.8.5) ; extra == "all"
+Requires-Dist: dara-components (==1.8.6) ; extra == "all"
 Requires-Dist: exceptiongroup (>=1.1.3,<2.0.0)
 Requires-Dist: fastapi (==0.109.0)
 Requires-Dist: fastapi-vite (==0.3.1)
 Requires-Dist: httpx (>=0.23.0)
 Requires-Dist: jinja2 (>=2.1.1,<3.1.0)
 Requires-Dist: odfpy
 Requires-Dist: openpyxl
@@ -46,15 +46,15 @@
 Requires-Dist: uvicorn[standard] (>=0.22.0,<0.23.0)
 Requires-Dist: xlrd
 Project-URL: Repository, https://github.com/causalens/dara
 Description-Content-Type: text/markdown
 
 # Dara Application Framework
 
-<img src="https://github.com/causalens/dara/blob/VERSION-1.8.5/img/dara_light.svg?raw=true">
+<img src="https://github.com/causalens/dara/blob/VERSION-1.8.6/img/dara_light.svg?raw=true">
 
 ![Master tests](https://github.com/causalens/dara/actions/workflows/tests.yml/badge.svg?branch=master)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
 [![PyPI](https://img.shields.io/pypi/v/dara-core.svg?color=dark-green)](https://pypi.org/project/dara-core/)
 [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/dara-core.svg?color=dark-green)](https://pypi.org/project/dara-core/)
 [![NPM](https://img.shields.io/npm/v/@darajs/components.svg?color=dark-green)](https://www.npmjs.com/package/@darajs/components)
 
@@ -91,15 +91,15 @@
 poetry run dara start
 
 # with pip installation make sure to activate the new virtual environment
 source .venv/bin/activate
 dara start
 ```
 
-![Dara App](https://github.com/causalens/dara/blob/VERSION-1.8.5/img/components_gallery.png?raw=true)
+![Dara App](https://github.com/causalens/dara/blob/VERSION-1.8.6/img/components_gallery.png?raw=true)
 
 Note: `pip` installation uses [PEP 660](https://peps.python.org/pep-0660/) `pyproject.toml`-based editable installs which require `pip >= 21.3` and `setuptools >= 64.0.0`. You can upgrade both with:
 
 ```bash
 python -m pip install --upgrade pip
 pip install --user --upgrade setuptools
 ```
@@ -108,27 +108,27 @@
 
 ## Dara App examples
 
 Explore some of our favorite apps - a great way of getting started and getting to know the framework!
 
 | Dara App                                                                                                 | Description                                                                                                                                                                                                       |
 | -------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| ![Large Language Model](https://github.com/causalens/dara/blob/VERSION-1.8.5/img/llm.png?raw=true)              | Demonstrates how to use incorporate a LLM chat box into your decision app to understand model insights                                                                                                            |
-| ![Plot Interactivity](https://github.com/causalens/dara/blob/VERSION-1.8.5/img/plot_interactivity.png?raw=true) | Demonstrates how to enable the user to interact with plots, trigger actions based on clicks, mouse movements and other interactions with `Bokeh` or `Plotly` plots                                                |
-| ![Graph Editor](https://github.com/causalens/dara/blob/VERSION-1.8.5/img/graph_viewer.png?raw=true)             | Demonstrates how to use the `CausalGraphViewer` component to display your graphs or networks, customising the displayed information through colors and tooltips, and updating the page based on user interaction. |
+| ![Large Language Model](https://github.com/causalens/dara/blob/VERSION-1.8.6/img/llm.png?raw=true)              | Demonstrates how to use incorporate a LLM chat box into your decision app to understand model insights                                                                                                            |
+| ![Plot Interactivity](https://github.com/causalens/dara/blob/VERSION-1.8.6/img/plot_interactivity.png?raw=true) | Demonstrates how to enable the user to interact with plots, trigger actions based on clicks, mouse movements and other interactions with `Bokeh` or `Plotly` plots                                                |
+| ![Graph Editor](https://github.com/causalens/dara/blob/VERSION-1.8.6/img/graph_viewer.png?raw=true)             | Demonstrates how to use the `CausalGraphViewer` component to display your graphs or networks, customising the displayed information through colors and tooltips, and updating the page based on user interaction. |
 
 Check out our [App Gallery](https://dara.causalens.com/gallery) for more inspiration!
 
 ## Repository introduction
 
 This repository covers the Dara Application Framework first-party packages.
 
 - `dara-core`: The core of the Dara framework, this includes the core framework code for creating applications.
 - `dara-components`: Components for the Dara Framework.
 - `create-dara-app`: A CLI tool for creating new Dara applications.
 
-More information on the repository structure can be found in the [CONTRIBUTING.md](https://github.com/causalens/dara/blob/VERSION-1.8.5/CONTRIBUTING.md) file.
+More information on the repository structure can be found in the [CONTRIBUTING.md](https://github.com/causalens/dara/blob/VERSION-1.8.6/CONTRIBUTING.md) file.
 
 ## License
 
-Dara is open-source and licensed under the [Apache 2.0 License](https://github.com/causalens/dara/blob/VERSION-1.8.5/LICENSE).
+Dara is open-source and licensed under the [Apache 2.0 License](https://github.com/causalens/dara/blob/VERSION-1.8.6/LICENSE).
```

## Comparing `dara_core-1.8.5.dist-info/RECORD` & `dara_core-1.8.6.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -77,15 +77,15 @@
 dara/core/logging.py,sha256=QXf8qQDNdh5UW5-jnYwFz7U7KDmhPiZXmObBal_mwPo,13093
 dara/core/main.py,sha256=bl-Sjcgh0Hb-iYoCAuiMlkoG-fN8Erhwa5Nw3HGv_cc,17899
 dara/core/metrics/__init__.py,sha256=2UqpWHv-Ie58QLJIHJ9Szfjq8xifAuwy5FYGUIFwWtI,823
 dara/core/metrics/cache.py,sha256=ybofUhZO0TCHeyhB_AtldWk1QTmTKh7GucTXpOkeTFA,2580
 dara/core/metrics/runtime.py,sha256=YP-6Dz0GeI9_Yr7bUk_-OqShyFySGH_AKpDO126l6es,1833
 dara/core/metrics/utils.py,sha256=meYfOcCvgdf39lc0NnAHjVQ3QDjwwzCXnL6vEh1ylL8,2231
 dara/core/persistence.py,sha256=TO94rPAN7jxZKVCC5YA4eE7GGDoNlCPe-BkkItV2VUE,10379
-dara/core/umd/dara.core.umd.js,sha256=PLx6p1I1dkrr7QkzjUwGa-uF4U9LsewHv8U2toGevUU,4793040
+dara/core/umd/dara.core.umd.js,sha256=6GpBcmfz_RePLJuUQ7LGxLhksoiicwKV28hstiWNndQ,4834104
 dara/core/umd/style.css,sha256=YQtQ4veiSktnyONl0CU1iU1kKfcQhreH4iASi1MP7Ak,4095007
 dara/core/visual/__init__.py,sha256=QN0wbG9HPQ_vXh8BO8DnBXeYLIENVTNtRmYzZf1lx7c,577
 dara/core/visual/components/__init__.py,sha256=O-Em_glGdZNO0LLl2RWmJSrQiXKxliXg_PuhVXGT81I,1811
 dara/core/visual/components/dynamic_component.py,sha256=w7rxrM9ZTNvkHymkAto_s9UKg7EE8VrlpL9QdRe4sgY,692
 dara/core/visual/components/fallback.py,sha256=uazqdqgmWXPHluPRl3-5DofjE_cMMyKusIsn_pHuz1s,3378
 dara/core/visual/components/for_cmp.py,sha256=h15J_uVc974ILSRVYRLOWFOqaWIllivd6j-lNjpQU4U,6600
 dara/core/visual/components/invalid_component.py,sha256=HbWj5tjD5M8o8e-s6awnkDn3boHV7GyOWhALjWGOQmk,866
@@ -101,12 +101,12 @@
 dara/core/visual/dynamic_component.py,sha256=bTDTYu12B3wSZmqFPisQvvnA_Q-fyYp0Ds0Y08lE-jM,13608
 dara/core/visual/progress_updater.py,sha256=35_fb_F68YjtYf8MMRA76FoajjfPAlutmqz5fUNgTPs,5840
 dara/core/visual/template.py,sha256=y0KJU2913Q10y1TVMpTVnIxIoUsabzYfpUHEGuX2QyM,5707
 dara/core/visual/themes/__init__.py,sha256=aM4mgoIYo2neBSw5FRzswsht7PUKjLthiHLmFIkyRKw,794
 dara/core/visual/themes/dark.py,sha256=UQGDooOc8ric73eHs9E0ltYP4UCrwqQ3QxqN_fb4PwY,1942
 dara/core/visual/themes/definitions.py,sha256=m3oN0txs65MZepqjj7AKMMxybf2aq5fTjcTwJmHqEbk,2744
 dara/core/visual/themes/light.py,sha256=-Tviq8oEwGbdFULoDOqPuHO0UpAZGsBy8qFi0kAGolQ,1944
-dara_core-1.8.5.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
-dara_core-1.8.5.dist-info/METADATA,sha256=5Xuk9ArcS5y48Qb6j2HFlzeo4gPRSTe3NgV_O4AKqXE,6773
-dara_core-1.8.5.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
-dara_core-1.8.5.dist-info/entry_points.txt,sha256=H__D5sNIGuPIhVam0DChNL-To5k8Y7nY7TAFz9Mz6cc,139
-dara_core-1.8.5.dist-info/RECORD,,
+dara_core-1.8.6.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
+dara_core-1.8.6.dist-info/METADATA,sha256=NJuh6dDYTRmPhFs-_hL4LIVO9BPiKIi5bHNOY_zgaJ4,6773
+dara_core-1.8.6.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
+dara_core-1.8.6.dist-info/entry_points.txt,sha256=H__D5sNIGuPIhVam0DChNL-To5k8Y7nY7TAFz9Mz6cc,139
+dara_core-1.8.6.dist-info/RECORD,,
```

