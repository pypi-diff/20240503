# Comparing `tmp/actoolkit-3.0.1b7-py3-none-any.whl.zip` & `tmp/actoolkit-3.0.1b8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,56 +1,56 @@
-Zip file size: 124853 bytes, number of entries: 54
--rw-r--r--  2.0 unx    10201 b- defN 24-Apr-30 01:37 toolkit.py
--rw-r--r--  2.0 unx     1139 b- defN 24-Apr-30 01:37 astraSDK/__init__.py
--rw-r--r--  2.0 unx     3659 b- defN 24-Apr-30 01:37 astraSDK/apiresources.py
--rw-r--r--  2.0 unx    16993 b- defN 24-Apr-30 01:37 astraSDK/apps.py
--rw-r--r--  2.0 unx     8289 b- defN 24-Apr-30 01:37 astraSDK/backups.py
--rw-r--r--  2.0 unx     7355 b- defN 24-Apr-30 01:37 astraSDK/buckets.py
--rw-r--r--  2.0 unx     6972 b- defN 24-Apr-30 01:37 astraSDK/clouds.py
--rw-r--r--  2.0 unx    10776 b- defN 24-Apr-30 01:37 astraSDK/clusters.py
--rw-r--r--  2.0 unx    14439 b- defN 24-Apr-30 01:37 astraSDK/common.py
--rw-r--r--  2.0 unx     9115 b- defN 24-Apr-30 01:37 astraSDK/credentials.py
--rw-r--r--  2.0 unx     2663 b- defN 24-Apr-30 01:37 astraSDK/entitlements.py
--rw-r--r--  2.0 unx     7958 b- defN 24-Apr-30 01:37 astraSDK/groups.py
--rw-r--r--  2.0 unx     7162 b- defN 24-Apr-30 01:37 astraSDK/hooks.py
--rw-r--r--  2.0 unx    45273 b- defN 24-Apr-30 01:37 astraSDK/k8s.py
--rw-r--r--  2.0 unx     5458 b- defN 24-Apr-30 01:37 astraSDK/namespaces.py
--rw-r--r--  2.0 unx     3576 b- defN 24-Apr-30 01:37 astraSDK/notifications.py
--rw-r--r--  2.0 unx    11162 b- defN 24-Apr-30 01:37 astraSDK/protections.py
--rw-r--r--  2.0 unx     9735 b- defN 24-Apr-30 01:37 astraSDK/replications.py
--rw-r--r--  2.0 unx     5757 b- defN 24-Apr-30 01:37 astraSDK/rolebindings.py
--rw-r--r--  2.0 unx     7090 b- defN 24-Apr-30 01:37 astraSDK/scripts.py
--rw-r--r--  2.0 unx     9821 b- defN 24-Apr-30 01:37 astraSDK/settings.py
--rw-r--r--  2.0 unx     7083 b- defN 24-Apr-30 01:37 astraSDK/snapshots.py
--rw-r--r--  2.0 unx     2434 b- defN 24-Apr-30 01:37 astraSDK/storagebackends.py
--rw-r--r--  2.0 unx     5023 b- defN 24-Apr-30 01:37 astraSDK/storageclasses.py
--rw-r--r--  2.0 unx     9007 b- defN 24-Apr-30 01:37 astraSDK/users.py
--rw-r--r--  2.0 unx      883 b- defN 24-Apr-30 01:37 tkSrc/__init__.py
--rw-r--r--  2.0 unx    32031 b- defN 24-Apr-30 01:37 tkSrc/choices.py
--rw-r--r--  2.0 unx     3992 b- defN 24-Apr-30 01:37 tkSrc/classes.py
--rw-r--r--  2.0 unx    24437 b- defN 24-Apr-30 01:37 tkSrc/clone.py
--rw-r--r--  2.0 unx     2011 b- defN 24-Apr-30 01:37 tkSrc/copy.py
--rw-r--r--  2.0 unx    29823 b- defN 24-Apr-30 01:37 tkSrc/create.py
--rw-r--r--  2.0 unx    11098 b- defN 24-Apr-30 01:37 tkSrc/deploy.py
--rw-r--r--  2.0 unx     9743 b- defN 24-Apr-30 01:37 tkSrc/destroy.py
--rw-r--r--  2.0 unx    26916 b- defN 24-Apr-30 01:37 tkSrc/helpers.py
--rw-r--r--  2.0 unx     4912 b- defN 24-Apr-30 01:37 tkSrc/ipr.py
--rw-r--r--  2.0 unx    19392 b- defN 24-Apr-30 01:37 tkSrc/list.py
--rw-r--r--  2.0 unx    16912 b- defN 24-Apr-30 01:37 tkSrc/manage.py
--rw-r--r--  2.0 unx    81403 b- defN 24-Apr-30 01:37 tkSrc/parser.py
--rw-r--r--  2.0 unx     7249 b- defN 24-Apr-30 01:37 tkSrc/unmanage.py
--rw-r--r--  2.0 unx    12344 b- defN 24-Apr-30 01:37 tkSrc/update.py
--rw-r--r--  2.0 unx      446 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/app.jinja
--rw-r--r--  2.0 unx      532 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/appVault.jinja
--rw-r--r--  2.0 unx      406 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/backup.jinja
--rw-r--r--  2.0 unx      374 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/hook.jinja
--rw-r--r--  2.0 unx      277 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/ipr.jinja
--rw-r--r--  2.0 unx      417 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/protection.jinja
--rw-r--r--  2.0 unx      584 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/restore.jinja
--rw-r--r--  2.0 unx      533 b- defN 24-Apr-30 01:37 tkSrc/templates/jinja/snapshot.jinja
--rw-r--r--  2.0 unx    11357 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/LICENSE
--rw-r--r--  2.0 unx     9193 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       23 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     4255 b- defN 24-Apr-30 01:37 actoolkit-3.0.1b7.dist-info/RECORD
-54 files, 539818 bytes uncompressed, 118267 bytes compressed:  78.1%
+Zip file size: 126330 bytes, number of entries: 54
+-rw-r--r--  2.0 unx    10702 b- defN 24-Apr-30 21:12 toolkit.py
+-rw-r--r--  2.0 unx     1139 b- defN 24-Apr-30 21:12 astraSDK/__init__.py
+-rw-r--r--  2.0 unx     3752 b- defN 24-Apr-30 21:12 astraSDK/apiresources.py
+-rw-r--r--  2.0 unx    17485 b- defN 24-Apr-30 21:12 astraSDK/apps.py
+-rw-r--r--  2.0 unx     8546 b- defN 24-Apr-30 21:12 astraSDK/backups.py
+-rw-r--r--  2.0 unx     7683 b- defN 24-Apr-30 21:12 astraSDK/buckets.py
+-rw-r--r--  2.0 unx     7234 b- defN 24-Apr-30 21:12 astraSDK/clouds.py
+-rw-r--r--  2.0 unx    11279 b- defN 24-Apr-30 21:12 astraSDK/clusters.py
+-rw-r--r--  2.0 unx    14577 b- defN 24-Apr-30 21:12 astraSDK/common.py
+-rw-r--r--  2.0 unx     9443 b- defN 24-Apr-30 21:12 astraSDK/credentials.py
+-rw-r--r--  2.0 unx     2745 b- defN 24-Apr-30 21:12 astraSDK/entitlements.py
+-rw-r--r--  2.0 unx     8286 b- defN 24-Apr-30 21:12 astraSDK/groups.py
+-rw-r--r--  2.0 unx     7419 b- defN 24-Apr-30 21:12 astraSDK/hooks.py
+-rw-r--r--  2.0 unx    45787 b- defN 24-Apr-30 21:12 astraSDK/k8s.py
+-rw-r--r--  2.0 unx     5594 b- defN 24-Apr-30 21:12 astraSDK/namespaces.py
+-rw-r--r--  2.0 unx     3658 b- defN 24-Apr-30 21:12 astraSDK/notifications.py
+-rw-r--r--  2.0 unx    11501 b- defN 24-Apr-30 21:12 astraSDK/protections.py
+-rw-r--r--  2.0 unx    10008 b- defN 24-Apr-30 21:12 astraSDK/replications.py
+-rw-r--r--  2.0 unx     6003 b- defN 24-Apr-30 21:12 astraSDK/rolebindings.py
+-rw-r--r--  2.0 unx     7418 b- defN 24-Apr-30 21:12 astraSDK/scripts.py
+-rw-r--r--  2.0 unx     9715 b- defN 24-Apr-30 21:12 astraSDK/settings.py
+-rw-r--r--  2.0 unx     7340 b- defN 24-Apr-30 21:12 astraSDK/snapshots.py
+-rw-r--r--  2.0 unx     2516 b- defN 24-Apr-30 21:12 astraSDK/storagebackends.py
+-rw-r--r--  2.0 unx     5151 b- defN 24-Apr-30 21:12 astraSDK/storageclasses.py
+-rw-r--r--  2.0 unx     9335 b- defN 24-Apr-30 21:12 astraSDK/users.py
+-rw-r--r--  2.0 unx      883 b- defN 24-Apr-30 21:12 tkSrc/__init__.py
+-rw-r--r--  2.0 unx    32915 b- defN 24-Apr-30 21:12 tkSrc/choices.py
+-rw-r--r--  2.0 unx     3992 b- defN 24-Apr-30 21:12 tkSrc/classes.py
+-rw-r--r--  2.0 unx    24602 b- defN 24-Apr-30 21:12 tkSrc/clone.py
+-rw-r--r--  2.0 unx     2110 b- defN 24-Apr-30 21:12 tkSrc/copy.py
+-rw-r--r--  2.0 unx    30546 b- defN 24-Apr-30 21:12 tkSrc/create.py
+-rw-r--r--  2.0 unx    11250 b- defN 24-Apr-30 21:12 tkSrc/deploy.py
+-rw-r--r--  2.0 unx    10102 b- defN 24-Apr-30 21:12 tkSrc/destroy.py
+-rw-r--r--  2.0 unx    26916 b- defN 24-Apr-30 21:12 tkSrc/helpers.py
+-rw-r--r--  2.0 unx     4966 b- defN 24-Apr-30 21:12 tkSrc/ipr.py
+-rw-r--r--  2.0 unx    19735 b- defN 24-Apr-30 21:12 tkSrc/list.py
+-rw-r--r--  2.0 unx    17439 b- defN 24-Apr-30 21:12 tkSrc/manage.py
+-rw-r--r--  2.0 unx    81403 b- defN 24-Apr-30 21:12 tkSrc/parser.py
+-rw-r--r--  2.0 unx     7451 b- defN 24-Apr-30 21:12 tkSrc/unmanage.py
+-rw-r--r--  2.0 unx    12714 b- defN 24-Apr-30 21:12 tkSrc/update.py
+-rw-r--r--  2.0 unx      446 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/app.jinja
+-rw-r--r--  2.0 unx      532 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/appVault.jinja
+-rw-r--r--  2.0 unx      406 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/backup.jinja
+-rw-r--r--  2.0 unx      374 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/hook.jinja
+-rw-r--r--  2.0 unx      277 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/ipr.jinja
+-rw-r--r--  2.0 unx      417 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/protection.jinja
+-rw-r--r--  2.0 unx      584 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/restore.jinja
+-rw-r--r--  2.0 unx      533 b- defN 24-Apr-30 21:12 tkSrc/templates/jinja/snapshot.jinja
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9193 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4257 b- defN 24-Apr-30 21:12 actoolkit-3.0.1b8.dist-info/RECORD
+54 files, 549874 bytes uncompressed, 119744 bytes compressed:  78.2%
```

## zipnote {}

```diff
@@ -138,26 +138,26 @@
 
 Filename: tkSrc/templates/jinja/restore.jinja
 Comment: 
 
 Filename: tkSrc/templates/jinja/snapshot.jinja
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/LICENSE
+Filename: actoolkit-3.0.1b8.dist-info/LICENSE
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/METADATA
+Filename: actoolkit-3.0.1b8.dist-info/METADATA
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/WHEEL
+Filename: actoolkit-3.0.1b8.dist-info/WHEEL
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/entry_points.txt
+Filename: actoolkit-3.0.1b8.dist-info/entry_points.txt
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/top_level.txt
+Filename: actoolkit-3.0.1b8.dist-info/top_level.txt
 Comment: 
 
-Filename: actoolkit-3.0.1b7.dist-info/RECORD
+Filename: actoolkit-3.0.1b8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## toolkit.py

```diff
@@ -15,17 +15,18 @@
    limitations under the License.
 """
 
 import gc
 import sys
 
 import tkSrc
+from astraSDK.common import getConfig
 
 
-def main(argv=sys.argv):
+def main(argv=sys.argv, config=None):
     # The various functions to populate the lists used for choices() in the options are
     # expensive. argparse provides no way to know what subcommand was selected prior to
     # parsing the options. By then it's too late to decide which functions to run to
     # populate the various choices the differing options for each subcommand needs. So
     # we just go around argparse's back and inspect sys.argv directly.
     acl = tkSrc.classes.ArgparseChoicesLists()
     ard = tkSrc.classes.AstraResourceDicts()
@@ -139,29 +140,39 @@
 
         # If v3, build the context@kubeconfig choices list (we want this outside of
         # tkSrc.choices.main as it should be generated regardless of plaidMode)
         if v3:
             v3, verbPosition = tkSrc.choices.kube_config(
                 argv, acl, verbPosition, v3Position, global_args
             )
+        # If not v3, set up the Astra Control config, which includes a requests Session
+        elif config is None:
+            config = getConfig().main()
 
         # Enabling comma separated listing of objects, like:
         # 'toolkit.py list apps,backups,snapshots'
         if (verbs["list"] or verbs["get"]) and len(argv) > (verbPosition + 1):
             if "," in argv[verbPosition + 1]:
                 listTypeArray = argv[verbPosition + 1].split(",")
                 for lt in listTypeArray:
                     argv[verbPosition + 1] = lt
-                    main(argv=argv)
+                    main(argv=argv, config=config)
                 sys.exit(0)
 
         # As long as we're not --fast/plaidMode, build the argparse choices lists
         if not plaidMode:
             tkSrc.choices.main(
-                argv, verbs, verbPosition, ard, acl, v3, v3_skip_tls_verify=v3_skip_tls_verify
+                argv,
+                verbs,
+                verbPosition,
+                ard,
+                acl,
+                v3,
+                v3_skip_tls_verify=v3_skip_tls_verify,
+                config=config,
             )
 
     else:
         raise SystemExit(
             f"{argv[0]}: error: please specify a subcommand. Run '{argv[0]} -h' for "
             "parser information."
         )
@@ -229,33 +240,33 @@
         tkSrc.helpers.parserError("--dry-run can only be used in conjunction with --v3")
     elif args.skip_tls_verify and not args.v3:
         tkSrc.helpers.parserError(
             "--insecure-skip-tls-verify can only be used in conjunction with --v3"
         )
 
     if args.subcommand == "deploy":
-        tkSrc.deploy.main(args, ard)
+        tkSrc.deploy.main(args, ard, config=config)
     elif args.subcommand == "clone" or args.subcommand == "restore":
-        tkSrc.clone.main(args, ard)
+        tkSrc.clone.main(args, ard, config=config)
     elif args.subcommand == "ipr":
-        tkSrc.ipr.main(args, ard)
+        tkSrc.ipr.main(args, ard, config=config)
     elif args.subcommand == "list" or args.subcommand == "get":
-        tkSrc.list.main(args)
+        tkSrc.list.main(args, config=config)
     elif args.subcommand == "copy":
-        tkSrc.copy.main(args)
+        tkSrc.copy.main(args, config=config)
     elif args.subcommand == "create":
-        tkSrc.create.main(args, ard)
+        tkSrc.create.main(args, ard, config=config)
     elif args.subcommand == "manage" or args.subcommand == "define":
-        tkSrc.manage.main(args, ard)
+        tkSrc.manage.main(args, ard, config=config)
     elif args.subcommand == "destroy":
-        tkSrc.destroy.main(args, ard)
+        tkSrc.destroy.main(args, ard, config=config)
     elif args.subcommand == "unmanage":
-        tkSrc.unmanage.main(args, ard)
+        tkSrc.unmanage.main(args, ard, config=config)
     elif args.subcommand == "update":
-        tkSrc.update.main(args, ard)
+        tkSrc.update.main(args, ard, config=config)
 
 
 if __name__ == "__main__":
     try:
         main()
     except KeyboardInterrupt:
         pass
```

## astraSDK/apiresources.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -20,25 +20,26 @@
 from tabulate import tabulate
 
 from .common import SDKCommon
 from .clusters import getClusters
 
 
 class getApiResources(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.clusters = getClusters(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.clusters = getClusters(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, cluster=None):
         if self.clusters is False:
             print("getClusters().main() failed")
             return False
         if len(self.clusters["items"]) == 0:
             print("No clusters found")
@@ -58,15 +59,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 if results is None:
```

## astraSDK/apps.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -31,24 +31,25 @@
     no longer a "discovered" or "ignored" construct with apps.  There's simply managed apps
     (which is what this class covers), or yet-to-be-managed (referred to as unmanaged) apps,
     which are handled by the getNamespaces class.
 
     Therefore this class cannot list all of the managed and unmanaged apps.
     """
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(
         self,
         namespace=None,
         nameFilter=None,
         cluster=None,
     ):
@@ -62,15 +63,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             apps = super().jsonifyResults(ret)
             appsCooked = copy.deepcopy(apps)
@@ -190,20 +190,21 @@
     Any number of clusterScopedResources (and optional label selectors) can be provided through
     the clusterScopedResources argument, which must be a list of dictionaries:
         [{"GVK": {"group": "rbac.authorization.k8s.io", "kind": "ClusterRole", "version": "v1"},
           "labelSelectors": ["app=name"]}]
 
     There is no validation of this input, that instead is left to the calling method."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-app+json"
         self.headers["Content-Type"] = "application/astra-app+json"
 
     def main(
         self,
         appName,
         namespace,
@@ -231,15 +232,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -250,20 +250,21 @@
                 super().printError(ret)
             return False
 
 
 class unmanageApp(SDKCommon):
     """This class undefines a managed application."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-app+json"
         self.headers["Content-Type"] = "application/astra-app+json"
 
     def main(self, appID):
         endpoint = f"k8s/v2/apps/{appID}"
         url = self.base + endpoint
         params = {}
@@ -271,15 +272,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             if not self.quiet:
                 print("App unmanaged")
@@ -299,20 +299,21 @@
     clone an app to the same cluster it is running on; in which case clusterID ==
     sourceClusterID.
 
     This class doesn't try to validate anything you pass it, if you give it garbage
     for any parameters the clone operation will fail.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-app+json"
         self.headers["Content-Type"] = "application/astra-app+json"
 
     def main(
         self,
         cloneName,
         clusterID,
@@ -351,15 +352,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -379,20 +379,21 @@
 
     Also note that the return code this class returns is referring to submitting
     the restore job.  To know if the restore job itself succeeds or fails you
     need to monitor the state of the app, watching for it to switch from
     "restoring" to "running" or "failed".
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return True/False
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-app+json"
         self.headers["Content-Type"] = "application/astra-app+json"
         self.headers["ForceUpdate"] = "true"
 
     def main(
         self,
         appID,
@@ -418,53 +419,52 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
             if not self.quiet:
                 super().printError(ret)
             return False
 
 
 class getAppAssets(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, appID):
         endpoint = f"k8s/v1/apps/{appID}/appAssets"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             assets = super().jsonifyResults(ret)
             assets["metadata"]["appID"] = appID
```

## astraSDK/backups.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -25,25 +25,26 @@
 class getBackups(SDKCommon):
     """Iterate over every managed app, and list all of it's backups.
     Failure reporting is not implimented, failure to list backups for
     one (or more) of N many apps just results in an empty list of backups
     for that app.
     """
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.apps = getApps(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.apps = getApps(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, appFilter=None):
         if self.apps is False:
             if not self.quiet:
                 super().printError("Call to getApps() failed")
             return False
 
@@ -76,15 +77,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 if results is None:
@@ -132,20 +132,21 @@
 
 
 class takeBackup(SDKCommon):
     """Take a backup of an app.  An AppID and backupName are required fields,
     a bucketID and snpshotID are optional fields, and either the result JSON is
     returned or the backupID of the newly created backup is returned."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appBackup+json"
         self.headers["Content-Type"] = "application/astra-appBackup+json"
 
     def main(self, appID, backupName, bucketID=None, snapshotID=None):
         endpoint = f"k8s/v1/apps/{appID}/appBackups"
         url = self.base + endpoint
         params = {}
@@ -161,15 +162,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -181,20 +181,21 @@
             return False
 
 
 class destroyBackup(SDKCommon):
     """Given an appID and backupID destroy the backup.  Note that this doesn't
     unmanage a backup, it actively destroys it. There is no coming back from this."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appBackup+json"
         self.headers["Content-Type"] = "application/astra-appBackup+json"
 
     def main(self, appID, backupID):
         endpoint = f"k8s/v1/apps/{appID}/appBackups/{backupID}"
         url = self.base + endpoint
         params = {}
@@ -205,15 +206,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/buckets.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,39 +21,39 @@
 
 from .common import SDKCommon
 
 
 class getBuckets(SDKCommon):
     """Get all of the buckets in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, nameFilter=None, provider=None):
         endpoint = "topology/v1/buckets"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             buckets = super().jsonifyResults(ret)
             bucketsCooked = copy.deepcopy(buckets)
@@ -86,20 +86,21 @@
 class manageBucket(SDKCommon):
     """Manage an object storage resource for storing backups.
     This class does no validation of the arguments, leaving that
     to the API call itself.  toolkit.py can be used as a guide as to
     what the API requirements are in case the swagger isn't sufficient.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-bucket+json"
         self.headers["Content-Type"] = "application/astra-bucket+json"
 
     def main(self, name, credentialID, provider, bucketParameters):
         endpoint = "topology/v1/buckets"
         url = self.base + endpoint
         params = {}
@@ -114,15 +115,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -133,20 +133,21 @@
                 super().printError(ret)
             return False
 
 
 class unmanageBucket(SDKCommon):
     """This class unmanages / removes a bucket"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-bucket+json"
         self.headers["Content-Type"] = "application/astra-bucket+json"
 
     def main(self, bucketID):
         endpoint = f"topology/v1/buckets/{bucketID}"
         url = self.base + endpoint
         params = {}
@@ -154,15 +155,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             if not self.quiet:
                 print("Bucket unmanaged")
@@ -173,20 +173,21 @@
             return False
 
 
 class updateBucket(SDKCommon):
     """This class updates a bucket, it is currently intended for updating the credentialID,
     but has been created in a way to allow other kinds of updates in future versions."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-bucket+json"
         self.headers["Content-Type"] = "application/astra-bucket+json"
 
     def main(self, bucketID, credentialID=None):
         endpoint = f"topology/v1/buckets/{bucketID}"
         url = self.base + endpoint
         params = {}
@@ -199,15 +200,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             # the buckets/ endpoint doesn't return a dict for PUTs, so calling getBuckets
             results = next(b for b in getBuckets().main()["items"] if b["id"] == bucketID)
```

## astraSDK/clouds.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -19,39 +19,39 @@
 import json
 import copy
 
 from .common import SDKCommon
 
 
 class getClouds(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, cloudType=None):
         endpoint = "topology/v1/clouds"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             clouds = super().jsonifyResults(ret)
             cloudsCooked = copy.deepcopy(clouds)
@@ -77,20 +77,21 @@
                 super().printError(ret)
             return False
 
 
 class manageCloud(SDKCommon):
     """This class manages a cloud"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-cloud+json"
         self.headers["Content-Type"] = "application/astra-cloud+json"
 
     def main(self, cloudName, cloudType, credentialID=None, description=None, defaultBucketID=None):
         endpoint = "topology/v1/clouds"
         url = self.base + endpoint
         params = {}
@@ -109,15 +110,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -128,20 +128,21 @@
                 super().printError(ret)
             return False
 
 
 class unmanageCloud(SDKCommon):
     """This class unmanages a cloud"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-cloud+json"
         self.headers["Content-Type"] = "application/astra-cloud+json"
 
     def main(self, cloudID):
         endpoint = f"topology/v1/clouds/{cloudID}"
         url = self.base + endpoint
         params = {}
@@ -149,15 +150,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             if not self.quiet:
                 print("Cloud unmanaged")
@@ -169,21 +169,21 @@
 
 
 class updateCloud(SDKCommon):
     """This class updates a cloud, it is currently intended for updating the credentialID
     or defaultBucketID of a cloud, but has been created in a way to allow other kinds of
     updates in future versions."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
-        # self.headers["accept"] = "application/astra-cloud+json"
+        super().__init__(config=config)
         self.headers["Content-Type"] = "application/astra-cloud+json"
 
     def main(self, cloudID, credentialID=None, defaultBucketID=None):
         endpoint = f"topology/v1/clouds/{cloudID}"
         url = self.base + endpoint
         params = {}
         data = {
@@ -197,15 +197,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
```

## astraSDK/clusters.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,25 +21,26 @@
 from .common import SDKCommon
 from .clouds import getClouds
 
 
 class getClusters(SDKCommon):
     """Iterate over the clouds and list the clusters in each."""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.clouds = getClouds(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.clouds = getClouds(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, hideManaged=False, hideUnmanaged=False, nameFilter=None):
         clusters = {}
         clusters["items"] = []
         if self.clouds is False:
             print("Call to get clouds failed")
             return False
@@ -54,15 +55,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 for item in results["items"]:
@@ -109,20 +109,21 @@
             print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
         return dataReturn
 
 
 class manageCluster(SDKCommon):
     """This class switches an unmanaged cluster to a managed cluster"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-managedCluster+json"
         self.headers["Content-Type"] = "application/managedCluster+json"
 
     def main(self, clusterID, storageClassID=None):
         endpoint = "topology/v1/managedClusters"
         url = self.base + endpoint
         params = {}
@@ -136,15 +137,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -155,20 +155,21 @@
                 super().printError(ret)
             return False
 
 
 class unmanageCluster(SDKCommon):
     """This class switches a managed cluster to an un managed cluster"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-managedCluster+json"
         self.headers["Content-Type"] = "application/managedCluster+json"
         self.clusters = getClusters().main()
 
     def main(self, clusterID):
         endpoint = f"topology/v1/managedClusters/{clusterID}"
         url = self.base + endpoint
@@ -177,15 +178,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             if not self.quiet:
                 print("Cluster unmanaged")
@@ -196,20 +196,21 @@
             return False
 
 
 class addCluster(SDKCommon):
     """This class adds an (ACC) Kubernetes cluster into the 'unmanaged' cluster list,
     after which it can then be changed from an unmanged to a managed cluster."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-cluster+json"
         self.headers["Content-Type"] = "application/astra-cluster+json"
 
     def main(self, cloudID, credentialID, privateRouteID=None):
         endpoint = f"topology/v1/clouds/{cloudID}/clusters"
         url = self.base + endpoint
         params = {}
@@ -223,15 +224,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -243,20 +243,21 @@
             return False
 
 
 class deleteCluster(SDKCommon):
     """This class deletes a cluster.  It's meant for ACC environments only, and should
     be called after unmanageCluster if it's an ACC-managed cluster."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-cluster+json"
         self.headers["Content-Type"] = "application/astra-cluster+json"
 
     def main(self, clusterID, cloudID):
         endpoint = f"topology/v1/clouds/{cloudID}/clusters/{clusterID}"
         url = self.base + endpoint
         params = {}
@@ -264,15 +265,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             if not self.quiet:
                 print(f"Cluster {clusterID} destroyed")
@@ -284,20 +284,21 @@
 
 
 class updateCluster(SDKCommon):
     """This class updates a managed cluster, it is currently intended for updating the
     or defaultBucketID of a cluster, but has been created in a way to allow other kinds of
     updates in future versions."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["Content-Type"] = "application/astra-managedCluster+json"
 
     def main(self, clusterID, defaultBucketID=None):
         endpoint = f"topology/v1/managedClusters/{clusterID}"
         url = self.base + endpoint
         params = {}
         data = {
@@ -309,15 +310,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
```

## astraSDK/common.py

```diff
@@ -75,27 +75,27 @@
 
         if "." in self.conf.get("astra_project"):
             self.domain = self.conf.get("astra_project")
         else:
             self.domain = "%s.astra.netapp.io" % (self.conf.get("astra_project"))
         self.account_id = self.conf.get("uid")
         self.base = "https://%s/accounts/%s/" % (self.domain, self.account_id)
-        self.headers = self.conf.get("headers")
+        self.session = requests.Session()
+        self.session.headers.update(self.conf.get("headers"))
 
         if self.conf.get("verifySSL") is False:
             disable_warnings()
-            self.verifySSL = False
+            self.session.verify = False
         else:
-            self.verifySSL = True
+            self.session.verify = True
 
     def main(self):
         return {
             "base": self.base,
-            "headers": self.headers,
-            "verifySSL": self.verifySSL,
+            "session": self.session,
             "domain": self.domain,
             "account_id": self.account_id,
         }
 
 
 class BaseCommon:
     def __init__(self):
@@ -164,32 +164,32 @@
             # Wrap text over 80 characters
             row = [textwrap.fill(r, width=80) if isinstance(r, str) else r for r in row]
             tabData.append(row)
         return tabulate(tabData, tabHeader, tablefmt=tablefmt)
 
 
 class SDKCommon(BaseCommon):
-    def __init__(self):
+    def __init__(self, config=None):
         super().__init__()
-        self.conf = getConfig().main()
+        self.conf = getConfig().main() if config is None else config
+        self.session = self.conf.get("session")
         self.base = self.conf.get("base")
-        self.headers = self.conf.get("headers")
-        self.verifySSL = self.conf.get("verifySSL")
+        self.headers = {}
 
-    def apicall(self, method, url, data, headers, params, verify, quiet=False, verbose=False):
+    def apicall(self, method, url, data, headers, params, quiet=False, verbose=False):
         """Make a call using the requests module.
         method can be get, put, post, patch, or delete"""
         try:
-            r = getattr(requests, method)
+            r = getattr(self.session, method)
         except AttributeError as e:
             raise SystemExit(e)
         try:
             if verbose:
-                self.printVerbose(url, method, headers, data, params)
-            ret = r(url, json=data, headers=headers, params=params, verify=verify)
+                self.printVerbose(url, method, headers, data, params, self.session)
+            ret = r(url, json=data, headers=headers, params=params)
         except requests.exceptions.RequestException as e:
             raise SystemExit(e)
         if not ret.ok:
             # GET clouds has more response information than other calls, so if
             # there's an error make a second API call to improve error messaging
             if (
                 url.split("/")[-1] != "clouds"
@@ -198,15 +198,14 @@
             ):
                 self.apicall(
                     "get",
                     self.base + "topology/v1/clouds",
                     {},
                     self.headers,
                     {},
-                    self.verifySSL,
                     quiet=False,
                     verbose=False,
                 )
             elif ret.status_code >= 400 and ret.status_code < 500:
                 if "x-pcloud-accountid" in ret.text:
                     print(f"API call to Astra Control failed: {RED}check uid in config.json{ENDC}")
                 elif ret.status_code == 401:
@@ -234,21 +233,23 @@
         try:
             results = requestsObject.json()
         except ValueError as e:
             print(f"response contained invalid JSON: {e}")
             results = None
         return results
 
-    def printVerbose(self, url, method, headers, data, params):
+    def printVerbose(self, url, method, headers, data, params, session):
         """Function to print API call details when in verbose mode"""
+        combinedHeaders = {**headers, **session.headers}
         print(f"{GREEN}API URL: {url}{ENDC}")
         print(f"{GREEN}API Method: {method}{ENDC}")
-        print(f"{GREEN}API Headers: {headers}{ENDC}")
+        print(f"{GREEN}API Headers: {combinedHeaders}{ENDC}")
         print(f"{GREEN}API data: {data}{ENDC}")
         print(f"{GREEN}API params: {params}{ENDC}")
+        print(f"{GREEN}API verifySSL: {session.verify}{ENDC}")
 
 
 class KubeCommon(BaseCommon):
     def __init__(self, config_context=None, client_configuration=None, silently_fail=False):
         super().__init__()
         if (
             isinstance(client_configuration, kubernetes.client.configuration.Configuration)
```

## astraSDK/credentials.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -20,39 +20,39 @@
 import copy
 from tabulate import tabulate
 
 from .common import SDKCommon
 
 
 class getCredentials(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, kubeconfigOnly=False):
         endpoint = "core/v1/credentials"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             creds = super().jsonifyResults(ret)
             credsCooked = copy.deepcopy(creds)
@@ -110,20 +110,21 @@
     of the inputs.  Please see toolkit.py for further examples if the swagger definition does
     not provide all the information you require.
 
     Cloud credentials must have a 'keyType' of 'generic' while also having the 'credType' label
     be 'service-account', so this class handles the discrepancy by accepting a 'keyType' of
     'service-account' as an input and modifying it to be 'generic' in the payload."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-credential+json"
         self.headers["Content-Type"] = "application/astra-credential+json"
 
     def main(
         self,
         credName,
         keyType,
@@ -152,15 +153,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -171,20 +171,21 @@
                 super().printError(ret)
             return False
 
 
 class destroyCredential(SDKCommon):
     """This class destroys a credential. Use with caution, as there's no going back."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-credential+json"
         self.headers["Content-Type"] = "application/astra-credential+json"
 
     def main(self, credentialID):
         endpoint = f"core/v1/credentials/{credentialID}"
         url = self.base + endpoint
         params = {}
@@ -192,15 +193,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
@@ -210,20 +210,21 @@
 
 
 class updateCredential(SDKCommon):
     """This class updates a credential, it is currently intended for updating a kubeconfig
     for a cluster (via the keyStore value), but has been created in a way to allow other
     kinds of updates in future versions."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-credential+json"
         self.headers["Content-Type"] = "application/astra-credential+json"
 
     def main(self, credentialID, credName, keyStore=None):
         endpoint = f"core/v1/credentials/{credentialID}"
         url = self.base + endpoint
         params = {}
@@ -237,15 +238,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
```

## astraSDK/entitlements.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,39 +21,39 @@
 from .common import SDKCommon
 
 
 class getEntitlements(SDKCommon):
     """Get the Astra Control entitlements, which can be used to determine if it's
     an Astra Control Service or Center environment."""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self):
         endpoint = "core/v1/entitlements"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             entitlements = super().jsonifyResults(ret)
             if self.output == "json":
```

## astraSDK/groups.py

```diff
@@ -25,39 +25,39 @@
 YELLOW = "\033[33m"
 ENDC = "\033[0m"
 
 
 class getGroups(SDKCommon):
     """Get all the groups in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, nameFilter=None):
         endpoint = "core/v1/groups"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             groups = super().jsonifyResults(ret)
 
@@ -81,20 +81,21 @@
             return False
 
 
 class createGroup(SDKCommon):
     """Create a group within the Astra Control account.  This class does not do argument
     verification, please reference toolkit.py which has proper guardrails"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-group+json"
         self.headers["Content-Type"] = "application/astra-group+json"
 
     def main(
         self,
         authID,
         authProvider="ldap",
@@ -111,15 +112,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -130,20 +130,21 @@
                 super().printError(ret)
             return False
 
 
 class destroyGroup(SDKCommon):
     """Destroys a group"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-group+json"
         self.headers["Content-Type"] = "application/astra-group+json"
 
     def main(self, groupID):
         endpoint = f"core/v1/groups/{groupID}"
         url = self.base + endpoint
         params = {}
@@ -154,15 +155,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
@@ -170,24 +170,25 @@
                 super().printError(ret)
             return False
 
 
 class getLdapGroups(SDKCommon):
     """Query LDAP for a list of groups"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(
         self,
         cnFilter=None,
         dnFilter=None,
         limit=25,
         cont=None,
@@ -214,15 +215,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             groups = super().jsonifyResults(ret)
             if matchType == "eq":
```

## astraSDK/hooks.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,25 +21,26 @@
 from .common import SDKCommon
 from .apps import getApps
 
 
 class getHooks(SDKCommon):
     """Get all the execution hooks for every app"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.apps = getApps(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.apps = getApps(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, appFilter=None):
         if self.apps is False:
             print("Call to getApps() failed")
             return False
 
         hooks = {}
@@ -57,15 +58,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 if results is None:
@@ -106,20 +106,21 @@
             print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
         return dataReturn
 
 
 class createHook(SDKCommon):
     """Create an execution hook"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-executionHook+json"
         self.headers["Content-Type"] = "application/astra-executionHook+json"
 
     def main(
         self,
         appID,
         name,
@@ -155,15 +156,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -175,20 +175,21 @@
             return False
 
 
 class destroyHook(SDKCommon):
     """Given an appID and hookID destroy the hook.  Note that this doesn't unmanage
     a hook, it actively destroys it. There is no coming back from this."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-executionHook+json"
         self.headers["Content-Type"] = "application/astra-executionHook+json"
 
     def main(self, appID, hookID):
         # endpoint = f"k8s/v1/apps/{appID}/executionHooks/{hookID}"
         endpoint = f"core/v1/executionHooks/{hookID}"
         url = self.base + endpoint
@@ -201,15 +202,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/k8s.py

```diff
@@ -803,47 +803,54 @@
                 print(json.dumps(resp, default=str) if type(resp) is dict else resp)
             return resp
         except (kubernetes.client.rest.ApiException, urllib3.exceptions.MaxRetryError) as e:
             sys.stdout = sys.__stdout__
             self.printKubeError(e)
 
 
-class createRegCred(KubeCommon, SDKCommon):
+class createRegCred(SDKCommon, KubeCommon):
     """Creates a docker registry credential. By default it uses fields from config.yaml,
     however any of these fields can be overridden by custom values."""
 
     def __init__(
-        self, quiet=True, dry_run=False, verbose=False, config_context=None, skip_tls_verify=False
+        self,
+        quiet=True,
+        dry_run=False,
+        verbose=False,
+        config_context=None,
+        skip_tls_verify=False,
+        config=None,
     ):
         """quiet: Will there be CLI output or just return (datastructure)
         dry-run: False (default):       submit and persist the resource
                  True or non-empty str: submit request without persisting the resource
         verbose: Print all of the rest call info: URL, Method, Headers, Request Body
         config_context: the kubeconfig:context mapping to execute against
                         None: use system defaults
                         str "None:<context>": use default kubeconfig w/ specified context
                         str "<config_file>:<context>": use specified file and context
-        skip_tls_verify: Whether to skip TLS/SSL verification"""
+        skip_tls_verify: Whether to skip TLS/SSL verification
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.dry_run = dry_run
         self.verbose = verbose
         self.config_context = config_context
         self.skip_tls_verify = skip_tls_verify
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, name=None, registry=None, username=None, password=None, namespace="trident"):
         if (not username and password) or (username and not password):
             raise SystemExit(
                 "Either both or neither of (username and password) should be specified"
             )
         if not registry:
             registry = f"cr.{self.conf['domain']}"
         if not username and not password:
             username = self.conf["account_id"]
-            password = self.conf["headers"].get("Authorization").split(" ")[-1]
+            password = self.conf["session"].headers.get("Authorization").split(" ")[-1]
 
         regCred = {
             "auths": {
                 registry: {
                     "username": username,
                     "password": password,
                     "auth": base64.b64encode(f"{username}:{password}".encode("utf-8")).decode(
@@ -872,42 +879,49 @@
             dry_run=self.dry_run,
             verbose=self.verbose,
             config_context=self.config_context,
             skip_tls_verify=self.skip_tls_verify,
         ).main(regCredSecret, namespace=namespace)
 
 
-class createAstraApiToken(KubeCommon, SDKCommon):
+class createAstraApiToken(SDKCommon, KubeCommon):
     """Creates an astra-api-token secret based on the contents of config.yaml"""
 
     def __init__(
-        self, quiet=True, dry_run=False, verbose=False, config_context=None, skip_tls_verify=False
+        self,
+        quiet=True,
+        dry_run=False,
+        verbose=False,
+        config_context=None,
+        skip_tls_verify=False,
+        config=None,
     ):
         """quiet: Will there be CLI output or just return (datastructure)
         dry-run: False (default):       submit and persist the resource
                  True or non-empty str: submit request without persisting the resource
         verbose: Print all of the rest call info: URL, Method, Headers, Request Body
         config_context: the kubeconfig:context mapping to execute against
                         None: use system defaults
                         str "None:<context>": use default kubeconfig w/ specified context
                         str "<config_file>:<context>": use specified file and context
-        skip_tls_verify: Whether to skip TLS/SSL verification"""
+        skip_tls_verify: Whether to skip TLS/SSL verification
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.dry_run = dry_run
         self.verbose = verbose
         self.config_context = config_context
         self.skip_tls_verify = skip_tls_verify
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, name=None, namespace="astra-connector"):
         # Handle case sensitivity
         authorization = (
-            self.conf["headers"].get("Authorization")
-            if self.conf["headers"].get("Authorization")
-            else self.conf["headers"].get("authorization")
+            self.conf["session"].headers.get("Authorization")
+            if self.conf["session"].headers.get("Authorization")
+            else self.conf["session"].headers.get("authorization")
         )
         token = authorization.split(" ")[-1]
         secret = kubernetes.client.V1Secret(
             metadata=(
                 kubernetes.client.V1ObjectMeta(name=name)
                 if name
                 else kubernetes.client.V1ObjectMeta(generate_name="astra-api-token-")
@@ -965,31 +979,38 @@
         ).main(secret, namespace=namespace)
 
 
 class createAstraConnector(SDKCommon):
     """Creates an AstraConnector custom resource"""
 
     def __init__(
-        self, quiet=True, dry_run=False, verbose=False, config_context=None, skip_tls_verify=False
+        self,
+        quiet=True,
+        dry_run=False,
+        verbose=False,
+        config_context=None,
+        skip_tls_verify=False,
+        config=None,
     ):
         """quiet: Will there be CLI output or just return (datastructure)
         dry-run: False (default):       submit and persist the resource
                  True or non-empty str: submit request without persisting the resource
         verbose: Print all of the rest call info: URL, Method, Headers, Request Body
         config_context: the kubeconfig:context mapping to execute against
                         None: use system defaults
                         str "None:<context>": use default kubeconfig w/ specified context
                         str "<config_file>:<context>": use specified file and context
-        skip_tls_verify: Whether to skip TLS/SSL verification"""
+        skip_tls_verify: Whether to skip TLS/SSL verification
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.dry_run = dry_run
         self.verbose = verbose
         self.config_context = config_context
         self.skip_tls_verify = skip_tls_verify
-        super().__init__()
+        super().__init__(config=config)
 
     def main(
         self,
         clusterName,
         cloudID,
         apiToken,
         regCred,
@@ -1002,15 +1023,15 @@
             "kind": "AstraConnector",
             "metadata": {"name": name, "namespace": namespace},
             "spec": {
                 "astra": {
                     "accountId": self.conf["account_id"],
                     "cloudId": cloudID,
                     "clusterName": clusterName,
-                    "skipTLSValidation": not self.conf["verifySSL"],
+                    "skipTLSValidation": not self.conf["session"].verify,
                     "tokenRef": apiToken,
                 },
                 "natsSyncClient": {"cloudBridgeURL": f"https://{self.conf['domain']}"},
                 "imageRegistry": {
                     "name": registry if registry else f"cr.{self.conf['domain']}",
                     "secret": regCred,
                 },
```

## astraSDK/namespaces.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -22,26 +22,29 @@
 
 from .common import SDKCommon
 from .apps import getApps
 from .clusters import getClusters
 
 
 class getNamespaces(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.clusters = getClusters(quiet=True, verbose=verbose).main()
-        self.apps = getApps(quiet=True, verbose=verbose).main() if self.clusters else False
+        super().__init__(config=config)
+        self.clusters = getClusters(quiet=True, verbose=verbose, config=config).main()
+        self.apps = (
+            getApps(quiet=True, verbose=verbose, config=config).main() if self.clusters else False
+        )
 
     def main(
         self,
         clusterID=None,
         nameFilter=None,
         showRemoved=False,
         unassociated=False,
@@ -67,15 +70,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             systemNS = ["kube-node-lease", "kube-public", "kube-system", "trident"]
             namespaces = super().jsonifyResults(ret)
```

## astraSDK/notifications.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -25,24 +25,25 @@
 YELLOW = "\033[33m"
 ENDC = "\033[0m"
 
 
 class getNotifications(SDKCommon):
     """Get all of the notifications in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, limit=None, skip=None, minuteFilter=None, severityFilter=None):
         endpoint = "core/v1/notifications"
         url = self.base + endpoint
 
         data = {}
         params = {"orderBy": "eventTime desc", "count": "true"}
@@ -53,15 +54,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             notifications = super().jsonifyResults(ret)
             notificationsCooked = copy.deepcopy(notifications)
```

## astraSDK/protections.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -22,25 +22,26 @@
 from .apps import getApps
 
 
 class getProtectionpolicies(SDKCommon):
     """Get all the Protection policies (aka backup / snapshot schedules) for each app, unless an
     optional appFilter is passed (can be either app name or app ID, but must be an exact match."""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.apps = getApps(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.apps = getApps(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, appFilter=None, clusterFilter=None):
         if self.apps is False:
             print("Call to getApps() failed")
             return False
 
         protections = {}
@@ -61,15 +62,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 if results is None:
@@ -159,20 +159,21 @@
     need to be set vary based on whether granularity is set to
     hourly, daily, weekly, or monthly
     This class does no validation of the arguments, leaving that
     to the API call itself.  toolkit.py can be used as a guide as to
     what the API requirements are in case the swagger isn't sufficient.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-schedule+json"
         self.headers["Content-Type"] = "application/astra-schedule+json"
 
     def main(
         self,
         granularity,
         backupRetention,
@@ -209,15 +210,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -231,20 +231,21 @@
 
 class updateProtectionpolicy(SDKCommon):
     """Update a protection policy. This class does no validation of the arguments, leaving
     that to the API call itself. tkSrc/update.py can be used as a guide as to what the API
     requirements are in case the swagger isn't sufficient.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["Content-Type"] = "application/astra-schedule+json"
 
     def main(
         self,
         appID,
         protectionID,
         granularity,
@@ -279,15 +280,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -298,20 +298,21 @@
                 super().printError(ret)
             return False
 
 
 class destroyProtectiontionpolicy(SDKCommon):
     """This class destroys a protection policy"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-schedule+json"
         self.headers["Content-Type"] = "application/astra-schedule+json"
 
     def main(self, appID, protectionID):
         endpoint = f"k8s/v1/apps/{appID}/schedules/{protectionID}"
         url = self.base + endpoint
         params = {}
@@ -319,15 +320,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/replications.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -23,25 +23,26 @@
 from .common import SDKCommon
 from .apps import getApps
 
 
 class getReplicationpolicies(SDKCommon):
     """Get all the Replication policies (aka snap mirror / app mirror)"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.apps = getApps(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.apps = getApps(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, appFilter=None):
         if self.apps is False:
             print("Call to getApps() failed")
             return False
 
         endpoint = "k8s/v1/appMirrors"
@@ -52,15 +53,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             replPolicies = super().jsonifyResults(ret)
             # Add custom app name entry
@@ -127,20 +127,21 @@
 class createReplicationpolicy(SDKCommon):
     """Create a replication policy for a source app to a destination cluster.
     This class does no validation of the arguments, leaving that
     to the API call itself.  toolkit.py can be used as a guide as to
     what the API requirements are in case the swagger isn't sufficient.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appMirror+json"
         self.headers["Content-Type"] = "application/astra-appMirror+json"
 
     def main(
         self,
         sourceAppID,
         destinationClusterID,
@@ -163,15 +164,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -186,21 +186,21 @@
 class updateReplicationpolicy(SDKCommon):
     """Update a replication policy.  Intended to reverse, resync, or fail over
     the replication.  This class does no validation of the arguments, leaving
     that to the API call itself.  toolkit.py can be used as a guide as to
     what the API requirements are in case the swagger isn't sufficient.
     """
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
-        # self.headers["accept"] = "application/astra-appMirror+json"
+        super().__init__(config=config)
         self.headers["Content-Type"] = "application/astra-appMirror+json"
 
     def main(
         self,
         replicationID,
         stateDesired,
         sourceAppID=None,
@@ -227,15 +227,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -246,20 +245,21 @@
                 super().printError(ret)
             return False
 
 
 class destroyReplicationpolicy(SDKCommon):
     """This class destroys a replication policy"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appMirror+json"
         self.headers["Content-Type"] = "application/astra-appMirror+json"
 
     def main(self, replicationID):
         endpoint = f"k8s/v1/appMirrors/{replicationID}"
         url = self.base + endpoint
         params = {}
@@ -267,15 +267,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/rolebindings.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,39 +21,39 @@
 
 from .common import SDKCommon
 
 
 class getRolebindings(SDKCommon):
     """Get all the role bindings in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, idFilter=None):
         endpoint = "core/v1/roleBindings"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             rbindings = super().jsonifyResults(ret)
             rbindingsCooked = copy.deepcopy(rbindings)
@@ -80,20 +80,21 @@
                 super().printError(ret)
             return False
 
 
 class createRolebinding(SDKCommon):
     """Create a role binding within the Astra Control account."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-roleBinding+json"
         self.headers["Content-Type"] = "application/astra-roleBinding+json"
 
     def main(
         self,
         role,
         userID=None,
@@ -118,15 +119,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -140,20 +140,21 @@
 
 class destroyRolebinding(SDKCommon):
     """This class destroys a roleBinding.  Use with caution, there's no going back.
 
     Deleting the last role-binding associated with a user with authProvider as 'local',
     or 'cloud-central' triggers the deletion of the user."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-roleBinding+json"
         self.headers["Content-Type"] = "application/astra-roleBinding+json"
 
     def main(self, roleBindingID):
         endpoint = f"core/v1/roleBindings/{roleBindingID}"
         url = self.base + endpoint
         params = {}
@@ -161,15 +162,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/scripts.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -21,39 +21,39 @@
 
 from .common import SDKCommon
 
 
 class getScripts(SDKCommon):
     """Get all the scripts (aka hook sources) for the Astra Control account"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, nameFilter=None):
         endpoint = "core/v1/hookSources"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             scripts = super().jsonifyResults(ret)
             scriptsCooked = copy.deepcopy(scripts)
@@ -80,20 +80,21 @@
                 super().printError(ret)
             return False
 
 
 class createScript(SDKCommon):
     """Create a script (aka hook source)"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-hookSource+json"
         self.headers["Content-Type"] = "application/astra-hookSource+json"
 
     def main(
         self,
         name,
         source,
@@ -114,15 +115,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -134,20 +134,21 @@
             return False
 
 
 class destroyScript(SDKCommon):
     """Given a scriptID destroy the script.  Note that this doesn't unmanage
     a script, it actively destroys it. There is no coming back from this."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-hookSource+json"
         self.headers["Content-Type"] = "application/astra-hookSource+json"
 
     def main(self, scriptID):
         endpoint = f"core/v1/hookSources/{scriptID}"
         url = self.base + endpoint
         params = {}
@@ -158,15 +159,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
@@ -174,20 +174,21 @@
                 super().printError(ret)
             return False
 
 
 class updateScript(SDKCommon):
     """Update a script (aka hook source)"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-hookSource+json"
         self.headers["Content-Type"] = "application/astra-hookSource+json"
 
     def main(
         self,
         scriptID,
         source=None,
@@ -208,15 +209,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             # the scripts/ endpoint doesn't return a dict for PUTs, so calling getScripts
             results = next(s for s in getScripts().main()["items"] if s["id"] == scriptID)
```

## astraSDK/settings.py

```diff
@@ -20,33 +20,33 @@
 from .common import SDKCommon
 
 
 class getSettings(SDKCommon):
     """List the Astra Control settings, which contain UUIDs which are needed to modify any
     of the settings."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self):
         endpoint = "core/v1/settings"
         params = {}
         url = self.base + endpoint
         data = {}
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
                 print(json.dumps(results))
@@ -54,23 +54,21 @@
         else:
             return False
 
 
 class createLdap(SDKCommon):
     """Class to create an LDAP(S) server connection"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
-        output: table: pretty print the data
-                json: (default) output in JSON
-                yaml: output in yaml"""
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-setting+json"
         self.headers["Content-Type"] = "application/astra-setting+json"
 
     def main(
         self,
         settingID,
         host,
@@ -107,15 +105,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
         if ret.ok:
             # the settings/ endpoint doesn't return a dict for PUTs, so calling getSettings
             results = next(x for x in getSettings().main()["items"] if x["id"] == settingID)
             if not self.quiet:
@@ -128,23 +125,21 @@
 class manageLdap(SDKCommon):
     """Class to manage (aka enable) an LDAP(S) server, which uses current LDAP settings but
     switches isEnabled to true. You must pass the 'astra.account.ldap' settingID, and the
     currentConfig of the setting (which can be gathered via getSettings()).
 
     If you're looking to set up an entirely new LDAP connection, use createLdap() instead."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
-        output: table: pretty print the data
-                json: (default) output in JSON
-                yaml: output in yaml"""
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-setting+json"
         self.headers["Content-Type"] = "application/astra-setting+json"
 
     def main(self, settingID, currentConfig):
         currentConfig["isEnabled"] = "true"
         endpoint = f"core/v1/settings/{settingID}"
         url = self.base + endpoint
@@ -157,15 +152,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
         if ret.ok:
             # the settings/ endpoint doesn't return a dict for PUTs, so calling getSettings
             results = next(x for x in getSettings().main()["items"] if x["id"] == settingID)
             if not self.quiet:
@@ -176,23 +170,21 @@
 
 
 class unmanageLdap(SDKCommon):
     """Class to unmanage (aka disable) an LDAP(S) server, which preserves current LDAP settings
     while removing the ability for users/groups to log in. You must pass the 'astra.account.ldap'
     settingID, and the currentConfig of the setting (which can be gathered via getSettings())."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
-        output: table: pretty print the data
-                json: (default) output in JSON
-                yaml: output in yaml"""
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-setting+json"
         self.headers["Content-Type"] = "application/astra-setting+json"
 
     def main(self, settingID, currentConfig):
         currentConfig["isEnabled"] = "false"
         endpoint = f"core/v1/settings/{settingID}"
         url = self.base + endpoint
@@ -205,15 +197,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
         if ret.ok:
             # the settings/ endpoint doesn't return a dict for PUTs, so calling getSettings
             results = next(x for x in getSettings().main()["items"] if x["id"] == settingID)
             if not self.quiet:
@@ -223,23 +214,21 @@
             return False
 
 
 class destroyLdap(SDKCommon):
     """Class to destroy (aka disconnect) an LDAP(S) server, this removes all LDAP(S) settings.
     Destroying the associated service account credential should follow."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
-        output: table: pretty print the data
-                json: (default) output in JSON
-                yaml: output in yaml"""
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-setting+json"
         self.headers["Content-Type"] = "application/astra-setting+json"
 
     def main(self, settingID):
         endpoint = f"core/v1/settings/{settingID}"
         url = self.base + endpoint
         params = {}
@@ -263,15 +252,14 @@
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
         if ret.ok:
             # the settings/ endpoint doesn't return a dict for PUTs, so calling getSettings
             results = next(x for x in getSettings().main()["items"] if x["id"] == settingID)
             if not self.quiet:
```

## astraSDK/snapshots.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -25,25 +25,26 @@
 class getSnaps(SDKCommon):
     """Iterate over every managed app, and list all of it's snapshots.
     Failure reporting is not implimented, failure to list snapshots for
     one (or more) of N many apps just results in an empty list of snapshots
     for that app.
     """
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.apps = getApps(quiet=True, verbose=verbose).main()
+        super().__init__(config=config)
+        self.apps = getApps(quiet=True, verbose=verbose, config=config).main()
 
     def main(self, appFilter=None):
         if self.apps is False:
             if not self.quiet:
                 super().printError("Call to getApps() failed")
             return False
 
@@ -62,15 +63,14 @@
 
             ret = super().apicall(
                 "get",
                 url,
                 data,
                 self.headers,
                 params,
-                self.verifySSL,
                 quiet=self.quiet,
                 verbose=self.verbose,
             )
 
             if ret.ok:
                 results = super().jsonifyResults(ret)
                 if results is None:
@@ -121,20 +121,21 @@
 
 
 class takeSnap(SDKCommon):
     """Take a snapshot of an app.  An AppID and snapName are required and
     either the result JSON is returned or the snapID of the newly created
     backup is returned."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appSnap+json"
         self.headers["Content-Type"] = "application/astra-appSnap+json"
 
     def main(self, appID, snapName):
         endpoint = f"k8s/v1/apps/{appID}/appSnaps"
         url = self.base + endpoint
         params = {}
@@ -146,15 +147,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -166,20 +166,21 @@
             return False
 
 
 class destroySnapshot(SDKCommon):
     """Given an appID and snapID destroy the snapshot.  Note that this doesn't
     unmanage a snapshot, it actively destroys it. There is no coming back from this."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-appSnap+json"
         self.headers["Content-Type"] = "application/astra-appSnap+json"
 
     def main(self, appID, snapID):
         endpoint = f"k8s/v1/apps/{appID}/appSnaps/{snapID}"
         url = self.base + endpoint
         params = {}
@@ -190,15 +191,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
```

## astraSDK/storagebackends.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -20,39 +20,39 @@
 
 from .common import SDKCommon
 
 
 class getStorageBackends(SDKCommon):
     """Get all of the storageBackends in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self):
         endpoint = "topology/v1/storageBackends"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             backends = super().jsonifyResults(ret)
             if self.output == "json":
```

## astraSDK/storageclasses.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -20,26 +20,29 @@
 
 from .common import SDKCommon
 from .clouds import getClouds
 from .clusters import getClusters
 
 
 class getStorageClasses(SDKCommon):
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
-        self.clouds = getClouds(quiet=True, verbose=verbose).main()
-        self.clusters = getClusters(quiet=True, verbose=verbose).main() if self.clouds else False
+        super().__init__(config=config)
+        self.clouds = getClouds(quiet=True, verbose=verbose, config=config).main()
+        self.clusters = (
+            getClusters(quiet=True, verbose=verbose, config=config).main() if self.clouds else False
+        )
 
     def main(self, cloudType=None, clusterStr=None, hideUnmanaged=False):
         if self.clouds is False:
             print("getClouds().main() failed")
             return False
         elif self.clusters is False:
             print("getClusters().main() failed")
@@ -77,15 +80,14 @@
 
                 ret = super().apicall(
                     "get",
                     url,
                     data,
                     self.headers,
                     params,
-                    self.verifySSL,
                     quiet=self.quiet,
                     verbose=self.verbose,
                 )
 
                 if ret.ok:
                     results = super().jsonifyResults(ret)
                     if results is None:
```

## astraSDK/users.py

```diff
@@ -25,39 +25,39 @@
 YELLOW = "\033[33m"
 ENDC = "\033[0m"
 
 
 class getUsers(SDKCommon):
     """Get all the users in Astra Control"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(self, nameFilter=None):
         endpoint = "core/v1/users"
         url = self.base + endpoint
 
         data = {}
         params = {}
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             users = super().jsonifyResults(ret)
             # Add custom fullName entry
@@ -94,20 +94,21 @@
 
 
 class createUser(SDKCommon):
     """Create a user within the Astra Control account.  This class does not do argument
     verification, please reference toolkit.py which has proper guardrails (primarily
     around the differences between Astra Control Center and Service)."""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-user+json"
         self.headers["Content-Type"] = "application/astra-user+json"
 
     def main(
         self,
         email,
         firstName=None,
@@ -137,15 +138,14 @@
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
@@ -156,20 +156,21 @@
                 super().printError(ret)
             return False
 
 
 class destroyUser(SDKCommon):
     """Destroys a users (this class is only required to be called for LDAP-based users)"""
 
-    def __init__(self, quiet=True, verbose=False):
+    def __init__(self, quiet=True, verbose=False, config=None):
         """quiet: Will there be CLI output or just return (datastructure)
-        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
+        verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
-        super().__init__()
+        super().__init__(config=config)
         self.headers["accept"] = "application/astra-user+json"
         self.headers["Content-Type"] = "application/astra-user+json"
 
     def main(self, userID):
         endpoint = f"core/v1/users/{userID}"
         url = self.base + endpoint
         params = {}
@@ -180,15 +181,14 @@
 
         ret = super().apicall(
             "delete",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             return True
         else:
@@ -196,24 +196,25 @@
                 super().printError(ret)
             return False
 
 
 class getLdapUsers(SDKCommon):
     """Query LDAP for a list of users"""
 
-    def __init__(self, quiet=True, verbose=False, output="json"):
+    def __init__(self, quiet=True, verbose=False, output="json", config=None):
         """quiet: Will there be CLI output or just return (datastructure)
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body
         output: table: pretty print the data
                 json: (default) output in JSON
-                yaml: output in yaml"""
+                yaml: output in yaml
+        config: optionally provide a pre-populated common.getConfig().main() object"""
         self.quiet = quiet
         self.verbose = verbose
         self.output = output
-        super().__init__()
+        super().__init__(config=config)
 
     def main(
         self,
         emailFilter=None,
         firstNameFilter=None,
         lastNameFilter=None,
         cnFilter=None,
@@ -243,15 +244,14 @@
 
         ret = super().apicall(
             "get",
             url,
             data,
             self.headers,
             params,
-            self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             users = super().jsonifyResults(ret)
```

## tkSrc/__init__.py

```diff
@@ -1,9 +1,9 @@
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## tkSrc/choices.py

```diff
@@ -22,15 +22,15 @@
 import astraSDK
 from tkSrc import helpers
 
 RED = "\033[31m"
 ENDC = "\033[0m"
 
 
-def main(argv, verbs, verbPosition, ard, acl, v3, v3_skip_tls_verify=False):
+def main(argv, verbs, verbPosition, ard, acl, v3, v3_skip_tls_verify=False, config=None):
     """This function builds the argparse choices lists. To build these lists, a variety of external
     calls need to be made. The results of these calls are stored in ard (an instantiation of
     AstraResourceDicts) so the same call doesn't have to be made again later. The choices lists are
     stored in acl (an instantiation of ArgparseChoicesLists)"""
 
     if verbs["deploy"]:
         # This expression translates to "Is there an arg after the verb we found?"
@@ -84,31 +84,31 @@
                         break
             else:
                 ard.storageClasses = astraSDK.k8s.getStorageClasses(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main()
                 acl.storageClasses = ard.buildList("storageClasses", "metadata.name")
         else:
-            ard.apps = astraSDK.apps.getApps().main()
+            ard.apps = astraSDK.apps.getApps(config=config).main()
             acl.apps = ard.buildList("apps", "id")
-            ard.destClusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
+            ard.destClusters = astraSDK.clusters.getClusters(config=config).main(hideUnmanaged=True)
             acl.destClusters = ard.buildList("destClusters", "id")
             if verbs["restore"]:
-                ard.backups = astraSDK.backups.getBackups().main()
-                ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                ard.backups = astraSDK.backups.getBackups(config=config).main()
+                ard.snapshots = astraSDK.snapshots.getSnaps(config=config).main()
                 acl.dataProtections = ard.buildList("backups", "id") + ard.buildList(
                     "snapshots", "id"
                 )
             # if the destination cluster has been specified, only show those storage classes
             if (clusterID := list(set(argv) & set(acl.destClusters))) and len(clusterID) == 1:
-                ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main(
+                ard.storageClasses = astraSDK.storageclasses.getStorageClasses(config=config).main(
                     clusterStr=clusterID[0], hideUnmanaged=True
                 )
             else:
-                ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main(
+                ard.storageClasses = astraSDK.storageclasses.getStorageClasses(config=config).main(
                     hideUnmanaged=True
                 )
             acl.storageClasses = list(set(ard.buildList("storageClasses", "name")))
 
     elif verbs["ipr"]:
         if v3:
             ard.apps = astraSDK.k8s.getResources(
@@ -126,19 +126,19 @@
                     acl.backups += ard.buildList(
                         "backups", "metadata.name", "spec.applicationRef", a
                     )
                     acl.snapshots += ard.buildList(
                         "snapshots", "metadata.name", "spec.applicationRef", a
                     )
         else:
-            ard.apps = astraSDK.apps.getApps().main()
+            ard.apps = astraSDK.apps.getApps(config=config).main()
             acl.apps = ard.buildList("apps", "id")
             if len(argv) - verbPosition >= 2:
-                ard.backups = astraSDK.backups.getBackups().main()
-                ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                ard.backups = astraSDK.backups.getBackups(config=config).main()
+                ard.snapshots = astraSDK.snapshots.getSnaps(config=config).main()
                 for a in argv[verbPosition + 1 :]:
                     acl.backups += ard.buildList("backups", "id", "appID", a)
                     acl.snapshots += ard.buildList("snapshots", "id", "appID", a)
 
     elif verbs["create"] and len(argv) - verbPosition >= 2:
         if (
             argv[verbPosition + 1] == "backup"
@@ -151,103 +151,107 @@
         ):
             if v3:
                 ard.apps = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main("applications")
                 acl.apps = ard.buildList("apps", "metadata.name")
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
             if argv[verbPosition + 1] == "backup" or argv[verbPosition + 1] == "snapshot":
                 if v3:
                     ard.buckets = astraSDK.k8s.getResources(
                         config_context=v3, skip_tls_verify=v3_skip_tls_verify
                     ).main("appvaults")
                     acl.buckets = ard.buildList("buckets", "metadata.name")
                 else:
-                    ard.buckets = astraSDK.buckets.getBuckets(quiet=True).main()
+                    ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
                     acl.buckets = ard.buildList("buckets", "id")
                 # Generate acl.snapshots if an app was provided
                 if argv[verbPosition + 1] == "backup":
                     for a in argv[verbPosition + 1 :]:
                         if a in acl.apps:
                             if v3:
                                 ard.snapshots = astraSDK.k8s.getResources(
                                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                                 ).main(
                                     "snapshots",
                                     filters=[{"keyFilter": "spec.applicationRef", "valFilter": a}],
                                 )
                                 acl.snapshots = ard.buildList("snapshots", "metadata.name")
                             else:
-                                ard.snapshots = astraSDK.snapshots.getSnaps().main(appFilter=a)
+                                ard.snapshots = astraSDK.snapshots.getSnaps(config=config).main(
+                                    appFilter=a
+                                )
                                 acl.snapshots = ard.buildList("snapshots", "id")
             if argv[verbPosition + 1] == "hook" or argv[verbPosition + 1] == "exechook":
                 if not v3:
-                    ard.scripts = astraSDK.scripts.getScripts().main()
+                    ard.scripts = astraSDK.scripts.getScripts(config=config).main()
                     acl.scripts = ard.buildList("scripts", "id")
             if argv[verbPosition + 1] == "protection" or argv[verbPosition + 1] == "schedule":
                 if v3:
                     ard.buckets = astraSDK.k8s.getResources(
                         config_context=v3, skip_tls_verify=v3_skip_tls_verify
                     ).main("appvaults")
                     acl.buckets = ard.buildList("buckets", "metadata.name")
                 else:
-                    ard.buckets = astraSDK.buckets.getBuckets().main()
+                    ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
                     acl.buckets = ard.buildList("buckets", "id")
             if argv[verbPosition + 1] == "replication":
-                ard.destClusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
+                ard.destClusters = astraSDK.clusters.getClusters(config=config).main(
+                    hideUnmanaged=True
+                )
                 acl.destClusters = ard.buildList("destClusters", "id")
-                ard.storageClasses = astraSDK.storageclasses.getStorageClasses(quiet=True).main()
+                ard.storageClasses = astraSDK.storageclasses.getStorageClasses(config=config).main()
                 acl.storageClasses = ard.buildList("storageClasses", "name")
                 acl.storageClasses = list(set(acl.storageClasses))
         elif argv[verbPosition + 1] == "cluster":
-            ard.clouds = astraSDK.clouds.getClouds().main()
+            ard.clouds = astraSDK.clouds.getClouds(config=config).main()
             for cloud in ard.clouds["items"]:
                 if cloud["cloudType"] not in ["GCP", "Azure", "AWS"]:
                     acl.clouds.append(cloud["id"])
             # Add a private cloud if it doesn't already exist
             if len(acl.clouds) == 0:
-                rc = astraSDK.clouds.manageCloud(quiet=True).main("private", "private")
+                rc = astraSDK.clouds.manageCloud(config=config).main("private", "private")
                 if rc:
                     acl.clouds.append(rc["id"])
         elif argv[verbPosition + 1] == "user" or argv[verbPosition + 1] == "group":
-            ard.namespaces = astraSDK.namespaces.getNamespaces().main()
+            ard.namespaces = astraSDK.namespaces.getNamespaces(config=config).main()
             for namespace in ard.namespaces["items"]:
                 acl.namespaces.append(namespace["id"])
                 if namespace.get("kubernetesLabels"):
                     for label in namespace["kubernetesLabels"]:
                         labelString = label["name"]
                         if label.get("value"):
                             labelString += "=" + label["value"]
                         acl.labels.append(labelString)
             acl.labels = list(set(acl.labels))
 
     elif verbs["copy"]:
-        ard.apps = astraSDK.apps.getApps().main()
+        ard.apps = astraSDK.apps.getApps(config=config).main()
         acl.apps = ard.buildList("apps", "id")
         if len(argv) - verbPosition > 2 and argv[verbPosition + 2] in acl.apps:
             acl.destApps = [x for x in acl.apps if x != argv[verbPosition + 2]]
         else:
             acl.destApps = [x for x in acl.apps]
 
     elif verbs["list"] and len(argv) - verbPosition >= 2:
         if argv[verbPosition + 1] == "assets":
-            ard.apps = astraSDK.apps.getApps().main()
+            ard.apps = astraSDK.apps.getApps(config=config).main()
             acl.apps = ard.buildList("apps", "id")
 
     elif (verbs["manage"] or verbs["define"]) and len(argv) - verbPosition >= 2:
         if argv[verbPosition + 1] == "app" or argv[verbPosition + 1] == "application":
             if v3:
                 ard.namespaces = astraSDK.k8s.getNamespaces(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main()
                 acl.namespaces = ard.buildList("namespaces", "metadata.name")
             else:
-                ard.namespaces = astraSDK.namespaces.getNamespaces().main()
+                ard.namespaces = astraSDK.namespaces.getNamespaces(config=config).main()
                 acl.namespaces = ard.buildList("namespaces", "name")
                 acl.clusters = ard.buildList("namespaces", "clusterID")
                 acl.clusters = list(set(acl.clusters))
         elif argv[verbPosition + 1] == "bucket" or argv[verbPosition + 1] == "appVault":
             if v3:
                 ard.credentials = astraSDK.k8s.getSecrets(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
@@ -258,15 +262,15 @@
                         for d in ard.buildList("credentials", "data", fKey="metadata.name", fVal=c):
                             for i in d:
                                 acl.keys.append(i)
                 if not acl.keys:
                     acl.keys = [i for d in ard.buildList("credentials", "data") for i in d]
                 acl.keys = list(set(acl.keys))
             else:
-                ard.credentials = astraSDK.credentials.getCredentials().main()
+                ard.credentials = astraSDK.credentials.getCredentials(config=config).main()
                 if ard.credentials:
                     for credential in ard.credentials["items"]:
                         if credential["metadata"].get("labels"):
                             credID = None
                             if credential.get("keyType") == "s3":
                                 credID = credential["id"]
                             else:
@@ -284,40 +288,42 @@
                                 acl.credentials.append(credential["id"])
         elif argv[verbPosition + 1] == "cluster":
             if v3:
                 if "--headless" in argv:
                     acl.clouds.append("123")
                 else:
                     try:
-                        ard.clouds = astraSDK.clouds.getClouds().main()
+                        ard.clouds = astraSDK.clouds.getClouds(config=config).main()
                         if ard.clouds and ard.clouds.get("items"):
                             for cloud in ard.clouds["items"]:
                                 if cloud["cloudType"] not in ["GCP", "Azure", "AWS"]:
                                     acl.clouds.append(cloud["id"])
                         # Add a private cloud if it doesn't already exist
                         if len(acl.clouds) == 0:
-                            rc = astraSDK.clouds.manageCloud(quiet=True).main("private", "private")
+                            rc = astraSDK.clouds.manageCloud(config=config).main(
+                                "private", "private"
+                            )
                             if rc:
                                 acl.clouds.append(rc["id"])
                     except SystemExit:
                         pass
                 ard.credentials = astraSDK.k8s.getSecrets(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main()
                 acl.credentials = ard.buildList("credentials", "metadata.name")
             else:
-                ard.clusters = astraSDK.clusters.getClusters().main()
+                ard.clusters = astraSDK.clusters.getClusters(config=config).main()
                 acl.clusters = ard.buildList(
                     "clusters", "id", fKey="managedState", fVal="unmanaged"
                 )
-                ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main()
+                ard.storageClasses = astraSDK.storageclasses.getStorageClasses(config=config).main()
                 for a in argv[verbPosition + 2 :]:
                     acl.storageClasses += ard.buildList("storageClasses", "id", "clusterID", a)
         elif argv[verbPosition + 1] == "cloud":
-            ard.buckets = astraSDK.buckets.getBuckets().main()
+            ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             acl.buckets = ard.buildList("buckets", "id")
 
     elif verbs["destroy"] and len(argv) - verbPosition >= 2:
         if argv[verbPosition + 1] == "backup" and len(argv) - verbPosition >= 3:
             if v3:
                 ard.apps = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
@@ -329,36 +335,36 @@
                 acl.backups = ard.buildList(
                     "backups",
                     "metadata.name",
                     fKey="spec.applicationRef",
                     fVal=argv[verbPosition + 2],
                 )
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
-                ard.backups = astraSDK.backups.getBackups().main()
+                ard.backups = astraSDK.backups.getBackups(config=config).main()
                 acl.backups = ard.buildList(
                     "backups", "id", fKey="appID", fVal=argv[verbPosition + 2]
                 )
         elif argv[verbPosition + 1] == "cluster" and len(argv) - verbPosition >= 3:
-            ard.clusters = astraSDK.clusters.getClusters().main()
+            ard.clusters = astraSDK.clusters.getClusters(config=config).main()
             acl.clusters = ard.buildList("clusters", "id", fKey="managedState", fVal="unmanaged")
         elif (argv[verbPosition + 1] == "credential" or argv[verbPosition + 1] == "secret") and len(
             argv
         ) - verbPosition >= 3:
             if v3:
                 ard.credentials = astraSDK.k8s.getSecrets(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main()
                 acl.credentials = ard.buildList("credentials", "metadata.name")
             else:
-                ard.credentials = astraSDK.credentials.getCredentials().main()
+                ard.credentials = astraSDK.credentials.getCredentials(config=config).main()
                 acl.credentials = ard.buildList("credentials", "id")
         elif argv[verbPosition + 1] == "group" and len(argv) - verbPosition >= 3:
-            ard.groups = astraSDK.groups.getGroups().main()
+            ard.groups = astraSDK.groups.getGroups(config=config).main()
             acl.groups = ard.buildList("groups", "id")
         elif (argv[verbPosition + 1] == "hook" or argv[verbPosition + 1] == "exechook") and len(
             argv
         ) - verbPosition >= 3:
             if v3:
                 ard.apps = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
@@ -370,17 +376,17 @@
                 acl.hooks = ard.buildList(
                     "hooks",
                     "metadata.name",
                     fKey="spec.applicationRef",
                     fVal=argv[verbPosition + 2],
                 )
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
-                ard.hooks = astraSDK.hooks.getHooks().main()
+                ard.hooks = astraSDK.hooks.getHooks(config=config).main()
                 acl.hooks = ard.buildList("hooks", "id", fKey="appID", fVal=argv[verbPosition + 2])
         elif (
             argv[verbPosition + 1] == "protection" or argv[verbPosition + 1] == "schedule"
         ) and len(argv) - verbPosition >= 3:
             if v3:
                 ard.apps = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
@@ -392,22 +398,22 @@
                 acl.protections = ard.buildList(
                     "protections",
                     "metadata.name",
                     fKey="spec.applicationRef",
                     fVal=argv[verbPosition + 2],
                 )
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
-                ard.protections = astraSDK.protections.getProtectionpolicies().main()
+                ard.protections = astraSDK.protections.getProtectionpolicies(config=config).main()
                 acl.protections = ard.buildList(
                     "protections", "id", fKey="appID", fVal=argv[verbPosition + 2]
                 )
         elif argv[verbPosition + 1] == "replication" and len(argv) - verbPosition >= 3:
-            ard.replications = astraSDK.replications.getReplicationpolicies().main()
+            ard.replications = astraSDK.replications.getReplicationpolicies(config=config).main()
             if not ard.replications:  # Gracefully handle ACS env
                 raise SystemExit(
                     "Error: 'replication' commands are currently only supported in ACC."
                 )
             acl.replications = ard.buildList("replications", "id")
         elif argv[verbPosition + 1] == "snapshot" and len(argv) - verbPosition >= 3:
             if v3:
@@ -421,119 +427,119 @@
                 acl.snapshots = ard.buildList(
                     "snapshots",
                     "metadata.name",
                     fKey="spec.applicationRef",
                     fVal=argv[verbPosition + 2],
                 )
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
-                ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                ard.snapshots = astraSDK.snapshots.getSnaps(config=config).main()
                 acl.snapshots = ard.buildList(
                     "snapshots", "id", fKey="appID", fVal=argv[verbPosition + 2]
                 )
         elif argv[verbPosition + 1] == "script" and len(argv) - verbPosition >= 3:
-            ard.scripts = astraSDK.scripts.getScripts().main()
+            ard.scripts = astraSDK.scripts.getScripts(config=config).main()
             acl.scripts = ard.buildList("scripts", "id")
         elif argv[verbPosition + 1] == "user" and len(argv) - verbPosition >= 3:
-            ard.users = astraSDK.users.getUsers().main()
+            ard.users = astraSDK.users.getUsers(config=config).main()
             acl.users = ard.buildList("users", "id")
 
     elif verbs["unmanage"] and len(argv) - verbPosition >= 2:
         if argv[verbPosition + 1] == "app" or argv[verbPosition + 1] == "application":
             if v3:
                 ard.apps = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main("applications")
                 acl.apps = ard.buildList("apps", "metadata.name")
             else:
-                ard.apps = astraSDK.apps.getApps().main()
+                ard.apps = astraSDK.apps.getApps(config=config).main()
                 acl.apps = ard.buildList("apps", "id")
         elif argv[verbPosition + 1] == "bucket" or argv[verbPosition + 1] == "appVault":
             if v3:
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main("appvaults")
                 acl.buckets = ard.buildList("buckets", "metadata.name")
             else:
-                ard.buckets = astraSDK.buckets.getBuckets().main()
+                ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
                 acl.buckets = ard.buildList("buckets", "id")
         elif argv[verbPosition + 1] == "cluster":
             if v3:
                 ard.connectors = astraSDK.k8s.getResources(
                     config_context=v3, skip_tls_verify=v3_skip_tls_verify
                 ).main("astraconnectors", version="v1", group="astra.netapp.io")
                 acl.clusters = ard.buildList("connectors", "spec.astra.clusterId") + ard.buildList(
                     "connectors", "spec.astra.clusterName"
                 )
             else:
-                ard.clusters = astraSDK.clusters.getClusters().main()
+                ard.clusters = astraSDK.clusters.getClusters(config=config).main()
                 acl.clusters = ard.buildList("clusters", "id", fKey="managedState", fVal="managed")
         elif argv[verbPosition + 1] == "cloud":
-            ard.clouds = astraSDK.clouds.getClouds().main()
+            ard.clouds = astraSDK.clouds.getClouds(config=config).main()
             acl.clouds = ard.buildList("clouds", "id")
 
     elif verbs["update"] and len(argv) - verbPosition >= 2:
         if argv[verbPosition + 1] == "bucket" or argv[verbPosition + 1] == "appVault":
-            ard.buckets = astraSDK.buckets.getBuckets().main()
+            ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             acl.buckets = ard.buildList("buckets", "id")
-            ard.credentials = astraSDK.credentials.getCredentials().main()
+            ard.credentials = astraSDK.credentials.getCredentials(config=config).main()
             for credential in ard.credentials["items"]:
                 if credential["metadata"].get("labels"):
                     credID = None
                     if credential.get("keyType") == "s3":
                         credID = credential["id"]
                     else:
                         for label in credential["metadata"]["labels"]:
                             if label["name"] == "astra.netapp.io/labels/read-only/credType":
                                 if label["value"] in ["AzureContainer", "service-account"]:
                                     credID = credential["id"]
                     if credID:
                         acl.credentials.append(credential["id"])
         elif argv[verbPosition + 1] == "cloud":
-            ard.buckets = astraSDK.buckets.getBuckets().main()
+            ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             acl.buckets = ard.buildList("buckets", "id")
-            ard.clouds = astraSDK.clouds.getClouds().main()
+            ard.clouds = astraSDK.clouds.getClouds(config=config).main()
             acl.clouds = ard.buildList("clouds", "id")
-            ard.credentials = astraSDK.credentials.getCredentials().main()
+            ard.credentials = astraSDK.credentials.getCredentials(config=config).main()
             for credential in ard.credentials["items"]:
                 if credential["metadata"].get("labels"):
                     credID = None
                     if credential.get("keyType") == "s3":
                         credID = credential["id"]
                     else:
                         for label in credential["metadata"]["labels"]:
                             if label["name"] == "astra.netapp.io/labels/read-only/credType":
                                 if label["value"] in ["AzureContainer", "service-account"]:
                                     credID = credential["id"]
                     if credID:
                         acl.credentials.append(credential["id"])
         elif argv[verbPosition + 1] == "cluster":
-            ard.buckets = astraSDK.buckets.getBuckets().main()
+            ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             acl.buckets = ard.buildList("buckets", "id")
-            ard.clusters = astraSDK.clusters.getClusters().main()
+            ard.clusters = astraSDK.clusters.getClusters(config=config).main()
             # If we're updating a default bucket, only allow managed clusters
             if len(set(argv[verbPosition + 2 :]) & set(acl.buckets)) > 0:
                 acl.clusters = ard.buildList("clusters", "id", fKey="managedState", fVal="managed")
             else:
                 acl.clusters = ard.buildList("clusters", "id")
         elif argv[verbPosition + 1] == "protection":
-            ard.protections = astraSDK.protections.getProtectionpolicies().main()
+            ard.protections = astraSDK.protections.getProtectionpolicies(config=config).main()
             acl.protections = ard.buildList("protections", "id")
-            ard.buckets = astraSDK.buckets.getBuckets().main()
+            ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             acl.buckets = ard.buildList("buckets", "id")
         elif argv[verbPosition + 1] == "replication":
-            ard.replications = astraSDK.replications.getReplicationpolicies().main()
+            ard.replications = astraSDK.replications.getReplicationpolicies(config=config).main()
             if not ard.replications:  # Gracefully handle ACS env
                 raise SystemExit(
                     "Error: 'replication' commands are currently only supported in ACC."
                 )
             acl.replications = ard.buildList("replications", "id")
         elif argv[verbPosition + 1] == "script":
-            ard.scripts = astraSDK.scripts.getScripts().main()
+            ard.scripts = astraSDK.scripts.getScripts(config=config).main()
             acl.scripts = ard.buildList("scripts", "id")
 
 
 def kube_config(argv, acl, verbPosition, v3Position, global_args):
     """This method completes two key actions:
     A) Generates the argparse choices list (acl) for the possible kubeconfig "contexts"
     B) Transparently modifies argv to enable very simple inputs for the user, but also allowing
```

## tkSrc/clone.py

```diff
@@ -38,19 +38,20 @@
     sourceAppID,
     resourceFilter,
     pollTimer=5,
     background=False,
     verb="restore",
     verbose=False,
     quiet=False,
+    config=None,
 ):
     """Create a clone/restore."""
     # Check to see if cluster-level resources are needed to be manually created
     needsIngressclass = False
-    appAssets = astraSDK.apps.getAppAssets(verbose=verbose).main(oApp["id"])
+    appAssets = astraSDK.apps.getAppAssets(verbose=verbose, config=config).main(oApp["id"])
     for asset in appAssets["items"]:
         if (
             "nginx-ingress-controller" in asset["assetName"]
             or "ingress-nginx-controller" in asset["assetName"]
         ) and asset["assetType"] == "Pod":
             needsIngressclass = True
             assetName = asset["assetName"]
@@ -58,15 +59,15 @@
                 cloneNamespace = asset["namespace"]
             else:
                 for nsm in namespaceMapping:
                     if nsm["source"] == asset["namespace"]:
                         cloneNamespace = nsm["destination"]
     # Clone 'ingressclass' cluster object
     if needsIngressclass and oApp["clusterID"] != clusterID:
-        clusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
+        clusters = astraSDK.clusters.getClusters(config=config).main(hideUnmanaged=True)
         contexts, _ = kubernetes.config.list_kube_config_contexts()
         # Loop through clusters and contexts, find matches and open api_client
         for cluster in clusters["items"]:
             for context in contexts:
                 if cluster["id"] == clusterID:
                     if cluster["name"] in context["name"]:
                         destClient = kubernetes.client.NetworkingV1Api(
@@ -176,15 +177,15 @@
         except kubernetes.client.rest.ApiException as e:
             # If the failure is due to the resource already existing, then we're all set,
             # otherwise it's more serious and we must raise an exception
             body = json.loads(e.body)
             if not (body.get("reason") == "AlreadyExists"):
                 raise SystemExit(f"Error: Kubernetes resource creation failed\n{e}")
 
-    cloneRet = astraSDK.apps.cloneApp(verbose=verbose, quiet=quiet).main(
+    cloneRet = astraSDK.apps.cloneApp(verbose=verbose, quiet=quiet, config=config).main(
         newAppName,
         clusterID,
         oApp["clusterID"],
         namespaceMapping=namespaceMapping,
         cloneStorageClass=newStorageClass,
         backupID=backupID,
         snapshotID=snapshotID,
@@ -197,15 +198,15 @@
             print(f"Background {verb} flag selected, run 'list apps' to get status.")
             return True
         print(f"Waiting for {verb} to become available", end="")
         sys.stdout.flush()
         appID = cloneRet.get("id")
         state = cloneRet.get("state")
         while state != "ready":
-            apps = astraSDK.apps.getApps().main()
+            apps = astraSDK.apps.getApps(config=config).main()
             for app in apps["items"]:
                 if app["id"] == appID:
                     if app["state"] == "ready":
                         state = app["state"]
                         print(f"{verb[:-1]}ing operation complete.")
                         sys.stdout.flush()
                     elif app["state"] == "failed":
@@ -485,15 +486,15 @@
         rName = restoreSourceDict["metadata"]["name"]
         helpers.parserError(
             f"{err} key not found in '{rName}' object, please ensure "
             f"{rName}' is a valid backup/snapshot"
         )
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     # Ensure proper use of resource filters
     if args.subcommand == "restore":
         if (args.filterSelection and not args.filterSet) or (
             args.filterSet and not args.filterSelection
         ):
             helpers.parserError(
                 "either both or none of --filterSelection and --filterSet should be specified"
@@ -545,15 +546,15 @@
                 multiNsMapping=args.multiNsMapping,
                 filterSelection=args.filterSelection,
                 filterSet=args.filterSet,
             )
 
     else:
         if ard.needsattr("apps"):
-            ard.apps = astraSDK.apps.getApps().main()
+            ard.apps = astraSDK.apps.getApps(config=config).main()
         # Get the original app dictionary based on args.sourceApp/args.restoreSource,
         # as the app dict contains sourceCluster and namespaceScopedResources which we need
         oApp = {}
         backup = None
         snapshot = None
         if args.subcommand == "clone":
             # There are certain args that aren't available for live clones, set those to None
@@ -561,17 +562,17 @@
             args.filterSet = None
             for app in ard.apps["items"]:
                 if app["id"] == args.sourceApp:
                     oApp = app
         elif args.subcommand == "restore":
             args.sourceApp = None
             if ard.needsattr("backups"):
-                ard.backups = astraSDK.backups.getBackups().main()
+                ard.backups = astraSDK.backups.getBackups(config=config).main()
             if ard.needsattr("snapshots"):
-                ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                ard.snapshots = astraSDK.snapshots.getSnaps(config=config).main()
             if args.restoreSource in ard.buildList("backups", "id"):
                 dataProtections = ard.backups
                 backup = args.restoreSource
             elif args.restoreSource in ard.buildList("snapshots", "id"):
                 dataProtections = ard.snapshots
                 snapshot = args.restoreSource
             else:
@@ -599,15 +600,16 @@
             args.newStorageClass,
             backup,
             snapshot,
             args.sourceApp,
             helpers.createFilterSet(
                 args.filterSelection,
                 args.filterSet,
-                astraSDK.apps.getAppAssets().main(oApp["id"]),
+                astraSDK.apps.getAppAssets(config=config).main(oApp["id"]),
             ),
             pollTimer=args.pollTimer,
             background=args.background,
             verb=args.subcommand,
             verbose=args.verbose,
             quiet=args.quiet,
+            config=config,
         )
```

## tkSrc/copy.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -14,34 +14,36 @@
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import astraSDK
 
 
-def main(args):
+def main(args, config=None):
     if args.objectType == "hooks":
-        for hook in astraSDK.hooks.getHooks().main(appFilter=args.sourceApp)["items"]:
-            rc = astraSDK.hooks.createHook(quiet=args.quiet, verbose=args.verbose).main(
+        for hook in astraSDK.hooks.getHooks(config=config).main(appFilter=args.sourceApp)["items"]:
+            rc = astraSDK.hooks.createHook(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 args.destinationApp,
                 hook["name"],
                 hook["hookSourceID"],
                 hook["stage"],
                 hook["action"],
                 hook["arguments"],
                 hook["matchingCriteria"],
             )
             if rc is False:
                 raise SystemExit("astraSDK.hooks.createHook() failed")
     elif args.objectType == "protections":
-        for protection in astraSDK.protections.getProtectionpolicies().main(
+        for protection in astraSDK.protections.getProtectionpolicies(config=config).main(
             appFilter=args.sourceApp
         )["items"]:
             rc = astraSDK.protections.createProtectionpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 protection["granularity"],
                 protection["backupRetention"],
                 protection["snapshotRetention"],
                 protection.get("dayOfWeek"),
                 protection.get("dayOfMonth"),
                 protection.get("hour"),
```

## tkSrc/create.py

```diff
@@ -22,22 +22,22 @@
 import time
 import yaml
 
 import astraSDK
 from tkSrc import helpers
 
 
-def monitorProtectionTask(protectionID, protectionType, appID, background, pollTimer):
+def monitorProtectionTask(protectionID, protectionType, appID, background, pollTimer, config=None):
     """Ensure backup/snapshot task was created successfully, then monitor"""
     if protectionID is False:
         return False
     if protectionType == "backup":
-        protection_class = astraSDK.backups.getBackups()
+        protection_class = astraSDK.backups.getBackups(config=config)
     elif protectionType == "snapshot":
-        protection_class = astraSDK.snapshots.getSnaps()
+        protection_class = astraSDK.snapshots.getSnaps(config=config)
     else:
         helpers.parserError(f"unknown protection type: {protectionType}")
 
     print(f"Starting {protectionType} of {appID}")
     if background:
         print(
             f"Background {protectionType} flag selected, run 'list {protectionType}s' to get status"
@@ -118,19 +118,19 @@
         f"kubectl --insecure-skip-tls-verify={skip_tls_verify} --context={context} "
         f"-v={6 if verbose else 0} apply --dry_run={dry_run if dry_run else 'none'} -f "
         f"{helpers.getOperatorURL(operator_version)}",
         env={"KUBECONFIG": os.path.expanduser(config_file)} if config_file != "None" else None,
     )
 
 
-def createCloudCredential(quiet, verbose, path, name, cloudType):
+def createCloudCredential(quiet, verbose, path, name, cloudType, config=None):
     """Create a public cloud (AWS/Azure/GCP) credential via the API"""
     credDict = helpers.openJson(path)
     encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
-    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose).main(
+    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose, config=config).main(
         "astra-sa@" + name,
         "service-account",
         {"base64": encodedStr},
         cloudType,
     )
     if rc:
         return rc
@@ -159,33 +159,33 @@
         dry_run=dry_run,
         verbose=verbose,
         config_context=v3,
         skip_tls_verify=skip_tls_verify,
     ).main(f"{name}-", data, generateName=True, namespace=namespace)
 
 
-def createLdapCredential(quiet, verbose, username, password):
+def createLdapCredential(quiet, verbose, username, password, config=None):
     """Create an LDAP bind credential via the API"""
     bindDn = base64.b64encode(username.encode("utf-8")).decode("utf-8")
     enpass = base64.b64encode(password.encode("utf-8")).decode("utf-8")
-    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose).main(
+    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose, config=config).main(
         "ldapBindCredential-" + username.split("@")[0],
         "generic",
         {"bindDn": bindDn, "password": enpass},
     )
     if rc:
         return rc
     raise SystemExit("astraSDK.credentials.createCredential() failed")
 
 
-def createS3Credential(quiet, verbose, accessKey, accessSecret, name):
+def createS3Credential(quiet, verbose, accessKey, accessSecret, name, config=None):
     """Create an S3 (accessKey and accessSecret) bucket credential via the API"""
     encodedKey = base64.b64encode(accessKey.encode("utf-8")).decode("utf-8")
     encodedSecret = base64.b64encode(accessSecret.encode("utf-8")).decode("utf-8")
-    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose).main(
+    rc = astraSDK.credentials.createCredential(quiet=quiet, verbose=verbose, config=config).main(
         name, "s3", {"accessKey": encodedKey, "accessSecret": encodedSecret}, cloudName="s3"
     )
     if rc:
         return rc
     else:
         raise SystemExit("astraSDK.credentials.createCredential() failed")
 
@@ -412,15 +412,15 @@
             v3_dict["metadata"]["namespace"],
             v3_dict,
             version="v1",
             group="astra.netapp.io",
         )
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "backup":
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
                 ).main("appvaults")
             if args.bucket is None:
@@ -438,60 +438,71 @@
                 args.bucket,
                 args.snapshot,
                 args.reclaimPolicy,
             )
             if backup and not args.dry_run and not args.background:
                 monitorV3ProtectionTask(backup, args.pollTimer, args.v3, args.skip_tls_verify)
         else:
-            protectionID = astraSDK.backups.takeBackup(quiet=args.quiet, verbose=args.verbose).main(
+            protectionID = astraSDK.backups.takeBackup(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 args.app,
                 helpers.isRFC1123(args.name),
                 bucketID=args.bucket,
                 snapshotID=args.snapshot,
             )
             rc = monitorProtectionTask(
                 protectionID,
                 args.objectType,
                 args.app,
                 args.background,
                 args.pollTimer,
+                config=config,
             )
             if rc is False:
                 raise SystemExit("monitorProtectionTask() failed")
     elif args.objectType == "cluster":
         kubeconfigDict = helpers.openYaml(args.filePath)
         encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode("utf-8")
-        rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
+        rc = astraSDK.credentials.createCredential(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(
             kubeconfigDict["clusters"][0]["name"],
             "kubeconfig",
             {"base64": encodedStr},
             cloudName="private",
         )
         if rc:
-            rc = astraSDK.clusters.addCluster(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.clusters.addCluster(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 args.cloudID,
                 rc["id"],
                 privateRouteID=args.privateRouteID,
             )
             if rc is False:
                 raise SystemExit("astraSDK.clusters.createCluster() failed")
         else:
             raise SystemExit("astraSDK.credentials.createCredential() failed")
     elif args.objectType == "group":
-        ldapGroups = astraSDK.groups.getLdapGroups().main(dnFilter=args.dn, matchType="eq")
+        ldapGroups = astraSDK.groups.getLdapGroups(config=config).main(
+            dnFilter=args.dn, matchType="eq"
+        )
         if len(ldapGroups["items"]) == 0:
             helpers.parserError(f"0 LDAP groups found with DN '{args.dn}'")
         elif len(ldapGroups["items"]) > 1:
             helpers.parserError(f"multiple LDAP users found with DN '{args.dn}'")
         # First create the group
-        grc = astraSDK.groups.createGroup(quiet=args.quiet, verbose=args.verbose).main(args.dn)
+        grc = astraSDK.groups.createGroup(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(args.dn)
         if grc:
             # Next create the role binding
             if not astraSDK.rolebindings.createRolebinding(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 args.role,
                 groupID=grc["id"],
                 roleConstraints=helpers.createConstraintList(
                     args.namespaceConstraint, args.labelConstraint
                 ),
             ):
@@ -514,15 +525,17 @@
                 containerImage=args.containerImage,
                 namespace=args.namespace,
                 podName=args.podName,
                 label=args.label,
                 containerName=args.containerName,
             )
         else:
-            rc = astraSDK.hooks.createHook(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.hooks.createHook(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 args.app,
                 args.name,
                 args.script,
                 args.operation.split("-")[0],
                 args.operation.split("-")[1],
                 helpers.createHookList(args.hookArguments),
                 matchingCriteria=helpers.createCriteriaList(
@@ -532,18 +545,22 @@
                     args.label,
                     args.containerName,
                 ),
             )
             if rc is False:
                 raise SystemExit("astraSDK.hooks.createHook() failed")
     elif args.objectType == "ldap":
-        credential = createLdapCredential(args.quiet, args.verbose, args.username, args.password)
-        ard.settings = astraSDK.settings.getSettings().main()
+        credential = createLdapCredential(
+            args.quiet, args.verbose, args.username, args.password, config=config
+        )
+        ard.settings = astraSDK.settings.getSettings(config=config).main()
         ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
-        rc = astraSDK.settings.createLdap(quiet=args.quiet, verbose=args.verbose).main(
+        rc = astraSDK.settings.createLdap(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(
             ldapSetting["id"],
             args.url,
             args.port,
             credential["id"],
             args.userBaseDN,
             args.userSearchFilter,
             args.userLoginAttribute,
@@ -603,15 +620,15 @@
                 args.minute,
                 args.hour,
                 args.dayOfWeek,
                 args.dayOfMonth,
             )
         else:
             rc = astraSDK.protections.createProtectionpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 args.granularity,
                 str(args.backupRetention),
                 str(args.snapshotRetention),
                 str(args.dayOfWeek),
                 str(args.dayOfMonth),
                 str(args.hour),
@@ -640,38 +657,38 @@
         rrule = "RRULE:FREQ=MINUTELY;INTERVAL="
         if "m" in args.replicationFrequency:
             rrule += args.replicationFrequency.strip("m")
         else:
             rrule += str(int(args.replicationFrequency.strip("h")) * 60)
         # Get Source ClusterID
         if ard.needsattr("apps"):
-            ard.apps = astraSDK.apps.getApps().main()
+            ard.apps = astraSDK.apps.getApps(config=config).main()
         for app in ard.apps["items"]:
             if app["id"] == args.appID:
                 sourceClusterID = app["clusterID"]
                 sourceNamespaces = app["namespaces"]
         nsMapping = [
             {"clusterID": sourceClusterID, "namespaces": sourceNamespaces},
             {"clusterID": args.destClusterID, "namespaces": [args.destNamespace]},
         ]
         if args.destStorageClass:
             args.destStorageClass = [
                 {"storageClassName": args.destStorageClass, "clusterID": args.destClusterID}
             ]
         rc = astraSDK.replications.createReplicationpolicy(
-            quiet=args.quiet, verbose=args.verbose
+            quiet=args.quiet, verbose=args.verbose, config=config
         ).main(
             args.appID,
             args.destClusterID,
             nsMapping,
             destinationStorageClass=args.destStorageClass,
         )
         if rc:
             prc = astraSDK.protections.createProtectionpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 "custom",
                 "0",
                 "0",
                 None,
                 None,
                 None,
@@ -681,17 +698,17 @@
             )
             if prc is False:
                 raise SystemExit("astraSDK.protections.createProtectionpolicy() failed")
         else:
             raise SystemExit("astraSDK.replications.createReplicationpolicy() failed")
     elif args.objectType == "script":
         encodedStr = helpers.openScript(args.filePath)
-        rc = astraSDK.scripts.createScript(quiet=args.quiet, verbose=args.verbose).main(
-            name=args.name, source=encodedStr, description=args.description
-        )
+        rc = astraSDK.scripts.createScript(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(name=args.name, source=encodedStr, description=args.description)
         if rc is False:
             raise SystemExit("astraSDK.scripts.createScript() failed")
     elif args.objectType == "snapshot":
         if args.v3:
             if ard.needsattr("buckets"):
                 ard.buckets = astraSDK.k8s.getResources(
                     config_context=args.v3, skip_tls_verify=args.skip_tls_verify
@@ -712,63 +729,66 @@
                 reclaimPolicy=args.reclaimPolicy,
                 createdTimeout=args.createdTimeout,
                 readyToUseTimeout=args.readyToUseTimeout,
             )
             if snapshot and not args.dry_run and not args.background:
                 monitorV3ProtectionTask(snapshot, args.pollTimer, args.v3, args.skip_tls_verify)
         else:
-            protectionID = astraSDK.snapshots.takeSnap(quiet=args.quiet, verbose=args.verbose).main(
-                args.app, helpers.isRFC1123(args.name)
-            )
+            protectionID = astraSDK.snapshots.takeSnap(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.app, helpers.isRFC1123(args.name))
             rc = monitorProtectionTask(
                 protectionID,
                 args.objectType,
                 args.app,
                 args.background,
                 args.pollTimer,
+                config=config,
             )
             if rc is False:
                 raise SystemExit("monitorProtectionTask() failed")
     elif args.objectType == "user":
         # Handle LDAP use cases
         if args.ldap:
-            ldapUsers = astraSDK.users.getLdapUsers().main(emailFilter=args.email, matchType="eq")
+            ldapUsers = astraSDK.users.getLdapUsers(config=config).main(
+                emailFilter=args.email, matchType="eq"
+            )
             if len(ldapUsers["items"]) == 0:
                 helpers.parserError(f"0 LDAP users found with email '{args.email}'")
             elif len(ldapUsers["items"]) > 1:
                 helpers.parserError(f"multiple LDAP users found with email '{args.email}'")
             args.firstName = ldapUsers["items"][0]["firstName"]
             args.lastName = ldapUsers["items"][0]["lastName"]
             args.ldap = "ldap"
         # First create the user
-        urc = astraSDK.users.createUser(quiet=args.quiet, verbose=args.verbose).main(
+        urc = astraSDK.users.createUser(quiet=args.quiet, verbose=args.verbose, config=config).main(
             args.email, firstName=args.firstName, lastName=args.lastName, authProvider=args.ldap
         )
         if urc:
             # Next create the role binding
             rrc = astraSDK.rolebindings.createRolebinding(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 args.role,
                 userID=urc["id"],
                 roleConstraints=helpers.createConstraintList(
                     args.namespaceConstraint, args.labelConstraint
                 ),
             )
             if rrc:
                 # Delete+error "local" users where a tempPassword wasn't provided
                 if urc["authProvider"] == "local" and not args.tempPassword:
-                    drc = astraSDK.rolebindings.destroyRolebinding(quiet=True).main(rrc["id"])
+                    drc = astraSDK.rolebindings.destroyRolebinding(config=config).main(rrc["id"])
                     if not drc:
                         raise SystemExit("astraSDK.rolebindings.destroyRolebinding() failed")
                     raise SystemExit("Error: --tempPassword is required for ACC+localAuth")
                 # Finally, create the credential if local user
                 if urc["authProvider"] == "local":
                     crc = astraSDK.credentials.createCredential(
-                        quiet=args.quiet, verbose=args.verbose
+                        quiet=args.quiet, verbose=args.verbose, config=config
                     ).main(
                         urc["id"],
                         "passwordHash",
                         {
                             "cleartext": base64.b64encode(args.tempPassword.encode("utf-8")).decode(
                                 "utf-8"
                             ),
```

## tkSrc/deploy.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -35,14 +35,15 @@
     fileValues,
     bucket,
     verbose,
     quiet,
     v3=False,
     dry_run=None,
     skip_tls_verify=False,
+    config=None,
 ):
     """Deploy a helm chart <chart>, naming the app <appName> into <namespace>"""
     if v3:
         context, config_file = tuple(v3.split("@"))
         contextStr = f" --kube-context={context}"
         configFileStr = (
             "" if config_file == "None" else f" --kubeconfig={os.path.expanduser(config_file)}"
@@ -94,15 +95,15 @@
                 snapshotRetention,
                 minute,
                 protectionData[granularity]["hour"],
                 protectionData[granularity]["dayOfWeek"],
                 protectionData[granularity]["dayOfMonth"],
             )
     else:
-        nsObj = astraSDK.namespaces.getNamespaces(verbose=verbose)
+        nsObj = astraSDK.namespaces.getNamespaces(verbose=verbose, config=config)
         print("Waiting for Astra to discover the namespace", end="")
         sys.stdout.flush()
 
         appID = ""
         while not appID:
             # It takes Astra some time to realize new apps have been installed
             time.sleep(3)
@@ -125,41 +126,41 @@
                     < timedelta(minutes=10)
                 ):
                     print(" Namespace discovered!")
                     sys.stdout.flush()
                     time.sleep(3)
                     print(f"Managing app: {ns['name']}.", end="")
                     sys.stdout.flush()
-                    rc = astraSDK.apps.manageApp(verbose=verbose).main(
+                    rc = astraSDK.apps.manageApp(verbose=verbose, config=config).main(
                         ns["name"], ns["name"], ns["clusterID"]
                     )
                     if rc:
                         appID = rc["id"]
                         print(" Success!")
                         sys.stdout.flush()
                         break
                     else:
                         sys.stdout.flush()
                         print("\nERROR managing app, trying one more time:")
-                        rc = astraSDK.apps.manageApp(quiet=quiet, verbose=verbose).main(
-                            ns["name"], ns["name"], ns["clusterID"]
-                        )
+                        rc = astraSDK.apps.manageApp(
+                            quiet=quiet, verbose=verbose, config=config
+                        ).main(ns["name"], ns["name"], ns["clusterID"])
                         if rc:
                             appID = rc["id"]
                             print("Success!")
                             break
                         else:
                             raise SystemExit("Error managing app")
 
         # Create a protection policy on that namespace (using its appID)
         time.sleep(5)
         backupRetention = "1"
         snapshotRetention = "1"
         minute = "0"
-        cpp = astraSDK.protections.createProtectionpolicy(quiet=quiet)
+        cpp = astraSDK.protections.createProtectionpolicy(quiet=quiet, config=config)
         cppData = {
             "hourly": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "*"},
             "daily": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "2"},
             "weekly": {"dayOfWeek": "0", "dayOfMonth": "*", "hour": "2"},
             "monthly": {"dayOfWeek": "*", "dayOfMonth": "1", "hour": "2"},
         }
         for period in cppData:
@@ -177,15 +178,15 @@
                 minute,
                 appID,
             )
             if cppRet is False:
                 raise SystemExit(f"cpp.main({period}...) returned False")
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "acp":
         if args.v3:
             # Ensure the trident orchestrator is already running
             torc = astraSDK.k8s.getClusterResources(
                 quiet=args.quiet,
                 verbose=args.verbose,
                 config_context=args.v3,
@@ -201,14 +202,15 @@
             if not args.regCred:
                 cred = astraSDK.k8s.createRegCred(
                     quiet=args.quiet,
                     dry_run=args.dry_run,
                     verbose=args.verbose,
                     config_context=args.v3,
                     skip_tls_verify=args.skip_tls_verify,
+                    config=config,
                 ).main(registry=args.registry)
                 if not cred:
                     raise SystemExit("astraSDK.k8s.createRegCred() failed")
                 args.regCred = cred["metadata"]["name"]
             else:
                 if ard.needsattr("credentials"):
                     ard.credentials = astraSDK.k8s.getSecrets(
@@ -273,8 +275,9 @@
             args.values,
             args.bucket,
             args.verbose,
             args.quiet,
             v3=args.v3,
             dry_run=args.dry_run,
             skip_tls_verify=args.skip_tls_verify,
+            config=config,
         )
```

## tkSrc/destroy.py

```diff
@@ -14,69 +14,69 @@
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import astraSDK
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "backup":
         if args.v3:
             rc = astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("backups", args.backup)
         else:
-            rc = astraSDK.backups.destroyBackup(quiet=args.quiet, verbose=args.verbose).main(
-                args.app, args.backup
-            )
+            rc = astraSDK.backups.destroyBackup(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.app, args.backup)
             if rc:
                 print(f"Backup {args.backup} destroyed")
             else:
                 raise SystemExit(f"Failed destroying backup: {args.backup}")
     elif args.objectType == "cluster":
         if ard.needsattr("clusters"):
-            ard.clusters = astraSDK.clusters.getClusters().main()
+            ard.clusters = astraSDK.clusters.getClusters(config=config).main()
         cluster = ard.getSingleDict("clusters", "id", args.cluster)
-        rc = astraSDK.clusters.deleteCluster(quiet=args.quiet, verbose=args.verbose).main(
-            cluster["id"], cluster["cloudID"]
-        )
+        rc = astraSDK.clusters.deleteCluster(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(cluster["id"], cluster["cloudID"])
         if not rc:
             raise SystemExit(f"Failed destroying cluster: {args.cluster}")
     elif args.objectType == "credential" or args.objectType == "secret":
         if args.v3:
             astraSDK.k8s.destroySecret(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main(args.credential)
         else:
             rc = astraSDK.credentials.destroyCredential(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(args.credential)
             if rc:
                 print(f"Credential {args.credential} destroyed")
             else:
                 raise SystemExit(f"Failed destroying credential: {args.credential}")
     elif args.objectType == "group":
         if ard.needsattr("rolebindings"):
-            ard.rolebindings = astraSDK.rolebindings.getRolebindings().main()
+            ard.rolebindings = astraSDK.rolebindings.getRolebindings(config=config).main()
         rb = ard.getSingleDict("rolebindings", "groupID", args.groupID)
-        if astraSDK.rolebindings.destroyRolebinding(quiet=args.quiet, verbose=args.verbose).main(
-            rb["id"]
-        ):
+        if astraSDK.rolebindings.destroyRolebinding(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(rb["id"]):
             print(f"RoleBinding {rb['id']} destroyed")
-            if astraSDK.groups.destroyGroup(quiet=args.quiet, verbose=args.verbose).main(
-                args.groupID
-            ):
+            if astraSDK.groups.destroyGroup(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.groupID):
                 print(f"Group {args.groupID} destroyed")
             else:
                 raise SystemExit(f"Failed destroying group {args.groupID}")
         else:
             raise SystemExit(f"Failed destroying group {args.groupID} with roleBinding {rb['id']}")
     elif args.objectType == "hook" or args.objectType == "exechook":
         if args.v3:
@@ -84,30 +84,30 @@
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("exechooks", args.hook)
         else:
-            rc = astraSDK.hooks.destroyHook(quiet=args.quiet, verbose=args.verbose).main(
-                args.app, args.hook
-            )
+            rc = astraSDK.hooks.destroyHook(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.app, args.hook)
             if rc:
                 print(f"Hook {args.hook} destroyed")
             else:
                 raise SystemExit(f"Failed destroying hook: {args.hook}")
     elif args.objectType == "ldap":
-        ard.settings = astraSDK.settings.getSettings().main()
+        ard.settings = astraSDK.settings.getSettings(config=config).main()
         ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
-        if astraSDK.settings.destroyLdap(quiet=args.quiet, verbose=args.verbose).main(
-            ldapSetting["id"]
-        ):
+        if astraSDK.settings.destroyLdap(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(ldapSetting["id"]):
             if ldapSetting["currentConfig"].get("credentialId"):
                 rc = astraSDK.credentials.destroyCredential(
-                    quiet=args.quiet, verbose=args.verbose
+                    quiet=args.quiet, verbose=args.verbose, config=config
                 ).main(ldapSetting["currentConfig"]["credentialId"])
                 if rc:
                     print(f"Credential {ldapSetting['currentConfig']['credentialId']} destroyed")
                 else:
                     raise SystemExit(
                         "Failed destroying credential: "
                         f"{ldapSetting['currentConfig']['credentialId']}"
@@ -121,90 +121,92 @@
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("schedules", args.protection)
         else:
             rc = astraSDK.protections.destroyProtectiontionpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(args.app, args.protection)
             if rc:
                 print(f"Protection policy {args.protection} destroyed")
             else:
                 raise SystemExit(f"Failed destroying protection policy: {args.protection}")
     elif args.objectType == "replication":
         if ard.needsattr("replications"):
-            ard.replications = astraSDK.replications.getReplicationpolicies().main()
+            ard.replications = astraSDK.replications.getReplicationpolicies(config=config).main()
         rc = astraSDK.replications.destroyReplicationpolicy(
-            quiet=args.quiet, verbose=args.verbose
+            quiet=args.quiet, verbose=args.verbose, config=config
         ).main(args.replicationID)
         if rc:
             print(f"Replication policy {args.replicationID} destroyed")
             # The underlying replication schedule(s) (protection policy) must also be deleted
             if ard.needsattr("protections"):
-                ard.protections = astraSDK.protections.getProtectionpolicies().main()
+                ard.protections = astraSDK.protections.getProtectionpolicies(config=config).main()
             for replication in ard.replications["items"]:
                 if replication["id"] == args.replicationID:
                     for protection in ard.protections["items"]:
                         if (
                             protection["appID"] == replication["sourceAppID"]
                             or protection["appID"] == replication["destinationAppID"]
                         ) and protection.get("replicate") == "true":
                             if astraSDK.protections.destroyProtectiontionpolicy(
-                                quiet=args.quiet, verbose=args.verbose
+                                quiet=args.quiet, verbose=args.verbose, config=config
                             ).main(protection["appID"], protection["id"]):
                                 print(
                                     f"Underlying replication schedule {protection['id']} destroyed"
                                 )
                             else:
                                 raise SystemExit(
                                     "Failed destroying underlying replication "
                                     + f"schedule: {protection['id']}"
                                 )
         else:
             raise SystemExit(f"Failed destroying replication policy: {args.replicationID}")
     elif args.objectType == "script":
-        rc = astraSDK.scripts.destroyScript(quiet=args.quiet, verbose=args.verbose).main(
-            args.scriptID
-        )
+        rc = astraSDK.scripts.destroyScript(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(args.scriptID)
         if rc:
             print(f"Script {args.scriptID} destroyed")
         else:
             raise SystemExit(f"Failed destroying script: {args.scriptID}")
     elif args.objectType == "snapshot":
         if args.v3:
             rc = astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("snapshots", args.snapshot)
         else:
-            rc = astraSDK.snapshots.destroySnapshot(quiet=args.quiet, verbose=args.verbose).main(
-                args.app, args.snapshot
-            )
+            rc = astraSDK.snapshots.destroySnapshot(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.app, args.snapshot)
             if rc:
                 print(f"Snapshot {args.snapshot} destroyed")
             else:
                 raise SystemExit(f"Failed destroying snapshot: {args.snapshot}")
     elif args.objectType == "user":
         if ard.needsattr("users"):
-            ard.users = astraSDK.users.getUsers().main()
+            ard.users = astraSDK.users.getUsers(config=config).main()
         if ard.needsattr("rolebindings"):
-            ard.rolebindings = astraSDK.rolebindings.getRolebindings().main()
+            ard.rolebindings = astraSDK.rolebindings.getRolebindings(config=config).main()
         user = ard.getSingleDict("users", "id", args.userID)
         rb = ard.getSingleDict("rolebindings", "userID", args.userID)
-        if astraSDK.rolebindings.destroyRolebinding(quiet=args.quiet, verbose=args.verbose).main(
-            rb["id"]
-        ):
+        if astraSDK.rolebindings.destroyRolebinding(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(rb["id"]):
             print(f"RoleBinding {rb['id']} destroyed")
         else:
             raise SystemExit(f"Failed destroying user {args.userID} with roleBinding {rb['id']}")
         # Only LDAP users also need to be destroyed
         if user["authProvider"] == "ldap":
-            if astraSDK.users.destroyUser(quiet=args.quiet, verbose=args.verbose).main(args.userID):
+            if astraSDK.users.destroyUser(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.userID):
                 print(f"User {args.userID} destroyed")
             else:
                 raise SystemExit(f"Failed destroying user {args.userID}")
         else:
             print(f"User {args.userID} destroyed")
```

## tkSrc/ipr.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -83,15 +83,15 @@
         iprSourceName = backup if backup else snapshot
         helpers.parserError(
             f"{err} key not found in '{iprSourceName}' object, please ensure "
             f"'{iprSourceName}' is a valid backup/snapshot"
         )
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if (args.filterSelection and not args.filterSet) or (
         args.filterSet and not args.filterSelection
     ):
         helpers.parserError(
             "either both or none of --filterSelection and --filterSet should be specified"
         )
 
@@ -105,33 +105,33 @@
             ard,
             backup=args.backup,
             snapshot=args.snapshot,
             filterSelection=args.filterSelection,
             filterSet=args.filterSet,
         )
     else:
-        rc = astraSDK.apps.restoreApp(quiet=args.quiet, verbose=args.verbose).main(
+        rc = astraSDK.apps.restoreApp(quiet=args.quiet, verbose=args.verbose, config=config).main(
             args.app,
             backupID=args.backup,
             snapshotID=args.snapshot,
             resourceFilter=helpers.createFilterSet(
                 args.filterSelection,
                 args.filterSet,
-                astraSDK.apps.getAppAssets().main(args.app),
+                astraSDK.apps.getAppAssets(config=config).main(args.app),
             ),
         )
         if rc:
             if args.background:
                 print("In-Place-Restore job submitted successfully")
                 print("Background flag selected, run 'list apps' to get status")
                 return True
             print("In-Place-Restore job in progress", end="")
             sys.stdout.flush()
             while True:
-                restoreApps = astraSDK.apps.getApps().main()
+                restoreApps = astraSDK.apps.getApps(config=config).main()
                 state = None
                 for restoreApp in restoreApps["items"]:
                     if restoreApp["id"] == args.app:
                         state = restoreApp["state"]
                 if state == "restoring":
                     print(".", end="")
                     sys.stdout.flush()
```

## tkSrc/list.py

```diff
@@ -222,18 +222,18 @@
         output=output,
         verbose=verbose,
         config_context=v3,
         skip_tls_verify=skip_tls_verify,
     ).main("snapshots", filters=[{"keyFilter": "spec.applicationRef", "valFilter": app}])
 
 
-def main(args):
+def main(args, config=None):
     if args.objectType == "apiresources":
         rc = astraSDK.apiresources.getApiResources(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(cluster=args.cluster)
         if rc is False:
             raise SystemExit("astraSDK.apiresources.getApiResources() failed")
     elif args.objectType == "apps" or args.objectType == "applications":
         if args.v3:
             listV3Apps(
                 args.v3,
@@ -242,25 +242,25 @@
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 nameFilter=args.nameFilter,
                 namespace=args.namespace,
             )
         else:
             rc = astraSDK.apps.getApps(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(
                 namespace=args.namespace,
                 nameFilter=args.nameFilter,
                 cluster=args.cluster,
             )
             if rc is False:
                 raise SystemExit("astraSDK.apps.getApps() failed")
     elif args.objectType == "assets":
         rc = astraSDK.apps.getAppAssets(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(args.appID)
         if rc is False:
             raise SystemExit("astraSDK.apps.getAppAssets() failed")
     elif args.objectType == "backups":
         if args.v3:
             listV3Backups(
                 args.v3,
@@ -268,15 +268,15 @@
                 args.output,
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 app=args.app,
             )
         else:
             rc = astraSDK.backups.getBackups(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(appFilter=args.app)
             if rc is False:
                 raise SystemExit("astraSDK.backups.getBackups() failed")
     elif args.objectType == "buckets" or args.objectType == "appVaults":
         if args.v3:
             listV3Appvaults(
                 args.v3,
@@ -285,27 +285,27 @@
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 provider=args.provider,
                 nameFilter=args.nameFilter,
             )
         else:
             rc = astraSDK.buckets.getBuckets(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(nameFilter=args.nameFilter, provider=args.provider)
             if rc is False:
                 raise SystemExit("astraSDK.buckets.getBuckets() failed")
     elif args.objectType == "clouds":
         rc = astraSDK.clouds.getClouds(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(cloudType=args.cloudType)
         if rc is False:
             raise SystemExit("astraSDK.clouds.getClouds() failed")
     elif args.objectType == "clusters":
         rc = astraSDK.clusters.getClusters(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(
             hideManaged=args.hideManaged,
             hideUnmanaged=args.hideUnmanaged,
             nameFilter=args.nameFilter,
         )
         if rc is False:
             raise SystemExit("astraSDK.clusters.getClusters() failed")
@@ -316,21 +316,21 @@
     elif args.objectType == "credentials" or args.objectType == "secrets":
         if args.v3:
             listV3Secrets(
                 args.v3, args.quiet, args.output, args.verbose, skip_tls_verify=args.skip_tls_verify
             )
         else:
             rc = astraSDK.credentials.getCredentials(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(kubeconfigOnly=args.kubeconfigOnly)
             if rc is False:
                 raise SystemExit("astraSDK.credentials.getCredentials() failed")
     elif args.objectType == "groups":
         rc = astraSDK.groups.getGroups(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main()
         if rc is False:
             raise SystemExit("astraSDK.groups.getGroups() failed")
     elif args.objectType == "hooks" or args.objectType == "exechooks":
         if args.v3:
             listV3Hooks(
                 args.v3,
@@ -338,15 +338,15 @@
                 args.output,
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 app=args.app,
             )
         else:
             rc = astraSDK.hooks.getHooks(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(appFilter=args.app)
             if rc is False:
                 raise SystemExit("astraSDK.hooks.getHooks() failed")
     elif args.objectType == "hooksruns" or args.objectType == "exechooksruns":
         """This is a --v3 only command, per tkSrc/parser.py"""
         listV3Hooksruns(
             args.v3,
@@ -364,25 +364,25 @@
             args.output,
             args.verbose,
             skip_tls_verify=args.skip_tls_verify,
             app=args.app,
         )
     elif args.objectType == "ldapgroups":
         rc = astraSDK.groups.getLdapGroups(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(
             cnFilter=args.cnFilter,
             dnFilter=args.dnFilter,
             limit=args.limit,
             cont=args.cont,
             matchType=("in" if args.matchType == "partial" else "eq"),
         )
     elif args.objectType == "ldapusers":
         rc = astraSDK.users.getLdapUsers(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(
             emailFilter=args.emailFilter,
             firstNameFilter=args.firstNameFilter,
             lastNameFilter=args.lastNameFilter,
             cnFilter=args.cnFilter,
             limit=args.limit,
             cont=args.cont,
@@ -396,21 +396,21 @@
                 args.output,
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 app=args.app,
             )
         else:
             rc = astraSDK.protections.getProtectionpolicies(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(appFilter=args.app, clusterFilter=args.cluster)
             if rc is False:
                 raise SystemExit("astraSDK.protections.getProtectionpolicies() failed")
     elif args.objectType == "replications":
         rc = astraSDK.replications.getReplicationpolicies(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(appFilter=args.app)
         if rc is False:
             raise SystemExit("astraSDK.replications.getReplicationpolicies() failed")
     elif args.objectType == "namespaces":
         if args.v3:
             listV3Namespaces(
                 args.v3,
@@ -420,27 +420,27 @@
                 skip_tls_verify=args.skip_tls_verify,
                 nameFilter=args.nameFilter,
                 unassociated=args.unassociated,
                 minuteFilter=args.minutes,
             )
         else:
             rc = astraSDK.namespaces.getNamespaces(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(
                 clusterID=args.clusterID,
                 nameFilter=args.nameFilter,
                 showRemoved=args.showRemoved,
                 unassociated=args.unassociated,
                 minuteFilter=args.minutes,
             )
             if rc is False:
                 raise SystemExit("astraSDK.namespaces.getNamespaces() failed")
     elif args.objectType == "notifications":
         rc = astraSDK.notifications.getNotifications(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(
             limit=args.limit,
             skip=args.offset,
             minuteFilter=args.minutes,
             severityFilter=args.severity,
         )
         if rc is False:
@@ -454,24 +454,24 @@
             args.verbose,
             skip_tls_verify=args.skip_tls_verify,
             sourceNamespace=args.sourceNamespace,
             destNamespace=args.destNamespace,
         )
     elif args.objectType == "rolebindings":
         rc = astraSDK.rolebindings.getRolebindings(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(idFilter=args.idFilter)
         if rc is False:
             raise SystemExit("astraSDK.rolebindings.getRolebindings() failed")
     elif args.objectType == "scripts":
         if args.getScriptSource:
             args.quiet = True
             args.output = "json"
         rc = astraSDK.scripts.getScripts(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(nameFilter=args.nameFilter)
         if rc is False:
             raise SystemExit("astraSDK.scripts.getScripts() failed")
         else:
             if args.getScriptSource:
                 if len(rc["items"]) == 0:
                     print(f"Script of name '{args.nameFilter}' not found.")
@@ -488,29 +488,29 @@
                 args.output,
                 args.verbose,
                 skip_tls_verify=args.skip_tls_verify,
                 app=args.app,
             )
         else:
             rc = astraSDK.snapshots.getSnaps(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
+                quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
             ).main(appFilter=args.app)
             if rc is False:
                 raise SystemExit("astraSDK.snapshots.getSnaps() failed")
     elif args.objectType == "storagebackends":
         rc = astraSDK.storagebackends.getStorageBackends(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main()
         if rc is False:
             raise SystemExit("astraSDK.backups.getBackends() failed")
     elif args.objectType == "storageclasses":
         rc = astraSDK.storageclasses.getStorageClasses(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(cloudType=args.cloudType, clusterStr=args.cluster)
         if rc is False:
             raise SystemExit("astraSDK.storageclasses.getStorageClasses() failed")
     elif args.objectType == "users":
         rc = astraSDK.users.getUsers(
-            quiet=args.quiet, verbose=args.verbose, output=args.output
+            quiet=args.quiet, verbose=args.verbose, output=args.output, config=config
         ).main(nameFilter=args.nameFilter)
         if rc is False:
             raise SystemExit("astraSDK.users.getUsers() failed")
```

## tkSrc/manage.py

```diff
@@ -62,24 +62,26 @@
             v3_dict["metadata"]["namespace"],
             v3_dict,
             version="v1",
             group="astra.netapp.io",
         )
 
 
-def manageBucket(provider, bucketName, storageAccount, serverURL, credential, quiet, verbose):
+def manageBucket(
+    provider, bucketName, storageAccount, serverURL, credential, quiet, verbose, config=None
+):
     """Manage a bucket via an API call"""
     if provider == "azure":
         bucketParameters = {"azure": {"bucketName": bucketName, "storageAccount": storageAccount}}
     elif provider == "gcp":
         bucketParameters = {"gcp": {"bucketName": bucketName}}
     else:
         bucketParameters = {"s3": {"bucketName": bucketName, "serverURL": serverURL}}
     # Call manageBucket class
-    rc = astraSDK.buckets.manageBucket(quiet=quiet, verbose=verbose).main(
+    rc = astraSDK.buckets.manageBucket(quiet=quiet, verbose=verbose, config=config).main(
         bucketName, credential, provider, bucketParameters
     )
     if rc:
         return rc
     raise SystemExit("astraSDK.buckets.manageBucket() failed")
 
 
@@ -148,34 +150,37 @@
     clusterName,
     operator_version,
     regCred,
     registry,
     cloudID,
     headless,
     ard,
+    config=None,
 ):
     helpers.isRFC1123(clusterName)
     create.createV3ConnectorOperator(v3, dry_run, skip_tls_verify, verbose, operator_version)
     # Create the astra API token secret
     if not headless:
         apiToken = astraSDK.k8s.createAstraApiToken(
             quiet=quiet,
             dry_run=dry_run,
             verbose=verbose,
             config_context=v3,
             skip_tls_verify=skip_tls_verify,
+            config=config,
         ).main()
     # Handle the registry secret
     if not regCred:
         cred = astraSDK.k8s.createRegCred(
             quiet=quiet,
             dry_run=dry_run,
             verbose=verbose,
             config_context=v3,
             skip_tls_verify=skip_tls_verify,
+            config=config,
         ).main(registry=registry, namespace="astra-connector")
         if not cred:
             raise SystemExit("astraSDK.k8s.createRegCred() failed")
         regCred = cred["metadata"]["name"]
     else:
         if ard.needsattr("credentials"):
             ard.credentials = astraSDK.k8s.getSecrets(
@@ -194,14 +199,15 @@
     else:
         connector = astraSDK.k8s.createAstraConnector(
             quiet=quiet,
             dry_run=dry_run,
             verbose=verbose,
             config_context=v3,
             skip_tls_verify=skip_tls_verify,
+            config=config,
         ).main(clusterName, cloudID, apiToken["metadata"]["name"], regCred, registry=registry)
     if not connector:
         raise SystemExit("astraSDK.k8s.createAstraConnector() failed")
 
 
 def validateBucketArgs(args):
     """Validate that user provided inputs for managing a bucket are valid"""
@@ -238,15 +244,15 @@
     # If json was specified, ensure provider is a public cloud
     if args.json is not None and args.provider not in ["aws", "azure", "gcp"]:
         helpers.parserError(
             "--json should only be specified for public cloud providers (aws, azure, gcp)"
         )
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "app" or args.objectType == "application":
         if args.additionalNamespace:
             args.additionalNamespace = helpers.createNamespaceList(
                 args.additionalNamespace, v3=args.v3
             )
         if args.clusterScopedResource:
             if args.v3:
@@ -284,15 +290,15 @@
                         {
                             "apiVersion": "admissionregistration.k8s.io/v1",
                             "kind": "ValidatingWebhookConfiguration",
                         },
                     ]
                 }
             else:
-                ard.apiresources = astraSDK.apiresources.getApiResources().main(
+                ard.apiresources = astraSDK.apiresources.getApiResources(config=config).main(
                     cluster=args.clusterID
                 )
             # Validate input as argparse+choices is unable to only validate the first input
             api_res_list = [f"{a['apiVersion']}/{a['kind']}" for a in ard.apiresources["items"]]
             for csr in args.clusterScopedResource:
                 if csr[0] not in api_res_list:
                     helpers.parserError(
@@ -312,15 +318,17 @@
                 args.appName,
                 args.namespace,
                 labelSelectors=args.labelSelectors,
                 additionalNamespace=args.additionalNamespace,
                 clusterScopedResource=args.clusterScopedResource,
             )
         else:
-            rc = astraSDK.apps.manageApp(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.apps.manageApp(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 helpers.isRFC1123(args.appName),
                 args.namespace,
                 args.clusterID,
                 args.labelSelectors,
                 addNamespaces=args.additionalNamespace,
                 clusterScopedResources=args.clusterScopedResource,
             )
@@ -376,34 +384,41 @@
                 args.skipCertValidation,
                 args.credential,
                 ard,
             )
         else:
             if args.accessKey:
                 crc = create.createS3Credential(
-                    args.quiet, args.verbose, args.accessKey, args.accessSecret, args.bucketName
+                    args.quiet,
+                    args.verbose,
+                    args.accessKey,
+                    args.accessSecret,
+                    args.bucketName,
+                    config=config,
                 )
                 args.credential = crc["id"]
             elif args.json:
                 crc = create.createCloudCredential(
                     args.quiet,
                     args.verbose,
                     args.json,
                     args.bucketName,
                     args.provider,
+                    config=config,
                 )
                 args.credential = crc["id"]
             manageBucket(
                 args.provider,
                 args.bucketName,
                 args.storageAccount,
                 args.serverURL,
                 args.credential,
                 args.quiet,
                 args.verbose,
+                config=config,
             )
 
     elif args.objectType == "cluster":
         if args.v3:
             manageV3Cluster(
                 args.v3,
                 args.dry_run,
@@ -413,19 +428,20 @@
                 args.clusterName,
                 args.operator_version,
                 args.regCred,
                 args.registry,
                 args.cloudID,
                 args.headless,
                 ard,
+                config=config,
             )
         else:
-            rc = astraSDK.clusters.manageCluster(quiet=args.quiet, verbose=args.verbose).main(
-                args.cluster, args.defaultStorageClassID
-            )
+            rc = astraSDK.clusters.manageCluster(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.cluster, args.defaultStorageClassID)
             if rc is False:
                 raise SystemExit("astraSDK.clusters.manageCluster() failed")
 
     elif args.objectType == "cloud":
         credentialID = None
         # First create the credential
         if args.cloudType != "private":
@@ -435,26 +451,29 @@
                 )
             rc = create.createCloudCredential(
                 args.quiet,
                 args.verbose,
                 args.credentialPath,
                 args.cloudName,
                 args.cloudType,
+                config=config,
             )
             credentialID = rc["id"]
         # Next manage the cloud
-        rc = astraSDK.clouds.manageCloud(quiet=args.quiet, verbose=args.verbose).main(
+        rc = astraSDK.clouds.manageCloud(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(
             args.cloudName,
             args.cloudType,
             credentialID=credentialID,
             defaultBucketID=args.defaultBucketID,
         )
         if rc is False:
             raise SystemExit("astraSDK.clouds.manageCloud() failed")
     elif args.objectType == "ldap":
-        ard.settings = astraSDK.settings.getSettings().main()
+        ard.settings = astraSDK.settings.getSettings(config=config).main()
         ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
-        rc = astraSDK.settings.manageLdap(quiet=args.quiet, verbose=args.verbose).main(
-            ldapSetting["id"], ldapSetting["currentConfig"]
-        )
+        rc = astraSDK.settings.manageLdap(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(ldapSetting["id"], ldapSetting["currentConfig"])
         if rc is False:
             raise SystemExit("astraSDK.settings.manageLdap() failed")
```

## tkSrc/unmanage.py

```diff
@@ -15,41 +15,43 @@
    limitations under the License.
 """
 
 from tkSrc import helpers
 import astraSDK
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "app" or args.objectType == "application":
         if args.v3:
             astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("applications", args.app)
         else:
-            rc = astraSDK.apps.unmanageApp(quiet=args.quiet, verbose=args.verbose).main(args.app)
+            rc = astraSDK.apps.unmanageApp(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.app)
             if rc is False:
                 raise SystemExit("astraSDK.apps.unmanageApp() failed")
     elif args.objectType == "bucket" or args.objectType == "appVault":
         if args.v3:
             astraSDK.k8s.destroyResource(
                 quiet=args.quiet,
                 dry_run=args.dry_run,
                 verbose=args.verbose,
                 config_context=args.v3,
                 skip_tls_verify=args.skip_tls_verify,
             ).main("appvaults", args.bucket)
         else:
-            rc = astraSDK.buckets.unmanageBucket(quiet=args.quiet, verbose=args.verbose).main(
-                args.bucket
-            )
+            rc = astraSDK.buckets.unmanageBucket(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.bucket)
             if rc is False:
                 raise SystemExit("astraSDK.buckets.unmanageBucket() failed")
     elif args.objectType == "cluster":
         # If this is a v3-managed cluster, we need to destroy the AstraConnector CR, however we do
         # not want to do that without first ensuring the clusterID the user inputted matches the
         # passed kubeconfig context
         if args.v3:
@@ -91,62 +93,62 @@
                         connector["spec"]["astra"]["tokenRef"],
                         namespace=connector["metadata"]["namespace"],
                     ):
                         raise SystemExit("astraSDK.k8s.destroySecret() failed")
             else:
                 raise SystemExit("astraSDK.k8s.destroyResource() failed")
         else:
-            if astraSDK.clusters.unmanageCluster(quiet=args.quiet, verbose=args.verbose).main(
-                args.cluster
-            ):
+            if astraSDK.clusters.unmanageCluster(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(args.cluster):
                 # "Private" cloud clusters+credentials also should be deleted
                 if ard.needsattr("clusters"):
-                    ard.clusters = astraSDK.clusters.getClusters().main()
+                    ard.clusters = astraSDK.clusters.getClusters(config=config).main()
                 for cluster in ard.clusters["items"]:
                     for label in cluster["metadata"]["labels"]:
                         if (
                             cluster["id"] == args.cluster
                             and label["name"] == "astra.netapp.io/labels/read-only/cloudName"
                             and label["value"] == "private"
                         ):
                             if astraSDK.clusters.deleteCluster(
-                                quiet=args.quiet, verbose=args.verbose
+                                quiet=args.quiet, verbose=args.verbose, config=config
                             ).main(args.cluster, cluster["cloudID"]):
                                 if astraSDK.credentials.destroyCredential(
-                                    quiet=args.quiet, verbose=args.verbose
+                                    quiet=args.quiet, verbose=args.verbose, config=config
                                 ).main(cluster.get("credentialID")):
                                     print("Credential deleted")
                                 else:
                                     raise SystemExit(
                                         "astraSDK.credentials.destroyCredential() failed"
                                     )
                             else:
                                 raise SystemExit("astraSDK.clusters.deleteCluster() failed")
             else:
                 raise SystemExit("astraSDK.clusters.unmanageCluster() failed")
     elif args.objectType == "cloud":
         if ard.needsattr("cloud"):
-            ard.clouds = astraSDK.clouds.getClouds().main()
-        rc = astraSDK.clouds.unmanageCloud(quiet=args.quiet, verbose=args.verbose).main(
-            args.cloudID
-        )
+            ard.clouds = astraSDK.clouds.getClouds(config=config).main()
+        rc = astraSDK.clouds.unmanageCloud(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(args.cloudID)
         if rc:
             # Cloud credentials also should be deleted
             for cloud in ard.clouds["items"]:
                 if cloud["id"] == args.cloudID:
                     if cloud.get("credentialID"):
                         if astraSDK.credentials.destroyCredential(
-                            quiet=args.quiet, verbose=args.verbose
+                            quiet=args.quiet, verbose=args.verbose, config=config
                         ).main(cloud.get("credentialID")):
                             print("Credential deleted")
                         else:
                             raise SystemExit("astraSDK.credentials.destroyCredential() failed")
         else:
             raise SystemExit("astraSDK.clusters.unmanageCloud() failed")
     elif args.objectType == "ldap":
-        ard.settings = astraSDK.settings.getSettings().main()
+        ard.settings = astraSDK.settings.getSettings(config=config).main()
         ldapSetting = ard.getSingleDict("settings", "name", "astra.account.ldap")
-        rc = astraSDK.settings.unmanageLdap(quiet=args.quiet, verbose=args.verbose).main(
-            ldapSetting["id"], ldapSetting["currentConfig"]
-        )
+        rc = astraSDK.settings.unmanageLdap(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(ldapSetting["id"], ldapSetting["currentConfig"])
         if rc is False:
             raise SystemExit("astraSDK.settings.unmanageLdap() failed")
```

## tkSrc/update.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2023 NetApp, Inc
+   Copyright 2024 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -19,15 +19,15 @@
 import json
 import yaml
 
 from tkSrc import helpers
 import astraSDK
 
 
-def main(args, ard):
+def main(args, ard, config=None):
     if args.objectType == "bucket":
         # Validate that both credentialID and accessKey/accessSecret were not specified
         if args.credentialID is not None and (
             args.accessKey is not None or args.accessSecret is not None
         ):
             helpers.parserError(
                 "if a credentialID is specified, neither accessKey nor accessSecret"
@@ -37,111 +37,119 @@
         if args.credentialID is None:
             if args.accessKey is None or args.accessSecret is None:
                 helpers.parserError(
                     "if a credentialID is not specified, both accessKey and "
                     + "accessSecret arguments must be provided."
                 )
             if ard.needsattr("buckets"):
-                ard.buckets = astraSDK.buckets.getBuckets().main()
+                ard.buckets = astraSDK.buckets.getBuckets(config=config).main()
             encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
             encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
             try:
                 crc = astraSDK.credentials.createCredential(
-                    quiet=args.quiet, verbose=args.verbose
+                    quiet=args.quiet, verbose=args.verbose, config=config
                 ).main(
                     next(b for b in ard.buckets["items"] if b["id"] == args.bucketID)["name"],
                     "s3",
                     {"accessKey": encodedKey, "accessSecret": encodedSecret},
                     cloudName="s3",
                 )
             except StopIteration:
                 helpers.parserError(f"{args.bucketID} does not seem to be a valid bucketID")
             if crc:
                 args.credentialID = crc["id"]
             else:
                 raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Call updateBucket class
-        rc = astraSDK.buckets.updateBucket(quiet=args.quiet, verbose=args.verbose).main(
-            args.bucketID, credentialID=args.credentialID
-        )
+        rc = astraSDK.buckets.updateBucket(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(args.bucketID, credentialID=args.credentialID)
         if rc is False:
             raise SystemExit("astraSDK.buckets.updateBucket() failed")
     elif args.objectType == "cloud":
         if args.credentialPath:
             with open(args.credentialPath, encoding="utf8") as f:
                 try:
                     credDict = json.loads(f.read().rstrip())
                 except json.decoder.JSONDecodeError:
                     helpers.parserError(f"{args.credentialPath} does not seem to be valid JSON")
             encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
             if ard.needsattr("clouds"):
-                ard.clouds = astraSDK.clouds.getClouds().main()
+                ard.clouds = astraSDK.clouds.getClouds(config=config).main()
             try:
                 cloud = next(c for c in ard.clouds["items"] if c["id"] == args.cloudID)
             except StopIteration:
                 helpers.parserError(f"{args.cloudID} does not seem to be a valid cloudID")
-            rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.credentials.createCredential(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 "astra-sa@" + cloud["name"],
                 "service-account",
                 {"base64": encodedStr},
                 cloud["cloudType"],
             )
             if rc:
                 args.credentialID = rc["id"]
             else:
                 raise SystemExit("astraSDK.credentials.createCredential() failed")
         # Next update the cloud
-        rc = astraSDK.clouds.updateCloud(quiet=args.quiet, verbose=args.verbose).main(
+        rc = astraSDK.clouds.updateCloud(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(
             args.cloudID,
             credentialID=args.credentialID,
             defaultBucketID=args.defaultBucketID,
         )
         if rc is False:
             raise SystemExit("astraSDK.clouds.updateCloud() failed")
     elif args.objectType == "cluster":
         # Get the cluster information based on the clusterID input
         if ard.needsattr("clusters"):
-            ard.clusters = astraSDK.clusters.getClusters().main()
+            ard.clusters = astraSDK.clusters.getClusters(config=config).main()
         cluster = ard.getSingleDict("clusters", "id", args.clusterID)
         # Currently this is required to be True, but this will not always be the case
         if args.credentialPath:
             with open(args.credentialPath, encoding="utf8") as f:
                 kubeconfigDict = yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
                 encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode(
                     "utf-8"
                 )
-            rc = astraSDK.credentials.updateCredential(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.credentials.updateCredential(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 cluster.get("credentialID"),
                 kubeconfigDict["clusters"][0]["name"],
                 keyStore={"base64": encodedStr},
             )
             if rc is False:
                 raise SystemExit("astraSDK.credentials.updateCredential() failed")
         if args.defaultBucketID:
-            rc = astraSDK.clusters.updateCluster(quiet=args.quiet, verbose=args.verbose).main(
+            rc = astraSDK.clusters.updateCluster(
+                quiet=args.quiet, verbose=args.verbose, config=config
+            ).main(
                 cluster.get("id"),
                 defaultBucketID=args.defaultBucketID,
             )
             if rc is False:
                 raise SystemExit("astraSDK.clusters.updateCluster() failed")
     elif args.objectType == "protection" or args.objectType == "schedule":
         if ard.needsattr("protections"):
-            ard.protections = astraSDK.protections.getProtectionpolicies().main()
+            ard.protections = astraSDK.protections.getProtectionpolicies(config=config).main()
         protection = ard.getSingleDict("protections", "id", args.protection)
         granularity = protection["granularity"]
         if granularity == "hourly" and args.hour:
             helpers.parserError(f"{granularity} granularity must not specify -H / --hour")
         if granularity == "hourly" or granularity == "daily" or granularity == "monthly":
             if args.dayOfWeek:
                 helpers.parserError(f"{granularity} granularity must not specify -W / --dayOfWeek")
         if granularity == "hourly" or granularity == "daily" or granularity == "weekly":
             if args.dayOfMonth:
                 helpers.parserError(f"{granularity} granularity must not specify -M / --dayOfMonth")
         rc = astraSDK.protections.updateProtectionpolicy(
-            quiet=args.quiet, verbose=args.verbose
+            quiet=args.quiet, verbose=args.verbose, config=config
         ).main(
             protection["appID"],
             protection["id"],
             protection["granularity"],
             str(args.backupRetention) if args.backupRetention else protection["backupRetention"],
             (
                 str(args.snapshotRetention)
@@ -155,15 +163,15 @@
             bucketID=args.bucket if args.bucket else protection.get("bucketID"),
         )
         if rc is False:
             raise SystemExit("astraSDK.protection.updateProtectionpolicy() failed")
     elif args.objectType == "replication":
         # Gather replication data
         if ard.needsattr("replications"):
-            ard.replications = astraSDK.replications.getReplicationpolicies().main()
+            ard.replications = astraSDK.replications.getReplicationpolicies(config=config).main()
             if not ard.replications:  # Gracefully handle ACS env
                 helpers.parserError("'replication' commands are currently only supported in ACC.")
         repl = None
         for replication in ard.replications["items"]:
             if args.replicationID == replication["id"]:
                 repl = replication
         if not repl:
@@ -175,26 +183,26 @@
             if repl["state"] != "failedOver":
                 helpers.parserError(
                     "to resync a replication, it must be in a 'failedOver' state"
                     + f", not a(n) '{repl['state']}' state"
                 )
             if args.dataSource in [repl["sourceAppID"], repl["sourceClusterID"]]:
                 rc = astraSDK.replications.updateReplicationpolicy(
-                    quiet=args.quiet, verbose=args.verbose
+                    quiet=args.quiet, verbose=args.verbose, config=config
                 ).main(
                     args.replicationID,
                     "established",
                     sourceAppID=repl["sourceAppID"],
                     sourceClusterID=repl["sourceClusterID"],
                     destinationAppID=repl["destinationAppID"],
                     destinationClusterID=repl["destinationClusterID"],
                 )
             elif args.dataSource in [repl["destinationAppID"], repl["destinationClusterID"]]:
                 rc = astraSDK.replications.updateReplicationpolicy(
-                    quiet=args.quiet, verbose=args.verbose
+                    quiet=args.quiet, verbose=args.verbose, config=config
                 ).main(
                     args.replicationID,
                     "established",
                     sourceAppID=repl["destinationAppID"],
                     sourceClusterID=repl["destinationClusterID"],
                     destinationAppID=repl["sourceAppID"],
                     destinationClusterID=repl["sourceClusterID"],
@@ -210,15 +218,15 @@
         elif args.operation == "reverse":
             if repl["state"] != "established" and repl["state"] != "failedOver":
                 helpers.parserError(
                     "to reverse a replication, it must be in an `established` or "
                     + f"'failedOver' state, not a(n) '{repl['state']}' state"
                 )
             rc = astraSDK.replications.updateReplicationpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(
                 args.replicationID,
                 "established",
                 sourceAppID=repl["destinationAppID"],
                 sourceClusterID=repl["destinationClusterID"],
                 destinationAppID=repl["sourceAppID"],
                 destinationClusterID=repl["sourceClusterID"],
@@ -226,22 +234,22 @@
         else:  # failover
             if repl["state"] != "established":
                 helpers.parserError(
                     "to failover a replication, it must be in an 'established' state"
                     + f", not a(n) '{repl['state']}' state"
                 )
             rc = astraSDK.replications.updateReplicationpolicy(
-                quiet=args.quiet, verbose=args.verbose
+                quiet=args.quiet, verbose=args.verbose, config=config
             ).main(args.replicationID, "failedOver")
         # Exit based on response
         if rc:
             print(f"Replication {args.operation} initiated")
         else:
             raise SystemExit("astraSDK.replications.updateReplicationpolicy() failed")
     elif args.objectType == "script":
         with open(args.filePath, encoding="utf8") as f:
             encodedStr = base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
-        rc = astraSDK.scripts.updateScript(quiet=args.quiet, verbose=args.verbose).main(
-            args.scriptID, source=encodedStr
-        )
+        rc = astraSDK.scripts.updateScript(
+            quiet=args.quiet, verbose=args.verbose, config=config
+        ).main(args.scriptID, source=encodedStr)
         if rc is False:
             raise SystemExit("astraSDK.scripts.updateScript() failed")
```

## Comparing `actoolkit-3.0.1b7.dist-info/LICENSE` & `actoolkit-3.0.1b8.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `actoolkit-3.0.1b7.dist-info/METADATA` & `actoolkit-3.0.1b8.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: actoolkit
-Version: 3.0.1b7
+Version: 3.0.1b8
 Summary: Toolkit and SDK for interacting with Astra Control
 Home-page: https://github.com/NetApp/netapp-astra-toolkits
 Author: Michael Haigh
 Author-email: Michael.Haigh@netapp.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
```

## Comparing `actoolkit-3.0.1b7.dist-info/RECORD` & `actoolkit-3.0.1b8.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-toolkit.py,sha256=M2WtMQj7ZUClTZgEtipW_NV2sqf2d8iyGwKp_WkC8PQ,10201
+toolkit.py,sha256=kHtSUYYLxnulhrvp06vjXuNZz3A0VeeV8rOR2rN5bm0,10702
 astraSDK/__init__.py,sha256=9IogQObmUB6rrUv2B_MemA3XJI6BraZzfJn5ewLrGww,1139
-astraSDK/apiresources.py,sha256=rz_8JYN0qeY4y1K5H6OzI1HQmhQMqRgcUogY1d9HJhs,3659
-astraSDK/apps.py,sha256=HQ7ADBoj1pONiRBKMaroG3uL8m6kAIw6W-VzZqqCKBg,16993
-astraSDK/backups.py,sha256=wVk_kSInOcSniDYyty07T5yy2Mp1AmZz40G9saNRMSs,8289
-astraSDK/buckets.py,sha256=0dKsmhlg9VRxMIXCbamqDZZ5YuHJwhxWs3i-wJgED4E,7355
-astraSDK/clouds.py,sha256=qcE1r0WbU3v3JSIF17Jlbsnv81kLE0M_uI8xFwqV5s0,6972
-astraSDK/clusters.py,sha256=GIFDwGJBeXeYgMkNd5lFjmGZrDYWjrzqos9YYot5X2k,10776
-astraSDK/common.py,sha256=oX6W4yKhK54iXzJfZIzRBmTtDUO8-Fdf1CuPx-RQXxE,14439
-astraSDK/credentials.py,sha256=tmvbJ9YwiqUhP0WKcSIysRYSB9gkCwXyVhYeKXB8xiA,9115
-astraSDK/entitlements.py,sha256=cWfWWEG-3i1aZbpKxD9adNaIcY50Ezm5Ykszu_sfp2A,2663
-astraSDK/groups.py,sha256=YoGysVgQGkJLw7VKUZBdBx8lC1B-9rNFqvFhrKdVRCc,7958
-astraSDK/hooks.py,sha256=7ato-tpUjzm2p8EWybGLVRhKnqvEOJpdRVGIqUuxp0c,7162
-astraSDK/k8s.py,sha256=EWoqrt0DxTm5XAKUZ3KO1CfijF89Es0FpF7Vt8MwLpk,45273
-astraSDK/namespaces.py,sha256=NExkodJpRKHPbDlpAxcCcmp5vGaHV8JFrCXi02LQwFQ,5458
-astraSDK/notifications.py,sha256=cnurpqSBXwRL-vTNxp6SYAl-xz7qzJnLT6w8kwBo4r4,3576
-astraSDK/protections.py,sha256=GISBkrOPl4IgrVViSrm7SpAznuzWD9NSV74G1RqFTJE,11162
-astraSDK/replications.py,sha256=1sFZtKDZ1k_0Y2f7V71ZZzoNP1vkR-3Xk8ESHB7j4gQ,9735
-astraSDK/rolebindings.py,sha256=C_fTyegWZ1XLaajIzI_ftybpkLEsPMnCmyn4mNn3g1M,5757
-astraSDK/scripts.py,sha256=AHMjcDhE5am8PhbUhALh7W22h2lSFe99qDRHTasGjtQ,7090
-astraSDK/settings.py,sha256=FjLCGalV_CVq_aQXixAPTe0GDCNYYV3NopLtVlk0_80,9821
-astraSDK/snapshots.py,sha256=P3FU7zUMnmAYmlorYp_qq1knU24Fa3VrymvS_Pn-hVg,7083
-astraSDK/storagebackends.py,sha256=U4xh-hv5P7ip69Je6e9HIqhGPusU0VukHmzugtUpk_o,2434
-astraSDK/storageclasses.py,sha256=YKMkLFqALreDcUPs1xQzzsadzLZPaLXmuwuJbKoMlXk,5023
-astraSDK/users.py,sha256=nuUS9llQ8I75XEjkRlWvFaai9Kg_VAIO9U7UK7xeKfo,9007
-tkSrc/__init__.py,sha256=bEBPw__Mr4AQFYM-nje4IiKl3_0ljSg_WvdfKItXS20,883
-tkSrc/choices.py,sha256=E1jIQGVpIO0wgKNeECMItq-Mv0U_AP-YZM873onpQoA,32031
+astraSDK/apiresources.py,sha256=zYgekglDN08ix0VVzj4996jkN5t7W3xk2xJIXdyPj_k,3752
+astraSDK/apps.py,sha256=Rz2RLdqWVH3CXkdbMUH3HI0af0moPq4J3zRTwQzGXPo,17485
+astraSDK/backups.py,sha256=oEw3-loNaR47A-7C7F_tInO7Epu3IkSKxXj6j-lVaZE,8546
+astraSDK/buckets.py,sha256=dcYe_WD9BpTLzu_0G3ovAZWAjOof7ZfKzXunx9MwhX8,7683
+astraSDK/clouds.py,sha256=uV4SxuhkLwL0O6afzcxLMHlPFh6DbP_Uc9y3B0wq524,7234
+astraSDK/clusters.py,sha256=htKqm0eAduaJtJRGjwRZxmRTvttbx9g2WWQwsjbuPgU,11279
+astraSDK/common.py,sha256=TgO7jAy7bZQZu4nJ954cP-aAZxRBRcfy4N5ThY2F0Hw,14577
+astraSDK/credentials.py,sha256=ftklPJEoE78EtVfNvh_hy6K0G_Tsu79od1aMo_BrRqw,9443
+astraSDK/entitlements.py,sha256=KosRc-foh6aR66pNw_W6Onp_NW1aBNWlz1rMagolbYM,2745
+astraSDK/groups.py,sha256=WEzXUDWbTz0nh_Q7JhH_pQ8EIEz9EBmD5HU5fb2wQEg,8286
+astraSDK/hooks.py,sha256=_-hV9y75RYFr5GMHCdf_FK3WFRdeZ_ByY2q8Oj9iyFQ,7419
+astraSDK/k8s.py,sha256=Xbnsyf44uAA1EzHatFCMgpCV_MiToE2ueeDfhK4K6hM,45787
+astraSDK/namespaces.py,sha256=L8kk15drlu_AMoc4sxUFyvGoo3XCROZRZ9utHONGzOE,5594
+astraSDK/notifications.py,sha256=h-ryFujL0HkIZoVrRN-oICt6AxhCnG_D-z8dD9kSzVk,3658
+astraSDK/protections.py,sha256=wWTU9vQzGdJNDSi5VcgwLUQmgzUwnTZwNgeIWKKm1Xo,11501
+astraSDK/replications.py,sha256=-tG3zEv2_bifwMzODMSGgCGjljsJwIk4uXhJPmTGHvQ,10008
+astraSDK/rolebindings.py,sha256=FaX-9TyidT4k8MZfuzxkHbZMmcv0M-d7HHPFU7qe44o,6003
+astraSDK/scripts.py,sha256=6GigDKuGXgmIdUglkf9Ky_hpxqBd1U8v20dB_TtAzYk,7418
+astraSDK/settings.py,sha256=ktYwoCgfzBWpQyhBraBThn9OQ8tSuNaQRtJLaQAc-3g,9715
+astraSDK/snapshots.py,sha256=3AoLjUGDKe9lZ9f_fA4iljmGCcKUHZ30lnS4cWB-wlI,7340
+astraSDK/storagebackends.py,sha256=t6hmKaP8xo6okZfz2b-Iu42PEWwwHCVZ7wj9bwAjVnY,2516
+astraSDK/storageclasses.py,sha256=K1uBpUG1oRbUNcfWp-zvPZkHjmeGms2E-I8S96oNdkk,5151
+astraSDK/users.py,sha256=JP6W0cVntretPR3amrBkHVHp4rZ9d1KWxIuA062y4zg,9335
+tkSrc/__init__.py,sha256=KPADRIrGnPbCppvc6xCrqzum-H7N9sFeyWHhjm9wdmI,883
+tkSrc/choices.py,sha256=fhK92z4ZhvmWbq5R6q6hAMeCOmuT8HKKjknohb5b7aU,32915
 tkSrc/classes.py,sha256=y3vFRoRsJS0UXWBrBjcG8ULUotd5NZEQedZu5TqYlPQ,3992
-tkSrc/clone.py,sha256=iPfMNVQkN3k6B6bqZ2IHI2a0Qya2aTapklxqu2A3ykQ,24437
-tkSrc/copy.py,sha256=sIiVt1gE4IJVJmwxXiHlhj-jKmYFrYSxdx3COSGG534,2011
-tkSrc/create.py,sha256=6LYdDPV4-MI2Li2Nl2rhRssVzs-zcSAThLpaK4CC-5I,29823
-tkSrc/deploy.py,sha256=FSw4ulNKV9OpVc9F6m9abrxy0LXzLbRvfUSTowpvTFo,11098
-tkSrc/destroy.py,sha256=R7wjXt-QZR_EJRi0zj1AwCiuPN4VCNWuaIg6baUeAzE,9743
+tkSrc/clone.py,sha256=x7Z3zL8n5feGShhtbnlbLX1vXM4nG3RDnS1Cowk5sNQ,24602
+tkSrc/copy.py,sha256=v_bK2B9PgljnS71X3jXmP76JM5TQMhcptjikTI6Se1Y,2110
+tkSrc/create.py,sha256=l_3tpcziwWqucXuVoaKKe9xIYxD4cvArml-RIbGJVIk,30546
+tkSrc/deploy.py,sha256=-9hVttpltj5-xHVh38cGKcfxqAIyFSgv5LwbrDNTTN4,11250
+tkSrc/destroy.py,sha256=l8VTmsZy2hjjt0zicckSanMgyeRiGM0-xxFdHwfJEvg,10102
 tkSrc/helpers.py,sha256=8tGOVsmppExCeclfAmoyYr_iUzrUxylpytMMRUIKAB8,26916
-tkSrc/ipr.py,sha256=jtPyaUm7dOAezJbh8KoIEcYdqwAUG_AeY0XyZcCK-GU,4912
-tkSrc/list.py,sha256=usUgWx7zPwlNA2ndeZhh_m10MYbT9-VJOmMAgGx2qIk,19392
-tkSrc/manage.py,sha256=CL6BKukA70x_A542HRtlGGn6PlYNKS5WyfspmyZccDM,16912
+tkSrc/ipr.py,sha256=7FBCdgJRCn_W3Op_GW-X6DPOSZnIuNELoLe7kDfDVOA,4966
+tkSrc/list.py,sha256=Lr-lshwgO3OE2QrPlw2tMrY6_NwWP1vq8EsQSNN0wT0,19735
+tkSrc/manage.py,sha256=mW66JGHQ97EWPwMKccfGHFkkOt7EBsvyaFzLANTU6VQ,17439
 tkSrc/parser.py,sha256=afxHFUE8Y549Yue4utmCZX-8Yg5Ir1vZema9P-JA6l0,81403
-tkSrc/unmanage.py,sha256=UnbLOD-zmQOyjY1bnnAj6cSowRqkf0AVqseoV89h43E,7249
-tkSrc/update.py,sha256=vplEyjae--CAUdeO07KkSTCDhcZ2d0CNg37XG123i80,12344
+tkSrc/unmanage.py,sha256=-eEzMKeI3615pV2KyhrQ3RYVaYNXtmlJwYP4kzVVkew,7451
+tkSrc/update.py,sha256=C4DyxlsdmgiDt4_bAyFNHnv2jbZ4YBGXRsy0aYgmJ5c,12714
 tkSrc/templates/jinja/app.jinja,sha256=6hkzd1kb3M2NWv1fOHERBacuIZ6Y4f-ymJthwPWHaF8,446
 tkSrc/templates/jinja/appVault.jinja,sha256=pJccPuk1Co6oGvwqYwy0kHGoLGtrmKqLMewYLovSYcU,532
 tkSrc/templates/jinja/backup.jinja,sha256=0m1Z-plkxS8xIa8QgmnnR5eNaLxHQkM1EJwgTGKOPF0,406
 tkSrc/templates/jinja/hook.jinja,sha256=shg7mtmw-pxyQPvc1ApJBk9h1ra33X5zWY6QXVnemE0,374
 tkSrc/templates/jinja/ipr.jinja,sha256=o24Gd86lkZicpwrlRRxz2asvQBDzGGpv8q7XGeNKO9A,277
 tkSrc/templates/jinja/protection.jinja,sha256=W2kXOkrkSLoHuAJJY3RFesc0HF_LSyuJ5dFBBMiwE-U,417
 tkSrc/templates/jinja/restore.jinja,sha256=yofEKvIBF5dwBVbdjIlLBoMk99JR9h97HzUmBbYaNw0,584
 tkSrc/templates/jinja/snapshot.jinja,sha256=kyEShlXwosIr7jYbywD-VcuaezhI2HpXYvVDleC7KzU,533
-actoolkit-3.0.1b7.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-actoolkit-3.0.1b7.dist-info/METADATA,sha256=3AYBxQ5W1icn_E-WdDsAktvxHsPXZpklIk4JEX5y234,9193
-actoolkit-3.0.1b7.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-actoolkit-3.0.1b7.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
-actoolkit-3.0.1b7.dist-info/top_level.txt,sha256=wWyEWMBpCvR7Kv5mt_hBl4SEOLoVTV_9blXZhzBu7Y8,23
-actoolkit-3.0.1b7.dist-info/RECORD,,
+actoolkit-3.0.1b8.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+actoolkit-3.0.1b8.dist-info/METADATA,sha256=S89HYmpHnGP1WdVKGt-2lsFBaJH32p4fhHlrcM11YHk,9193
+actoolkit-3.0.1b8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+actoolkit-3.0.1b8.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
+actoolkit-3.0.1b8.dist-info/top_level.txt,sha256=wWyEWMBpCvR7Kv5mt_hBl4SEOLoVTV_9blXZhzBu7Y8,23
+actoolkit-3.0.1b8.dist-info/RECORD,,
```

